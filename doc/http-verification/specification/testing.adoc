= URL Security Validation Testing Framework
:toc: left
:toclevels: 3
:sectnums:
:icons: font

link:../README.adoc[← Back to Documentation Overview]

[IMPORTANT]
====
This document describes HOW to test the URL Security Validation system.
For WHAT tasks to implement, see link:plan.adoc[Implementation Plan].
For HOW the system architecture works, see link:specification.adoc[Architecture Specification].
====

== Testing Philosophy

. **Generator-Based Testing**: Dynamic test data generation using TypedGenerator pattern
. **Deterministic Generation**: Using cui-tools Generator (not Random) for reproducibility
. **Comprehensive Coverage**: 36 explicit test cases covering all attack categories
. **Performance Validation**: Sub-millisecond requirement verification
. **False Positive Prevention**: Ensuring legitimate URLs pass validation
. **Mixed Responsibility Integration Testing**: Security framework tests intentionally validate both attack detection AND monitoring verification as architectural design - this provides comprehensive validation of security pipeline behavior rather than fragmented coverage

== Test Framework Structure

----
src/test/java/de/cuioss/tools/security/http/
├── config/                                  # Configuration tests
│   ├── SecurityConfigurationTest.java
│   ├── SecurityConfigurationBuilderTest.java
│   └── SecurityDefaultsTest.java
│
├── core/                                    # Core component tests
│   ├── HttpSecurityValidatorTest.java
│   ├── UrlSecurityFailureTypeTest.java
│   └── ValidationTypeTest.java
│
├── database/                                # Attack pattern databases
│   ├── AttackDatabase.java                 # Database interface
│   ├── AttackTestCase.java                 # Test case record
│   ├── ApacheCVEAttackDatabase.java        # Apache CVE patterns
│   ├── HomographAttackDatabase.java        # Unicode homograph attacks
│   ├── IDNAttackDatabase.java              # Internationalized domain attacks
│   ├── IISCVEAttackDatabase.java           # IIS CVE patterns
│   ├── IPv6AttackDatabase.java             # IPv6 address exploits
│   ├── NginxCVEAttackDatabase.java         # Nginx CVE patterns
│   ├── OWASPTop10AttackDatabase.java       # OWASP Top 10 patterns
│   └── ProtocolHandlerAttackDatabase.java  # Protocol handler exploits
│
├── exceptions/                              # Exception handling tests
│   └── UrlSecurityExceptionTest.java
│
├── generators/                              # Test data generators (organized by type)
│   ├── AllGeneratorsIntegrationTest.java   # Generator integration tests
│   ├── SupportedValidationTypeGenerator.java
│   ├── body/                               # HTTP body generators
│   │   ├── HTTPBodyGenerator.java
│   │   └── ValidHTTPBodyContentGenerator.java
│   ├── cookie/                             # Cookie generators
│   │   ├── AttackCookieGenerator.java
│   │   └── ValidCookieGenerator.java
│   ├── encoding/                           # Encoding attack generators
│   │   ├── BoundaryFuzzingGenerator.java
│   │   ├── DoubleEncodingAttackGenerator.java
│   │   ├── EncodingCombinationGenerator.java
│   │   ├── PathTraversalGenerator.java
│   │   ├── UnicodeAttackGenerator.java
│   │   ├── UnicodeControlCharacterAttackGenerator.java
│   │   └── UnicodeNormalizationAttackGenerator.java
│   ├── header/                             # HTTP header generators
│   │   ├── HttpHeaderInjectionAttackGenerator.java
│   │   ├── HTTPHeaderInjectionGenerator.java
│   │   ├── InvalidHTTPHeaderNameGenerator.java
│   │   ├── ValidHTTPHeaderNameGenerator.java
│   │   └── ValidHTTPHeaderValueGenerator.java
│   ├── injection/                          # Protocol injection generators
│   │   ├── HttpRequestSmugglingAttackGenerator.java
│   │   └── ProtocolHandlerAttackGenerator.java
│   └── url/                                # URL-specific generators
│       ├── AttackURLParameterGenerator.java
│       ├── InvalidURLGenerator.java
│       ├── NullByteInjectionParameterGenerator.java
│       ├── NullByteURLGenerator.java
│       ├── PathTraversalParameterGenerator.java
│       ├── PathTraversalURLGenerator.java
│       ├── URLLengthLimitAttackGenerator.java
│       ├── URLParameterGenerator.java
│       ├── ValidURLGenerator.java
│       ├── ValidURLParameterGenerator.java
│       ├── ValidURLParameterStringGenerator.java
│       └── ValidURLPathGenerator.java
│
├── monitoring/                              # Security monitoring tests
│   └── SecurityEventCounterTest.java
│
├── pipeline/                                # Validation pipeline tests
│   ├── HTTPBodyValidationPipelineTest.java
│   ├── HTTPHeaderValidationPipelineTest.java
│   ├── PipelineFactoryTest.java
│   ├── URLParameterValidationPipelineTest.java
│   └── URLPathValidationPipelineTest.java
│
├── tests/                                   # Attack-specific test classes
│   ├── ApacheCVEAttackDatabaseTest.java    # Apache CVE database tests
│   ├── DoubleEncodingAttackTest.java       # Double encoding attacks
│   ├── EncodedPathTraversalAttackTest.java # Encoded traversal tests
│   ├── HomographAttackDatabaseTest.java    # Homograph database tests
│   ├── HttpHeaderInjectionAttackTest.java  # Header injection tests
│   ├── HttpRequestSmugglingAttackTest.java # Request smuggling tests
│   ├── IDNAttackDatabaseTest.java          # IDN database tests
│   ├── IISCVEAttackDatabaseTest.java       # IIS CVE database tests
│   ├── IPv6AttackDatabaseTest.java         # IPv6 database tests
│   ├── MixedEncodingAttackTest.java        # Mixed encoding tests
│   ├── NginxCVEAttackDatabaseTest.java     # Nginx CVE database tests
│   ├── NullBytePathTraversalAttackTest.java # Null byte traversal tests
│   ├── OWASPTop10AttackDatabaseTest.java   # OWASP database tests
│   ├── PathTraversalAttackTest.java        # Path traversal tests
│   ├── ProtocolHandlerAttackTest.java      # Protocol handler tests
│   ├── UnicodeControlCharacterAttackTest.java # Unicode control tests
│   ├── UnicodeNormalizationAttackTest.java # Unicode normalization tests
│   ├── UnicodePathTraversalAttackTest.java # Unicode traversal tests
│   └── URLLengthLimitAttackTest.java       # URL length limit tests
│
└── validation/                              # Validation stage tests
    ├── CharacterValidationStageTest.java
    ├── DecodingStageTest.java
    ├── LengthValidationStageTest.java
    ├── NormalizationStageTest.java
    └── PatternMatchingStageTest.java
----

== Test Data Generators

The test framework uses a hierarchical generator architecture organized by attack type and validation context. All generators implement the `TypedGenerator<T>` interface from cui-test-generator.

[NOTE]
====
For complete generator contract requirements and implementation standards, see link:generator-contract.adoc[Generator Contract Specification].
====

=== Generator Architecture

**Design Principle**: Generator/Database separation
- **Generators**: Create dynamic, varied test data using algorithmic generation
- **Databases**: Store curated collections of documented attack patterns (CVEs, OWASP)

**Generator Naming Convention**:
- `Valid*Generator`: Generates legitimate input that should pass validation
- `Attack*Generator` / `Invalid*Generator`: Generates malicious/malformed input that should be rejected

=== Generator Categories

==== Encoding Attack Generators (`generators/encoding/`)
- **`PathTraversalGenerator`**: Dynamic path traversal patterns with configurable depth
- **`EncodingCombinationGenerator`**: Multi-level URL encoding combinations  
- **`DoubleEncodingAttackGenerator`**: Double/triple encoding bypass attempts
- **`UnicodeAttackGenerator`**: Unicode-based bypass patterns
- **`UnicodeControlCharacterAttackGenerator`**: Control character injection
- **`UnicodeNormalizationAttackGenerator`**: Normalization-based attacks
- **`BoundaryFuzzingGenerator`**: Boundary condition and length-based attacks

==== URL/Path Generators (`generators/url/`)
- **`ValidURLGenerator`**: RFC-compliant URLs for positive testing
- **`ValidURLPathGenerator`**: Valid path components
- **`ValidURLParameterGenerator`**: Valid URL parameters
- **`InvalidURLGenerator`**: Malformed URLs for negative testing
- **`PathTraversalURLGenerator`**: Path traversal in URL context
- **`NullByteURLGenerator`**: Null byte injection in URLs
- **`URLLengthLimitAttackGenerator`**: Length-based DoS attacks

==== HTTP Header Generators (`generators/header/`)
- **`ValidHTTPHeaderNameGenerator`**: RFC-compliant header names
- **`ValidHTTPHeaderValueGenerator`**: Valid header values
- **`InvalidHTTPHeaderNameGenerator`**: Malformed header names
- **`HttpHeaderInjectionAttackGenerator`**: CRLF injection attacks

==== Cookie Generators (`generators/cookie/`)  
- **`ValidCookieGenerator`**: RFC-compliant cookies
- **`AttackCookieGenerator`**: Cookie-based attack patterns

==== Protocol Injection Generators (`generators/injection/`)
- **`HttpRequestSmugglingAttackGenerator`**: HTTP smuggling patterns
- **`ProtocolHandlerAttackGenerator`**: Protocol handler exploits

==== HTTP Body Generators (`generators/body/`)
- **`ValidHTTPBodyContentGenerator`**: Valid body content
- **`HTTPBodyGenerator`**: Various body formats and structures

=== Attack Pattern Databases

The framework includes curated databases of documented attack patterns organized by source:

**CVE-Based Databases**:
- `ApacheCVEAttackDatabase`: Apache HTTP Server vulnerabilities (CVE-2021-41773, CVE-2021-42013)
- `NginxCVEAttackDatabase`: Nginx vulnerabilities (CVE-2013-4547, CVE-2017-7529)  
- `IISCVEAttackDatabase`: Microsoft IIS vulnerabilities

**Standards-Based Databases**:
- `OWASPTop10AttackDatabase`: OWASP Top 10 attack patterns
- `IPv6AttackDatabase`: IPv6 address parsing exploits
- `IDNAttackDatabase`: Internationalized Domain Name attacks
- `HomographAttackDatabase`: Unicode homograph attacks

Each database provides structured test cases with expected failure types and comprehensive attack documentation.

== Attack Test Implementation

=== Path Traversal Tests (T1-T4)

[source,java]
----
package de.cuioss.tools.security.http.attacks;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import de.cuioss.test.generator.junit.EnableGeneratorController;
import de.cuioss.test.generator.junit.TypeGeneratorSource;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Path traversal attack tests using TypedGenerators.
 * Implements: link:plan.adoc#_phase_71_path_traversal_attack_tests[Tasks T1-T4]
 */
@EnableGeneratorController
public class PathTraversalAttackTest {
    
    private final HttpSecurityValidator validator = createValidator();
    
    @ParameterizedTest(name = "T1: Path traversal [{index}]: {0}")
    @TypeGeneratorSource(value = PathTraversalGenerator.class, count = 100)
    void testBasicPathTraversal_T1(String attack) {
        // T1: Basic path traversal patterns from generator
        UrlSecurityException exception = assertThrows(
            UrlSecurityException.class, 
            () -> validator.execute(attack),
            "Failed to detect path traversal: " + attack
        );
        
        // Verify appropriate failure type
        assertTrue(
            exception.getFailureType() == UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED ||
            exception.getFailureType() == UrlSecurityFailureType.INVALID_CHARACTER,
            "Unexpected failure type: " + exception.getFailureType()
        );
    }
    
    @ParameterizedTest(name = "T2: Encoded [{index}]: {0}")
    @TypeGeneratorSource(value = EncodingCombinationGenerator.class, count = 100)
    void testEncodedPathTraversal_T2(String encoded) {
        // T2: URL-encoded path traversal - caught early at character validation
        UrlSecurityException exception = assertThrows(
            UrlSecurityException.class, 
            () -> validator.execute(encoded)
        );
        
        // Should be caught at character validation or as encoding issue
        assertTrue(
            exception.getFailureType() == UrlSecurityFailureType.INVALID_ENCODING ||
            exception.getFailureType() == UrlSecurityFailureType.DOUBLE_ENCODING ||
            exception.getFailureType() == UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED
        );
    }
    
    @ParameterizedTest(name = "T3: Unicode [{index}]: {0}")
    @TypeGeneratorSource(value = UnicodeAttackGenerator.class, count = 100)
    void testUnicodePathTraversal_T3(String unicode) {
        // T3: Unicode-based path traversal
        UrlSecurityException exception = assertThrows(
            UrlSecurityException.class, 
            () -> validator.execute(unicode)
        );
        
        // Should detect unicode attacks
        assertTrue(
            exception.getFailureType() == UrlSecurityFailureType.INVALID_CHARACTER ||
            exception.getFailureType() == UrlSecurityFailureType.UNICODE_NORMALIZATION_CHANGED ||
            exception.getFailureType() == UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED
        );
    }
    
    @ParameterizedTest(name = "T4: Null byte/Boundary [{index}]: {0}")
    @TypeGeneratorSource(value = BoundaryFuzzingGenerator.class, count = 50)
    void testNullBytePathTraversal_T4(String nullByteAttack) {
        // T4: Null byte injection and boundary conditions
        // BoundaryFuzzingGenerator includes null byte patterns
        UrlSecurityException exception = assertThrows(
            UrlSecurityException.class, 
            () -> validator.execute(nullByteAttack)
        );
        
        // Must be caught as appropriate security issue
        assertTrue(
            exception.getFailureType() == UrlSecurityFailureType.NULL_BYTE_INJECTION ||
            exception.getFailureType() == UrlSecurityFailureType.PATH_TOO_LONG ||
            exception.getFailureType() == UrlSecurityFailureType.EXCESSIVE_NESTING ||
            exception.getFailureType() == UrlSecurityFailureType.INVALID_CHARACTER,
            "Unexpected failure for boundary test: " + exception.getFailureType()
        );
    }
}
----

== Attack Pattern Database

=== Database Structure

[source,java]
----
package de.cuioss.tools.security.http.database;

/**
 * Central repository of attack patterns.
 * Implements: link:plan.adoc#_phase_712_integration_tasks[Task I2]
 */
public class AttackPatternDatabase {
    
    private final Map<String, AttackPattern> patterns = new HashMap<>();
    
    public record AttackPattern(
        String id,
        String name,
        String pattern,
        AttackCategory category,
        String cveReference,
        String owaspReference,
        String description,
        boolean shouldBlock,
        String justification
    ) {}
    
    public enum AttackCategory {
        PATH_TRAVERSAL,
        ENCODING_BYPASS,
        UNICODE_ATTACK,
        INJECTION,
        HTTP_SMUGGLING,
        DOS_ATTACK,
        PROTOCOL_ABUSE
    }
    
    public AttackPatternDatabase() {
        loadCVEPatterns();
        loadOWASPPatterns();
        loadModSecurityPatterns();
    }
    
    private void loadCVEPatterns() {
        // CVE-2021-41773: Apache path traversal
        patterns.put("CVE-2021-41773", new AttackPattern(
            "CVE-2021-41773",
            "Apache Path Traversal",
            "/.%2e/",
            AttackCategory.PATH_TRAVERSAL,
            "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-41773",
            "CWE-22",
            "Apache HTTP Server 2.4.49 path traversal",
            true,
            "Known critical vulnerability allowing directory traversal"
        ));
        
        // CVE-2021-42013: Apache double encoding
        patterns.put("CVE-2021-42013", new AttackPattern(
            "CVE-2021-42013",
            "Apache Double Encoding",
            "%%32%65",
            AttackCategory.ENCODING_BYPASS,
            "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-42013",
            "CWE-22",
            "Apache HTTP Server double encoding bypass",
            true,
            "Double encoding bypass of CVE-2021-41773 fix"
        ));
        
        // More CVE patterns loaded from database...
    }
}
----

== Test Execution Strategy

=== Performance Benchmarking
[[_performance_benchmarking]]

==== JMH Integration Setup

Add JMH dependency to `pom.xml`:

[source,xml]
----
<dependencies>
    <!-- JMH for performance benchmarking -->
    <dependency>
        <groupId>org.openjdk.jmh</groupId>
        <artifactId>jmh-core</artifactId>
        <version>1.37</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.openjdk.jmh</groupId>
        <artifactId>jmh-generator-annprocess</artifactId>
        <version>1.37</version>
        <scope>test</scope>
    </dependency>
</dependencies>

<build>
    <plugins>
        <!-- JMH benchmark plugin -->
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-shade-plugin</artifactId>
            <version>3.4.1</version>
            <executions>
                <execution>
                    <phase>package</phase>
                    <goals>
                        <goal>shade</goal>
                    </goals>
                    <configuration>
                        <finalName>benchmarks</finalName>
                        <transformers>
                            <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                <mainClass>org.openjdk.jmh.Main</mainClass>
                            </transformer>
                        </transformers>
                        <filters>
                            <filter>
                                <artifact>*:*</artifact>
                                <excludes>
                                    <exclude>META-INF/*.SF</exclude>
                                    <exclude>META-INF/*.DSA</exclude>
                                    <exclude>META-INF/*.RSA</exclude>
                                </excludes>
                            </filter>
                        </filters>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
----

==== Performance Benchmark Implementation

[source,java]
----
package de.cuioss.tools.security.http.attacks;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;
import java.util.concurrent.TimeUnit;

/**
 * Performance validation benchmarks with JMH integration.
 * Run with: mvn clean package && java -jar target/benchmarks.jar
 * Or: mvn exec:java -Dexec.mainClass="org.openjdk.jmh.Main" -Dexec.args="PerformanceValidationBenchmark"
 * 
 * Implements: link:plan.adoc#_phase_711_performance_validation_tests[Tasks T34-T36]
 */
@BenchmarkMode({Mode.AverageTime, Mode.Throughput})
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@Warmup(iterations = 3, time = 2, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, jvmArgs = {"-Xmx2G", "-Xms2G"})
@State(Scope.Benchmark)
public class PerformanceValidationBenchmark {
    
    private HttpSecurityValidator pathValidator;
    private HttpSecurityValidator paramNameValidator;
    private HttpSecurityValidator paramValueValidator;
    private HttpSecurityValidator headerNameValidator;
    private HttpSecurityValidator headerValueValidator;
    
    private PathTraversalGenerator attackGen;
    private ValidURLGenerator validGen;
    private EncodingCombinationGenerator encodingGen;
    private UnicodeAttackGenerator unicodeGen;
    
    @Setup(Level.Trial)
    public void setupBenchmark() {
        // Setup configuration
        UrlSecurityConfig baseConfig = UrlSecurityConfig.builder()
            .maxPathLength(2048)
            .maxDirectoryDepth(10)
            .build();
        
        SecurityEventCounter eventCounter = new SecurityEventCounter();
        
        // Create validators for different types
        pathValidator = createPathValidator(baseConfig, eventCounter);
        paramNameValidator = createParameterNameValidator(baseConfig, eventCounter);
        paramValueValidator = createParameterValueValidator(baseConfig, eventCounter);
        headerNameValidator = createHeaderNameValidator(baseConfig, eventCounter);
        headerValueValidator = createHeaderValueValidator(baseConfig, eventCounter);
        
        // Setup generators
        attackGen = new PathTraversalGenerator();
        validGen = new ValidURLGenerator();
        encodingGen = new EncodingCombinationGenerator();
        unicodeGen = new UnicodeAttackGenerator();
    }
    
    @Benchmark
    @Group("path_validation")
    public void benchmarkValidPaths_T34() {
        // T34: Verify <1ms for typical inputs
        String validPath = validGen.next();
        try {
            pathValidator.validate(validPath);
        } catch (UrlSecurityException e) {
            // Should not happen for valid URLs
        }
    }
    
    @Benchmark
    @Group("attack_detection")
    public void benchmarkPathTraversalAttacks_T35() {
        // T35: Verify <1ms even with attacks
        String attack = attackGen.next();
        try {
            pathValidator.validate(attack);
        } catch (UrlSecurityException e) {
            // Expected for attacks
        }
    }
    
    @Benchmark
    @Group("http_encoding_attacks")
    public void benchmarkHttpEncodingAttacks_T35() {
        String encodedAttack = encodingGen.next(); // HTTP protocol-layer encoding only
        try {
            pathValidator.validate(encodedAttack);
        } catch (UrlSecurityException e) {
            // Expected for HTTP protocol encoding attacks
        }
    }
    
    @Benchmark
    @Group("unicode_attacks")
    public void benchmarkUnicodeAttacks_T35() {
        String unicodeAttack = unicodeGen.next();
        try {
            pathValidator.validate(unicodeAttack);
        } catch (UrlSecurityException e) {
            // Expected for unicode attacks
        }
    }
    
    @Benchmark
    @Group("parameter_validation")
    public void benchmarkParameterNames_T36() {
        // Test parameter name validation performance
        try {
            paramNameValidator.validate("validParamName123");
        } catch (UrlSecurityException e) {
            // Should not happen for valid names
        }
    }
    
    @Benchmark
    @Group("parameter_validation")
    public void benchmarkParameterValues_T36() {
        // Test parameter value validation performance
        try {
            paramValueValidator.validate("valid%20parameter%20value");
        } catch (UrlSecurityException e) {
            // Should not happen for valid values
        }
    }
    
    @Benchmark
    @Group("header_validation")
    public void benchmarkHeaderNames_T36() {
        // Test header name validation performance
        try {
            headerNameValidator.validate("Content-Type");
        } catch (UrlSecurityException e) {
            // Should not happen for valid header names
        }
    }
    
    @Benchmark
    @Group("header_validation")
    public void benchmarkHeaderValues_T36() {
        // Test header value validation performance
        try {
            headerValueValidator.validate("application/json; charset=utf-8");
        } catch (UrlSecurityException e) {
            // Should not happen for valid header values
        }
    }
    
    private HttpSecurityValidator createPathValidator(UrlSecurityConfig baseConfig, SecurityEventCounter eventCounter) {
        ConfigStageProvider pathConfig = new URLPathConfig(baseConfig);
        return new UnifiedValidationPipeline(pathConfig, eventCounter);
    }
    
    private HttpSecurityValidator createParameterNameValidator(UrlSecurityConfig baseConfig, SecurityEventCounter eventCounter) {
        ConfigStageProvider paramNameConfig = new URLParameterNameConfig(baseConfig);
        return new UnifiedValidationPipeline(paramNameConfig, eventCounter);
    }
    
    private HttpSecurityValidator createParameterValueValidator(UrlSecurityConfig baseConfig, SecurityEventCounter eventCounter) {
        ConfigStageProvider paramValueConfig = new URLParameterValueConfig(baseConfig);
        return new UnifiedValidationPipeline(paramValueConfig, eventCounter);
    }
    
    private HttpSecurityValidator createHeaderNameValidator(UrlSecurityConfig baseConfig, SecurityEventCounter eventCounter) {
        ConfigStageProvider headerNameConfig = new HTTPHeaderNameConfig(baseConfig);
        return new UnifiedValidationPipeline(headerNameConfig, eventCounter);
    }
    
    private HttpSecurityValidator createHeaderValueValidator(UrlSecurityConfig baseConfig, SecurityEventCounter eventCounter) {
        ConfigStageProvider headerValueConfig = new HTTPHeaderValueConfig(baseConfig);
        return new UnifiedValidationPipeline(headerValueConfig, eventCounter);
    }
    
    /**
     * Main method for running benchmarks standalone
     */
    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
            .include(PerformanceValidationBenchmark.class.getSimpleName())
            .shouldDoGC(true)
            .build();
        
        new Runner(opt).run();
    }
}
----

==== Running Performance Benchmarks

===== Command Line Execution

[source,bash]
----
# Build benchmarks
mvn clean package

# Run all benchmarks
java -jar target/benchmarks.jar

# Run specific benchmark group
java -jar target/benchmarks.jar -rf json -rff results.json PerformanceValidationBenchmark.benchmarkValidPaths

# Run with custom parameters
java -jar target/benchmarks.jar -wi 5 -i 10 -f 2 -t 4
----

===== Maven Integration

[source,bash]
----
# Run via Maven exec plugin
mvn exec:java -Dexec.mainClass="org.openjdk.jmh.Main" -Dexec.args="PerformanceValidationBenchmark"

# With custom JVM options
mvn exec:java -Dexec.mainClass="org.openjdk.jmh.Main" -Dexec.args="-wi 3 -i 5 -f 1 PerformanceValidationBenchmark"
----

===== Performance Criteria

* **Target**: <1ms average time for 95% of validations
* **Throughput**: >1000 validations/second per thread
* **Memory**: No memory leaks, stable heap usage
* **Warmup**: 3 iterations × 2 seconds
* **Measurement**: 5 iterations × 3 seconds
* **Fork**: 1 JVM fork with 2GB heap

===== CI/CD Integration

Add to GitHub Actions or Jenkins:

[source,yaml]
----
- name: Run Performance Benchmarks
  run: |
    mvn clean package
    java -jar target/benchmarks.jar -rf json -rff benchmark-results.json
    # Parse results and fail if performance regression detected
    python scripts/check-performance-regression.py benchmark-results.json
----
----

== Test Coverage Requirements

=== Security Coverage Metrics

1. **Attack Pattern Coverage**: 100% of patterns in AttackPatternDatabase
2. **CVE Coverage**: All relevant CVEs from 2020-2024
3. **OWASP Coverage**: Complete OWASP Top 10 2021
4. **Encoding Coverage**: All encoding combinations up to 3 levels
5. **Unicode Coverage**: All Unicode normalization forms (NFC, NFD, NFKC, NFKD)
6. **Performance Coverage**: 95th percentile <1ms

=== False Positive Requirements

- Maximum 0.1% false positive rate on legitimate URLs
- All RFC 3986 compliant URLs must pass
- International domain names must be supported
- Valid relative paths must work correctly

== Test Quality Requirements

=== Test Coverage Requirements

* **ALL tests MUST pass** - No exceptions, no degradation threshold
* **100% attack detection** - Every known attack pattern must be blocked
* **Zero false positives** - Valid URLs must not be rejected
* **Performance requirements** - All validations must complete in <1ms

=== Regression Testing

* Maintain test case for every security issue found
* Add new CVE patterns as they are discovered  
* Update OWASP patterns with each OWASP update
* All existing tests must continue to pass

== Generator Usage Guidelines

=== Custom Test Annotations

[source,java]
----
package de.cuioss.tools.security.http.testing;

import org.junit.jupiter.params.provider.ArgumentsSource;
import java.lang.annotation.*;

/**
 * Custom annotation for generator-based tests.
 * Automatically provides test data from all security generators.
 */
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@ArgumentsSource(GeneratorsArgumentsProvider.class)
@Documented
public @interface GeneratorsSource {
    /**
     * Which generator types to use
     */
    GeneratorType[] value() default {
        GeneratorType.PATH_TRAVERSAL,
        GeneratorType.ENCODING,
        GeneratorType.UNICODE,
        GeneratorType.BOUNDARY
    };
    
    /**
     * Number of test cases to generate per generator
     */
    int limit() default 100;
}

public enum GeneratorType {
    PATH_TRAVERSAL,
    ENCODING,
    UNICODE,
    BOUNDARY,
    VALID_URL,
    INVALID_URL,
    PARAMETER_NAME,
    PARAMETER_VALUE,
    COOKIE,
    HTTP_BODY
}

/**
 * ArgumentsProvider for @GeneratorsSource annotation.
 */
public class GeneratorsArgumentsProvider implements ArgumentsProvider {
    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        GeneratorsSource annotation = context.getRequiredTestMethod()
            .getAnnotation(GeneratorsSource.class);
        
        List<Stream<Arguments>> streams = new ArrayList<>();
        
        for (GeneratorType type : annotation.value()) {
            TypedGenerator<String> generator = createGenerator(type);
            Stream<Arguments> stream = Stream.generate(() -> 
                Arguments.of(generator.next(), type.name())
            ).limit(annotation.limit());
            streams.add(stream);
        }
        
        // Combine all streams
        return streams.stream().flatMap(Function.identity());
    }
    
    private TypedGenerator<String> createGenerator(GeneratorType type) {
        return switch (type) {
            case PATH_TRAVERSAL -> new PathTraversalGenerator();
            case ENCODING -> new EncodingCombinationGenerator();
            case UNICODE -> new UnicodeAttackGenerator();
            case BOUNDARY -> new BoundaryFuzzingGenerator();
            case VALID_URL -> new ValidURLGenerator();
            case INVALID_URL -> new InvalidURLGenerator();
            case PARAMETER_NAME -> new URLParameterNameGenerator();
            case PARAMETER_VALUE -> new URLParameterValueGenerator();
            case COOKIE -> new CookieGenerator();
            case HTTP_BODY -> new HTTPBodyGenerator();
        };
    }
}
----

=== Comprehensive Test Example

== ValidationType Integration Testing

=== Testing Different Validation Types

[source,java]
----
package de.cuioss.tools.security.http.validation;

/**
 * Tests to ensure ValidationType is properly propagated through the system.
 */
public class ValidationTypeTest {
    
    @Test
    void testValidationTypeInException() {
        // Create validators for different types
        UrlSecurityConfig config = UrlSecurityConfig.builder().build();
        
        // Test URL_PATH type
        ConfigStageProvider pathConfig = new URLPathConfig(config);
        HttpSecurityValidator pathValidator = new UnifiedValidationPipeline(
            pathConfig, new SecurityEventCounter());
        
        UrlSecurityException pathException = assertThrows(
            UrlSecurityException.class,
            () -> pathValidator.execute("../../../etc/passwd")
        );
        assertEquals(ValidationType.URL_PATH, pathException.getValidationType());
        
        // Test PARAMETER_VALUE type
        ConfigStageProvider paramConfig = new URLParameterValueConfig(config);
        HttpSecurityValidator paramValidator = new UnifiedValidationPipeline(
            paramConfig, new SecurityEventCounter());
        
        UrlSecurityException paramException = assertThrows(
            UrlSecurityException.class,
            () -> paramValidator.execute("<script>alert(1)</script>")
        );
        assertEquals(ValidationType.PARAMETER_VALUE, paramException.getValidationType());
        
        // Test HEADER_VALUE type
        ConfigStageProvider headerConfig = new HTTPHeaderValueConfig(config);
        HttpSecurityValidator headerValidator = new UnifiedValidationPipeline(
            headerConfig, new SecurityEventCounter());
        
        UrlSecurityException headerException = assertThrows(
            UrlSecurityException.class,
            () -> headerValidator.execute("Bearer\\r\\nX-Injected: true")
        );
        assertEquals(ValidationType.HEADER_VALUE, headerException.getValidationType());
    }
    
    @Test
    void testValidationTypeConsistency() {
        // Ensure ValidationType is consistent across all stages in a pipeline
        UrlSecurityConfig config = UrlSecurityConfig.builder().build();
        ConfigStageProvider pathConfig = new URLPathConfig(config);
        
        // All stages should report the same ValidationType
        assertEquals(ValidationType.URL_PATH, pathConfig.getValidationType());
        for (HttpSecurityValidator stage : pathConfig.getStages()) {
            if (stage != null) {
                assertEquals(ValidationType.URL_PATH, stage.getType());
            }
        }
    }
}
----

== Comprehensive Security Testing

[source,java]
----
package de.cuioss.tools.security.http.attacks;

import org.junit.jupiter.params.ParameterizedTest;
import de.cuioss.test.generator.junit.EnableGeneratorController;
import de.cuioss.test.generator.junit.TypeGeneratorSource;
import de.cuioss.test.generator.junit.CompositeTypeGeneratorSource;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive security test using all generators.
 */
@EnableGeneratorController
public class ComprehensiveSecurityTest {
    
    private final HttpSecurityValidator pathValidator = createPathValidator();
    private final HttpSecurityValidator paramValidator = createParameterValidator();
    private final HttpSecurityValidator headerValidator = createHeaderValidator();
    
    private HttpSecurityValidator createPathValidator() {
        UrlSecurityConfig baseConfig = UrlSecurityConfig.builder().build();
        ConfigStageProvider pathConfig = new URLPathConfig(baseConfig);
        return new UnifiedValidationPipeline(pathConfig, new SecurityEventCounter());
    }
    
    private HttpSecurityValidator createParameterValidator() {
        UrlSecurityConfig baseConfig = UrlSecurityConfig.builder().build();
        ConfigStageProvider paramConfig = new URLParameterValueConfig(baseConfig);
        return new UnifiedValidationPipeline(paramConfig, new SecurityEventCounter());
    }
    
    private HttpSecurityValidator createHeaderValidator() {
        UrlSecurityConfig baseConfig = UrlSecurityConfig.builder().build();
        ConfigStageProvider headerConfig = new HTTPHeaderValueConfig(baseConfig);
        return new UnifiedValidationPipeline(headerConfig, new SecurityEventCounter());
    }
    
    @ParameterizedTest(name = "Attack detection [{index}]: {0}")
    @CompositeTypeGeneratorSource(
        generatorClasses = {
            PathTraversalGenerator.class,
            EncodingCombinationGenerator.class,
            UnicodeAttackGenerator.class,
            BoundaryFuzzingGenerator.class
        }, 
        count = 200
    )
    void testAllAttackPatterns(String attack) {
        // All attack patterns should be blocked
        UrlSecurityException exception = assertThrows(
            UrlSecurityException.class,
            () -> pathValidator.execute(attack),
            "Failed to detect attack: " + attack
        );
        
        // Verify ValidationType is properly set
        assertEquals(ValidationType.URL_PATH, exception.getValidationType(),
            "Exception should include ValidationType");
        
        // Log failure type for analysis
        logger.debug("Detected {} for attack (type: {}): {}", 
            exception.getFailureType(), 
            exception.getValidationType(), attack);
    }
    
    @ParameterizedTest(name = "Valid URL [{index}]")
    @TypeGeneratorSource(value = ValidURLGenerator.class, count = 500)
    void testValidURLs(String validUrl) {
        // Valid URLs should pass without exception
        String result = assertDoesNotThrow(
            () -> pathValidator.execute(validUrl),
            "False positive for valid URL: " + validUrl
        );
        
        assertNotNull(result);
        // Result might be normalized but should still be valid
        assertTrue(isValidPath(result));
    }
    
    @ParameterizedTest(name = "Parameter validation [{index}]")
    @TypeGeneratorSource(value = ValidURLGenerator.class, count = 200)
    void testParameterValidation(String paramValue) {
        // Test parameter-specific validation
        // URLParameterValueGenerator creates both attack and valid parameters
        try {
            String result = paramValidator.execute(paramValue);
            // Valid parameter passed
            assertNotNull(result);
        } catch (UrlSecurityException e) {
            // Attack parameter detected - verify it's a known attack type
            assertTrue(
                e.getFailureType() == UrlSecurityFailureType.INVALID_CHARACTER ||
                e.getFailureType() == UrlSecurityFailureType.INVALID_ENCODING ||
                e.getFailureType() == UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED ||
                e.getFailureType() == UrlSecurityFailureType.SUSPICIOUS_PATTERN
            );
        }
    }
    
    @ParameterizedTest(name = "Boundary fuzzing [{index}]")
    @TypeGeneratorSource(value = BoundaryFuzzingGenerator.class, count = 100)
    void testBoundaryConditions(String boundary) {
        // Boundary conditions should be handled gracefully
        try {
            pathValidator.execute(boundary);
            // If it passes, verify length constraints
            assertTrue(boundary.length() <= UrlSecurityConfig.DEFAULT_MAX_PATH_LENGTH);
        } catch (UrlSecurityException e) {
            // Expected for oversized or malformed inputs
            assertTrue(
                e.getFailureType() == UrlSecurityFailureType.PATH_TOO_LONG ||
                e.getFailureType() == UrlSecurityFailureType.EXCESSIVE_NESTING ||
                e.getFailureType() == UrlSecurityFailureType.INVALID_CHARACTER
            );
        }
    }
    
    @Test
    void testGeneratorCoverage() {
        // Verify all generators produce unique patterns
        Set<String> uniquePatterns = new HashSet<>();
        PathTraversalGenerator gen = new PathTraversalGenerator();
        
        for (int i = 0; i < 1000; i++) {
            uniquePatterns.add(gen.next());
        }
        
        // Should generate many unique patterns
        assertTrue(uniquePatterns.size() > 500, 
            "Generator should produce diverse patterns");
    }
}
----

=== Best Practices

1. **Always use TypedGenerator interface** - Ensures type safety
2. **Use Generator class, never Random** - Maintains determinism  
3. **Respect configuration limits** - Check DEFAULT_* constants
4. **Document attack sources** - Include CVE/OWASP references
5. **Test generators themselves** - Task G10 validates all generators
6. **Use @GeneratorsSource** - For comprehensive parameterized testing
7. **Combine generators** - Test interaction between different attack types
8. **Track failure types** - Ensure attacks are caught for the right reasons

=== Additional Test Examples

[source,java]
----
/**
 * False positive prevention tests.
 * Implements: link:plan.adoc#_phase_710_false_positive_prevention_tests[Tasks T31-T33]
 */
public class FalsePositiveTest {
    
    private final HttpSecurityValidator validator = createValidator();
    
    @ParameterizedTest(name = "Valid URLs should pass [{index}]: {0}")
    @GeneratorsSource(value = GeneratorType.VALID_URL, limit = 500)
    void testValidURLsNoFalsePositives(String validUrl, String generatorType) {
        // T31: Legitimate paths should pass validation
        String result = assertDoesNotThrow(
            () -> validator.execute(validUrl),
            "False positive on valid URL: " + validUrl
        );
        
        // Result should be non-null and potentially normalized
        assertNotNull(result);
    }
    
    @ParameterizedTest(name = "Invalid URLs should fail [{index}]: {0}")
    @GeneratorsSource(value = GeneratorType.INVALID_URL, limit = 200)
    void testInvalidURLsDetected(String invalidUrl, String generatorType) {
        // T32: Malformed URLs should be rejected
        assertThrows(
            UrlSecurityException.class,
            () -> validator.execute(invalidUrl),
            "Failed to detect invalid URL: " + invalidUrl
        );
    }
}

/**
 * Performance validation tests.
 * Implements: link:plan.adoc#_phase_711_performance_validation_tests[Tasks T34-T36]
 */
public class PerformanceValidationTest {
    
    private final HttpSecurityValidator validator = createValidator();
    
    @ParameterizedTest(name = "Performance test [{index}]")
    @GeneratorsSource(value = {
        GeneratorType.VALID_URL,
        GeneratorType.PATH_TRAVERSAL,
        GeneratorType.ENCODING
    }, limit = 1000)
    void testPerformanceUnderLoad_T34(String input, String generatorType) {
        // T34-T36: Verify <1ms performance requirement
        long startTime = System.nanoTime();
        
        try {
            validator.execute(input);
        } catch (UrlSecurityException e) {
            // Expected for attack inputs
        }
        
        long duration = System.nanoTime() - startTime;
        long durationMs = duration / 1_000_000;
        
        // Must complete within 1ms
        assertTrue(durationMs < 1, 
            "Validation took " + durationMs + "ms for " + generatorType);
    }
}

/**
 * Cookie and HTTP body validation tests.
 */
public class HTTPDataValidationTest {
    
    private final HttpSecurityValidator cookieValidator = createCookieValidator();
    private final HttpSecurityValidator bodyValidator = createBodyValidator();
    
    @ParameterizedTest(name = "Cookie validation [{index}]")
    @GeneratorsSource(value = GeneratorType.COOKIE, limit = 100)
    void testCookieValidation(String cookieValue, String generatorType) {
        // CookieGenerator creates both valid and attack cookies
        try {
            String result = cookieValidator.execute(cookieValue);
            // Valid cookie
            assertNotNull(result);
        } catch (UrlSecurityException e) {
            // Attack cookie detected
            assertNotNull(e.getFailureType());
        }
    }
    
    @ParameterizedTest(name = "HTTP body validation [{index}]")
    @GeneratorsSource(value = GeneratorType.HTTP_BODY, limit = 100)
    void testHTTPBodyValidation(String bodyContent, String generatorType) {
        // HTTPBodyGenerator creates various body content types
        try {
            String result = bodyValidator.execute(bodyContent);
            // Valid body content
            assertNotNull(result);
        } catch (UrlSecurityException e) {
            // Malicious body content detected
            assertNotNull(e.getFailureType());
        }
    }
}

/**
 * Combined attack tests using multiple generators.
 */
public class CombinedAttackTest {
    
    private final HttpSecurityValidator validator = createValidator();
    
    @ParameterizedTest(name = "Combined attacks [{index}]: {1}")
    @GeneratorsSource(value = {
        GeneratorType.PATH_TRAVERSAL,
        GeneratorType.ENCODING,
        GeneratorType.UNICODE,
        GeneratorType.BOUNDARY
    }, limit = 50)  // 50 each = 200 total tests
    void testAllAttackTypes(String attack, String generatorType) {
        // Test that all attack types are properly detected
        UrlSecurityException exception = assertThrows(
            UrlSecurityException.class,
            () -> validator.execute(attack),
            "Failed to detect " + generatorType + " attack: " + attack
        );
        
        // Track which failure types are triggered by which generators
        logger.info("Generator: {} -> FailureType: {}", 
            generatorType, exception.getFailureType());
    }
    
    @ParameterizedTest(name = "Mixed valid/invalid [{index}]: {1}")
    @GeneratorsSource(value = {
        GeneratorType.VALID_URL,
        GeneratorType.INVALID_URL,
        GeneratorType.PATH_TRAVERSAL
    }, limit = 33)  // ~100 total tests mixed
    void testMixedInputs(String input, String generatorType) {
        // Test mix of valid and invalid inputs
        boolean isValid = generatorType.equals("VALID_URL");
        
        if (isValid) {
            assertDoesNotThrow(() -> validator.execute(input));
        } else {
            assertThrows(UrlSecurityException.class, 
                () -> validator.execute(input));
        }
    }
}
----

== Success Criteria

The test harness achieves success when:

1. ✅ **ALL tests pass** - No failures accepted
2. ✅ All 10 generators (G1-G10) implemented and tested
3. ✅ All 36 test cases (T1-T36) passing
4. ✅ 100% of known CVE patterns blocked
5. ✅ OWASP Top 10 compliance achieved
6. ✅ <1ms performance for ALL validations
7. ✅ Zero false positives - valid URLs must pass
8. ✅ Zero false negatives - all attacks must be detected
8. ✅ CI/CD integration complete
9. ✅ Comprehensive reporting available
