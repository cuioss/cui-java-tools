= URL Security Validation Test Harness Design
:toc: left
:toclevels: 3
:sectnums:
:icons: font

link:README.adoc[← Back to Documentation Index]

[IMPORTANT]
====
This document describes HOW to test the URL Security Validation system.
For WHAT tasks to implement, see link:plan.adoc[Implementation Plan].
For HOW the system architecture works, see link:specification.adoc[Architecture Specification].
====

== Testing Philosophy

. **Generator-Based Testing**: Dynamic test data generation using TypedGenerator pattern
. **Deterministic Generation**: Using cui-tools Generator (not Random) for reproducibility
. **Comprehensive Coverage**: 36 explicit test cases covering all attack categories
. **Performance Validation**: Sub-millisecond requirement verification
. **False Positive Prevention**: Ensuring legitimate URLs pass validation

== Test Framework Structure

----
src/test/java/de/cuioss/tools/security/http/
├── generators/                              # Test data generators
│   ├── PathTraversalGenerator.java         # Path traversal patterns
│   ├── EncodingCombinationGenerator.java   # Encoding combinations
│   ├── UnicodeAttackGenerator.java         # Unicode attacks
│   ├── BoundaryFuzzingGenerator.java       # Boundary conditions
│   ├── ValidURLGenerator.java              # Valid URLs
│   ├── InvalidURLGenerator.java            # Malformed URLs
│   ├── URLParameterGenerator.java          # URL parameters
│   ├── CookieGenerator.java                # Cookie data
│   ├── HTTPBodyGenerator.java              # HTTP body content
│   └── GeneratorTestSuite.java             # Generator tests
│
├── attacks/                                 # Attack test cases
│   ├── PathTraversalAttackTest.java        # Path traversal tests
│   ├── EncodingAttackTest.java             # Encoding attack tests
│   ├── UnicodeAttackTest.java              # Unicode attack tests
│   ├── InjectionAttackTest.java            # Injection tests
│   ├── HTTPAttackTest.java                 # HTTP-specific tests
│   ├── DoSAttackTest.java                  # DoS attack tests
│   ├── ProtocolEdgeCaseTest.java           # Protocol edge cases
│   ├── CVEValidationTest.java              # Known CVE tests
│   ├── OWASPComplianceTest.java            # OWASP compliance
│   ├── FalsePositiveTest.java              # False positive tests
│   └── PerformanceValidationTest.java      # Performance tests
│
├── database/                                # Attack patterns
│   ├── AttackPatternDatabase.java          # Pattern repository
│   ├── CVEPatterns.java                    # CVE patterns
│   └── OWASPPatterns.java                  # OWASP patterns
│
└── harness/                                 # Test orchestration
    ├── SecurityTestSuite.java              # Main test suite
    ├── TestReporter.java                   # Report generation
    └── SecurityCoverageAnalyzer.java       # Coverage analysis
----

== Test Data Generators

=== G1: PathTraversalGenerator

[source,java]
----
package de.cuioss.tools.security.http.generators;

import de.cuioss.test.generator.TypedGenerator;
import de.cuioss.test.generator.Generators;

/**
 * Generates path traversal attack patterns.
 * Implements: link:plan.adoc#_phase_1_test_infrastructure_and_generators[Task G1]
 */
public class PathTraversalGenerator implements TypedGenerator<String> {
    
    private static final TypedGenerator<String> BASE_PATTERNS = Generators.fixedValues(
        "../", ".../", "..\\", "..\\\\",
        ".%2e/", "%2e%2e/", "%2e%2e%2f",
        "..;/", "..\\../", "..//..//"
    );
    
    private static final TypedGenerator<String> TARGET_FILES = Generators.fixedValues(
        "etc/passwd", "etc/shadow", "etc/hosts",
        "windows/system32/config/sam",
        "windows/win.ini", "boot.ini"
    );
    
    private final TypedGenerator<Integer> depthGen = Generators.integers(1, 10);
    
    @Override
    public String next() {
        int depth = depthGen.next();
        String pattern = BASE_PATTERNS.next();
        String target = TARGET_FILES.next();
        
        StringBuilder attack = new StringBuilder();
        for (int i = 0; i < depth; i++) {
            attack.append(pattern);
        }
        attack.append(target);
        
        return attack.toString();
    }
    
    @Override
    public Class<String> getType() {
        return String.class;
    }
}
----

=== G2: EncodingCombinationGenerator

[source,java]
----
package de.cuioss.tools.security.http.generators;

import de.cuioss.test.generator.TypedGenerator;
import de.cuioss.test.generator.Generators;

/**
 * Generates various encoding combinations for bypass attempts.
 * Implements: link:plan.adoc#_phase_1_test_infrastructure_and_generators[Task G2]
 */
public class EncodingCombinationGenerator implements TypedGenerator<String> {
    
    private final TypedGenerator<Integer> encodingLevelGen = Generators.integers(1, 3);
    private final TypedGenerator<Boolean> mixedCaseGen = Generators.booleans();
    
    @Override
    public String next() {
        int level = encodingLevelGen.next();
        boolean mixedCase = mixedCaseGen.next();
        
        String encoded = "../";
        
        // Apply encoding levels
        for (int i = 0; i < level; i++) {
            encoded = urlEncode(encoded);
        }
        
        // Apply mixed case if selected
        if (mixedCase) {
            encoded = applyMixedCase(encoded);
        }
        
        return encoded;
    }
    
    private String urlEncode(String input) {
        // URL encode with %25 for % in multi-level
        return input.replace(".", "%2e")
                   .replace("/", "%2f")
                   .replace("%", "%25");
    }
    
    private String applyMixedCase(String input) {
        // Mix uppercase and lowercase in hex encoding
        return input.replaceAll("%2e", "%2E")
                   .replaceAll("%2f", "%2F");
    }
    
    @Override
    public Class<String> getType() {
        return String.class;
    }
}
----

=== G3: UnicodeAttackGenerator

[source,java]
----
package de.cuioss.tools.security.http.generators;

import de.cuioss.test.generator.TypedGenerator;
import de.cuioss.test.generator.Generators;

/**
 * Generates Unicode-based attack patterns.
 * Implements: link:plan.adoc#_phase_1_test_infrastructure_and_generators[Task G3]
 */
public class UnicodeAttackGenerator implements TypedGenerator<String> {
    
    private static final TypedGenerator<String> UNICODE_ATTACKS = Generators.fixedValues(
        "\u002e\u002e\u002f",           // Unicode dots and slash
        "\u2024\u2024\u2215",           // Lookalike characters
        "\u202e",                       // Right-to-left override
        "\u200b",                       // Zero-width space
        "\uFEFF",                       // Zero-width no-break space
        "\u0000"                        // Null character
    );
    
    private final TypedGenerator<Boolean> combineGen = Generators.booleans();
    
    @Override
    public String next() {
        String attack = UNICODE_ATTACKS.next();
        
        if (combineGen.next()) {
            // Combine with path traversal
            return attack + "../etc/passwd";
        }
        
        return attack;
    }
    
    @Override
    public Class<String> getType() {
        return String.class;
    }
}
----

=== G4: BoundaryFuzzingGenerator

[source,java]
----
package de.cuioss.tools.security.http.generators;

import de.cuioss.test.generator.TypedGenerator;
import de.cuioss.test.generator.Generators;

/**
 * Generates boundary condition test cases.
 * Implements: link:plan.adoc#_phase_1_test_infrastructure_and_generators[Task G4]
 */
public class BoundaryFuzzingGenerator implements TypedGenerator<String> {
    
    private final TypedGenerator<Integer> lengthGen = Generators.integers(1000, 10000);
    private final TypedGenerator<Integer> nestingGen = Generators.integers(50, 200);
    private final TypedGenerator<Integer> typeGen = Generators.integers(0, 5);
    
    @Override
    public String next() {
        int type = typeGen.next();
        
        return switch (type) {
            case 0 -> generateLongPath();
            case 1 -> generateDeepNesting();
            case 2 -> generateNullBytes();
            case 3 -> generateControlCharacters();
            case 4 -> generateMixedBoundaryAttacks();
            default -> generateSpecialChars();
        };
    }
    
    private String generateLongPath() {
        int length = lengthGen.next();
        StringBuilder path = new StringBuilder("/");
        while (path.length() < length) {
            path.append("verylongpathsegment/");
        }
        return path.toString();
    }
    
    private String generateDeepNesting() {
        int depth = nestingGen.next();
        return "dir/".repeat(depth);
    }
    
    private String generateNullBytes() {
        TypedGenerator<String> patterns = Generators.fixedValues(
            "/file\u0000.txt",              // Raw null byte
            "/admin%00.php",                // Encoded null byte  
            "../etc/passwd%00.jpg",         // Path traversal with null
            "file.jsp%00.png",              // Extension bypass
            "%00../../etc/shadow"           // Leading null byte
        );
        return patterns.next();
    }
    
    private String generateControlCharacters() {
        // Various control characters that should be rejected
        TypedGenerator<String> controls = Generators.fixedValues(
            "/file\r\n.txt",                // CRLF injection
            "/path\t\tfile",                // Tab characters
            "/dir\b\bfile",                 // Backspace
            "/test\u001Ffile"               // Unit separator
        );
        return controls.next();
    }
    
    private String generateMixedBoundaryAttacks() {
        // Combine multiple boundary issues
        TypedGenerator<Integer> attackGen = Generators.integers(0, 3);
        int attack = attackGen.next();
        return switch (attack) {
            case 0 -> "../".repeat(100) + "etc/passwd";  // Excessive traversal
            case 1 -> "/a".repeat(2000);                  // Near max length
            case 2 -> "/%00" + "../".repeat(10);          // Null + traversal
            default -> "/\u0000/../\u0000/../file";       // Multiple nulls
        };
    }
    
    private String generateSpecialChars() {
        // Other special characters
        TypedGenerator<String> specials = Generators.fixedValues(
            "/file|command",                // Pipe character
            "/file;command",                // Semicolon
            "/file`command`",               // Backticks
            "/file$variable",               // Variable expansion
            "/file>output"                  // Redirection
        );
        return specials.next();
    }
    
    @Override
    public Class<String> getType() {
        return String.class;
    }
}
----

=== G5: ValidURLGenerator

[source,java]
----
package de.cuioss.tools.security.http.generators;

import de.cuioss.test.generator.TypedGenerator;
import de.cuioss.test.generator.Generators;
import de.cuioss.tools.security.http.config.UrlSecurityConfig;

/**
 * Generates legitimate URLs that should pass validation.
 * Implements: link:plan.adoc#_phase_1_test_infrastructure_and_generators[Task G5]
 */
public class ValidURLGenerator implements TypedGenerator<String> {
    
    private static final TypedGenerator<String> VALID_PATHS = Generators.fixedValues(
        "/api/v1/users",
        "/static/css/style.css",
        "/index.html",
        "/docs/guide.pdf",
        "/search?q=test&limit=10",
        "/products/123/reviews",
        "/admin/dashboard"
    );
    
    private static final TypedGenerator<String> SORT_OPTIONS = Generators.fixedValues("asc", "desc");
    
    private final TypedGenerator<Boolean> paramGen = Generators.booleans();
    private final TypedGenerator<Integer> pageGen = Generators.integers(1, 100);
    
    @Override
    public String next() {
        String path = VALID_PATHS.next();
        
        if (paramGen.next()) {
            // Add valid parameters
            path += "?page=" + pageGen.next();
            path += "&sort=" + SORT_OPTIONS.next();
        }
        
        // Ensure within DEFAULT_MAX_PATH_LENGTH (2048)
        if (path.length() > UrlSecurityConfig.DEFAULT_MAX_PATH_LENGTH) {
            path = path.substring(0, UrlSecurityConfig.DEFAULT_MAX_PATH_LENGTH);
        }
        
        return path;
    }
    
    @Override
    public Class<String> getType() {
        return String.class;
    }
}
----

== Attack Test Implementation

=== Path Traversal Tests (T1-T4)

[source,java]
----
package de.cuioss.tools.security.http.attacks;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import de.cuioss.test.generator.junit.EnableGeneratorController;
import de.cuioss.test.generator.junit.TypeGeneratorSource;
import de.cuioss.tools.security.http.generators.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Path traversal attack tests using TypedGenerators.
 * Implements: link:plan.adoc#_phase_71_path_traversal_attack_tests[Tasks T1-T4]
 */
@EnableGeneratorController
public class PathTraversalAttackTest {
    
    private final HttpSecurityValidator validator = createValidator();
    
    @ParameterizedTest(name = "T1: Path traversal [{index}]: {0}")
    @TypeGeneratorSource(value = PathTraversalGenerator.class, count = 100)
    void testBasicPathTraversal_T1(String attack) {
        // T1: Basic path traversal patterns from generator
        UrlSecurityException exception = assertThrows(
            UrlSecurityException.class, 
            () -> validator.execute(attack),
            "Failed to detect path traversal: " + attack
        );
        
        // Verify appropriate failure type
        assertTrue(
            exception.getFailureType() == UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED ||
            exception.getFailureType() == UrlSecurityFailureType.INVALID_CHARACTER,
            "Unexpected failure type: " + exception.getFailureType()
        );
    }
    
    @ParameterizedTest(name = "T2: Encoded [{index}]: {0}")
    @TypeGeneratorSource(value = EncodingCombinationGenerator.class, count = 100)
    void testEncodedPathTraversal_T2(String encoded) {
        // T2: URL-encoded path traversal - caught early at character validation
        UrlSecurityException exception = assertThrows(
            UrlSecurityException.class, 
            () -> validator.execute(encoded)
        );
        
        // Should be caught at character validation or as encoding issue
        assertTrue(
            exception.getFailureType() == UrlSecurityFailureType.INVALID_ENCODING ||
            exception.getFailureType() == UrlSecurityFailureType.DOUBLE_ENCODING ||
            exception.getFailureType() == UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED
        );
    }
    
    @ParameterizedTest(name = "T3: Unicode [{index}]: {0}")
    @TypeGeneratorSource(value = UnicodeAttackGenerator.class, count = 100)
    void testUnicodePathTraversal_T3(String unicode) {
        // T3: Unicode-based path traversal
        UrlSecurityException exception = assertThrows(
            UrlSecurityException.class, 
            () -> validator.execute(unicode)
        );
        
        // Should detect unicode attacks
        assertTrue(
            exception.getFailureType() == UrlSecurityFailureType.INVALID_CHARACTER ||
            exception.getFailureType() == UrlSecurityFailureType.UNICODE_NORMALIZATION_CHANGED ||
            exception.getFailureType() == UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED
        );
    }
    
    @ParameterizedTest(name = "T4: Null byte/Boundary [{index}]: {0}")
    @TypeGeneratorSource(value = BoundaryFuzzingGenerator.class, count = 50)
    void testNullBytePathTraversal_T4(String nullByteAttack) {
        // T4: Null byte injection and boundary conditions
        // BoundaryFuzzingGenerator includes null byte patterns
        UrlSecurityException exception = assertThrows(
            UrlSecurityException.class, 
            () -> validator.execute(nullByteAttack)
        );
        
        // Must be caught as appropriate security issue
        assertTrue(
            exception.getFailureType() == UrlSecurityFailureType.NULL_BYTE_INJECTION ||
            exception.getFailureType() == UrlSecurityFailureType.PATH_TOO_LONG ||
            exception.getFailureType() == UrlSecurityFailureType.EXCESSIVE_NESTING ||
            exception.getFailureType() == UrlSecurityFailureType.INVALID_CHARACTER,
            "Unexpected failure for boundary test: " + exception.getFailureType()
        );
    }
}
----

== Attack Pattern Database

=== Database Structure

[source,java]
----
package de.cuioss.tools.security.http.database;

/**
 * Central repository of attack patterns.
 * Implements: link:plan.adoc#_phase_712_integration_tasks[Task I2]
 */
public class AttackPatternDatabase {
    
    private final Map<String, AttackPattern> patterns = new HashMap<>();
    
    public record AttackPattern(
        String id,
        String name,
        String pattern,
        AttackCategory category,
        String cveReference,
        String owaspReference,
        String description,
        boolean shouldBlock,
        String justification
    ) {}
    
    public enum AttackCategory {
        PATH_TRAVERSAL,
        ENCODING_BYPASS,
        UNICODE_ATTACK,
        INJECTION,
        HTTP_SMUGGLING,
        DOS_ATTACK,
        PROTOCOL_ABUSE
    }
    
    public AttackPatternDatabase() {
        loadCVEPatterns();
        loadOWASPPatterns();
        loadModSecurityPatterns();
    }
    
    private void loadCVEPatterns() {
        // CVE-2021-41773: Apache path traversal
        patterns.put("CVE-2021-41773", new AttackPattern(
            "CVE-2021-41773",
            "Apache Path Traversal",
            "/.%2e/",
            AttackCategory.PATH_TRAVERSAL,
            "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-41773",
            "CWE-22",
            "Apache HTTP Server 2.4.49 path traversal",
            true,
            "Known critical vulnerability allowing directory traversal"
        ));
        
        // CVE-2021-42013: Apache double encoding
        patterns.put("CVE-2021-42013", new AttackPattern(
            "CVE-2021-42013",
            "Apache Double Encoding",
            "%%32%65",
            AttackCategory.ENCODING_BYPASS,
            "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-42013",
            "CWE-22",
            "Apache HTTP Server double encoding bypass",
            true,
            "Double encoding bypass of CVE-2021-41773 fix"
        ));
        
        // More CVE patterns loaded from database...
    }
}
----

== Test Execution Strategy

=== Performance Benchmarking

[source,java]
----
package de.cuioss.tools.security.http.attacks;

import org.openjdk.jmh.annotations.*;
import java.util.concurrent.TimeUnit;

/**
 * Performance validation benchmarks.
 * Implements: link:plan.adoc#_phase_711_performance_validation_tests[Tasks T34-T36]
 */
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@State(Scope.Benchmark)
public class PerformanceValidationBenchmark {
    
    private HttpSecurityValidator validator;
    private PathTraversalGenerator attackGen;
    private ValidURLGenerator validGen;
    
    @Setup
    public void setup() {
        UrlSecurityConfig baseConfig = UrlSecurityConfig.builder().build();
        ConfigStageProvider pathConfig = new URLPathConfig(baseConfig);
        validator = new UnifiedValidationPipeline(
            pathConfig,
            new SecurityEventCounter()
        );
        attackGen = new PathTraversalGenerator();
        validGen = new ValidURLGenerator();
    }
    
    @Benchmark
    public void benchmarkNormalLoad_T34() {
        // T34: Verify <1ms for typical inputs
        String valid = validGen.next();
        try {
            validator.execute(valid);
        } catch (UrlSecurityException e) {
            // Should not happen for valid URLs
        }
    }
    
    @Benchmark
    public void benchmarkAttackPayload_T35() {
        // T35: Verify <1ms even with attacks
        String attack = attackGen.next();
        try {
            validator.execute(attack);
        } catch (UrlSecurityException e) {
            // Expected for attacks
        }
    }
}
----

== Test Coverage Requirements

=== Security Coverage Metrics

1. **Attack Pattern Coverage**: 100% of patterns in AttackPatternDatabase
2. **CVE Coverage**: All relevant CVEs from 2020-2024
3. **OWASP Coverage**: Complete OWASP Top 10 2021
4. **Encoding Coverage**: All encoding combinations up to 3 levels
5. **Unicode Coverage**: All Unicode normalization forms (NFC, NFD, NFKC, NFKD)
6. **Performance Coverage**: 95th percentile <1ms

=== False Positive Requirements

- Maximum 0.1% false positive rate on legitimate URLs
- All RFC 3986 compliant URLs must pass
- International domain names must be supported
- Valid relative paths must work correctly

== Test Quality Requirements

=== Test Coverage Requirements

* **ALL tests MUST pass** - No exceptions, no degradation threshold
* **100% attack detection** - Every known attack pattern must be blocked
* **Zero false positives** - Valid URLs must not be rejected
* **Performance requirements** - All validations must complete in <1ms

=== Regression Testing

* Maintain test case for every security issue found
* Add new CVE patterns as they are discovered  
* Update OWASP patterns with each OWASP update
* All existing tests must continue to pass

== Generator Usage Guidelines

=== Custom Test Annotations

[source,java]
----
package de.cuioss.tools.security.http.testing;

import org.junit.jupiter.params.provider.ArgumentsSource;
import java.lang.annotation.*;

/**
 * Custom annotation for generator-based tests.
 * Automatically provides test data from all security generators.
 */
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@ArgumentsSource(GeneratorsArgumentsProvider.class)
@Documented
public @interface GeneratorsSource {
    /**
     * Which generator types to use
     */
    GeneratorType[] value() default {
        GeneratorType.PATH_TRAVERSAL,
        GeneratorType.ENCODING,
        GeneratorType.UNICODE,
        GeneratorType.BOUNDARY
    };
    
    /**
     * Number of test cases to generate per generator
     */
    int limit() default 100;
}

public enum GeneratorType {
    PATH_TRAVERSAL,
    ENCODING,
    UNICODE,
    BOUNDARY,
    VALID_URL,
    INVALID_URL,
    URL_PARAMETER,
    COOKIE,
    HTTP_BODY
}

/**
 * ArgumentsProvider for @GeneratorsSource annotation.
 */
public class GeneratorsArgumentsProvider implements ArgumentsProvider {
    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        GeneratorsSource annotation = context.getRequiredTestMethod()
            .getAnnotation(GeneratorsSource.class);
        
        List<Stream<Arguments>> streams = new ArrayList<>();
        
        for (GeneratorType type : annotation.value()) {
            TypedGenerator<String> generator = createGenerator(type);
            Stream<Arguments> stream = Stream.generate(() -> 
                Arguments.of(generator.next(), type.name())
            ).limit(annotation.limit());
            streams.add(stream);
        }
        
        // Combine all streams
        return streams.stream().flatMap(Function.identity());
    }
    
    private TypedGenerator<String> createGenerator(GeneratorType type) {
        return switch (type) {
            case PATH_TRAVERSAL -> new PathTraversalGenerator();
            case ENCODING -> new EncodingCombinationGenerator();
            case UNICODE -> new UnicodeAttackGenerator();
            case BOUNDARY -> new BoundaryFuzzingGenerator();
            case VALID_URL -> new ValidURLGenerator();
            case INVALID_URL -> new InvalidURLGenerator();
            case URL_PARAMETER -> new URLParameterGenerator();
            case COOKIE -> new CookieGenerator();
            case HTTP_BODY -> new HTTPBodyGenerator();
        };
    }
}
----

=== Comprehensive Test Example

== ValidationType Integration Testing

=== Testing Different Validation Types

[source,java]
----
package de.cuioss.tools.security.http.validation;

/**
 * Tests to ensure ValidationType is properly propagated through the system.
 */
public class ValidationTypeTest {
    
    @Test
    void testValidationTypeInException() {
        // Create validators for different types
        UrlSecurityConfig config = UrlSecurityConfig.builder().build();
        
        // Test URL_PATH type
        ConfigStageProvider pathConfig = new URLPathConfig(config);
        HttpSecurityValidator pathValidator = new UnifiedValidationPipeline(
            pathConfig, new SecurityEventCounter());
        
        UrlSecurityException pathException = assertThrows(
            UrlSecurityException.class,
            () -> pathValidator.execute("../../../etc/passwd")
        );
        assertEquals(ValidationType.URL_PATH, pathException.getValidationType());
        
        // Test URL_PARAMETER type
        ConfigStageProvider paramConfig = new URLParameterConfig(config);
        HttpSecurityValidator paramValidator = new UnifiedValidationPipeline(
            paramConfig, new SecurityEventCounter());
        
        UrlSecurityException paramException = assertThrows(
            UrlSecurityException.class,
            () -> paramValidator.execute("search=<script>alert(1)</script>")
        );
        assertEquals(ValidationType.URL_PARAMETER, paramException.getValidationType());
        
        // Test HTTP_HEADER type
        ConfigStageProvider headerConfig = new HTTPHeaderConfig(config);
        HttpSecurityValidator headerValidator = new UnifiedValidationPipeline(
            headerConfig, new SecurityEventCounter());
        
        UrlSecurityException headerException = assertThrows(
            UrlSecurityException.class,
            () -> headerValidator.execute("Bearer\\r\\nX-Injected: true")
        );
        assertEquals(ValidationType.HTTP_HEADER, headerException.getValidationType());
    }
    
    @Test
    void testValidationTypeConsistency() {
        // Ensure ValidationType is consistent across all stages in a pipeline
        UrlSecurityConfig config = UrlSecurityConfig.builder().build();
        ConfigStageProvider pathConfig = new URLPathConfig(config);
        
        // All stages should report the same ValidationType
        assertEquals(ValidationType.URL_PATH, pathConfig.getValidationType());
        for (HttpSecurityValidator stage : pathConfig.getStages()) {
            if (stage != null) {
                assertEquals(ValidationType.URL_PATH, stage.getType());
            }
        }
    }
}
----

== Comprehensive Security Testing

[source,java]
----
package de.cuioss.tools.security.http.attacks;

import org.junit.jupiter.params.ParameterizedTest;
import de.cuioss.test.generator.junit.EnableGeneratorController;
import de.cuioss.test.generator.junit.TypeGeneratorSource;
import de.cuioss.test.generator.junit.CompositeTypeGeneratorSource;
import de.cuioss.tools.security.http.generators.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive security test using all generators.
 */
@EnableGeneratorController
public class ComprehensiveSecurityTest {
    
    private final HttpSecurityValidator pathValidator = createPathValidator();
    private final HttpSecurityValidator paramValidator = createParameterValidator();
    private final HttpSecurityValidator headerValidator = createHeaderValidator();
    
    private HttpSecurityValidator createPathValidator() {
        UrlSecurityConfig baseConfig = UrlSecurityConfig.builder().build();
        ConfigStageProvider pathConfig = new URLPathConfig(baseConfig);
        return new UnifiedValidationPipeline(pathConfig, new SecurityEventCounter());
    }
    
    private HttpSecurityValidator createParameterValidator() {
        UrlSecurityConfig baseConfig = UrlSecurityConfig.builder().build();
        ConfigStageProvider paramConfig = new URLParameterConfig(baseConfig);
        return new UnifiedValidationPipeline(paramConfig, new SecurityEventCounter());
    }
    
    private HttpSecurityValidator createHeaderValidator() {
        UrlSecurityConfig baseConfig = UrlSecurityConfig.builder().build();
        ConfigStageProvider headerConfig = new HTTPHeaderConfig(baseConfig);
        return new UnifiedValidationPipeline(headerConfig, new SecurityEventCounter());
    }
    
    @ParameterizedTest(name = "Attack detection [{index}]: {0}")
    @CompositeTypeGeneratorSource(
        generatorClasses = {
            PathTraversalGenerator.class,
            EncodingCombinationGenerator.class,
            UnicodeAttackGenerator.class,
            BoundaryFuzzingGenerator.class
        }, 
        count = 200
    )
    void testAllAttackPatterns(String attack) {
        // All attack patterns should be blocked
        UrlSecurityException exception = assertThrows(
            UrlSecurityException.class,
            () -> pathValidator.execute(attack),
            "Failed to detect attack: " + attack
        );
        
        // Verify ValidationType is properly set
        assertEquals(ValidationType.URL_PATH, exception.getValidationType(),
            "Exception should include ValidationType");
        
        // Log failure type for analysis
        logger.debug("Detected {} for attack (type: {}): {}", 
            exception.getFailureType(), 
            exception.getValidationType(), attack);
    }
    
    @ParameterizedTest(name = "Valid URL [{index}]")
    @TypeGeneratorSource(value = ValidURLGenerator.class, count = 500)
    void testValidURLs(String validUrl) {
        // Valid URLs should pass without exception
        String result = assertDoesNotThrow(
            () -> pathValidator.execute(validUrl),
            "False positive for valid URL: " + validUrl
        );
        
        assertNotNull(result);
        // Result might be normalized but should still be valid
        assertTrue(isValidPath(result));
    }
    
    @ParameterizedTest(name = "Parameter validation [{index}]")
    @TypeGeneratorSource(value = ValidURLGenerator.class, count = 200)
    void testParameterValidation(String paramValue) {
        // Test parameter-specific validation
        // URLParameterGenerator creates both attack and valid parameters
        try {
            String result = paramValidator.execute(paramValue);
            // Valid parameter passed
            assertNotNull(result);
        } catch (UrlSecurityException e) {
            // Attack parameter detected - verify it's a known attack type
            assertTrue(
                e.getFailureType() == UrlSecurityFailureType.INVALID_CHARACTER ||
                e.getFailureType() == UrlSecurityFailureType.INVALID_ENCODING ||
                e.getFailureType() == UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED ||
                e.getFailureType() == UrlSecurityFailureType.SUSPICIOUS_PATTERN
            );
        }
    }
    
    @ParameterizedTest(name = "Boundary fuzzing [{index}]")
    @TypeGeneratorSource(value = BoundaryFuzzingGenerator.class, count = 100)
    void testBoundaryConditions(String boundary) {
        // Boundary conditions should be handled gracefully
        try {
            pathValidator.execute(boundary);
            // If it passes, verify length constraints
            assertTrue(boundary.length() <= UrlSecurityConfig.DEFAULT_MAX_PATH_LENGTH);
        } catch (UrlSecurityException e) {
            // Expected for oversized or malformed inputs
            assertTrue(
                e.getFailureType() == UrlSecurityFailureType.PATH_TOO_LONG ||
                e.getFailureType() == UrlSecurityFailureType.EXCESSIVE_NESTING ||
                e.getFailureType() == UrlSecurityFailureType.INVALID_CHARACTER
            );
        }
    }
    
    @Test
    void testGeneratorCoverage() {
        // Verify all generators produce unique patterns
        Set<String> uniquePatterns = new HashSet<>();
        PathTraversalGenerator gen = new PathTraversalGenerator();
        
        for (int i = 0; i < 1000; i++) {
            uniquePatterns.add(gen.next());
        }
        
        // Should generate many unique patterns
        assertTrue(uniquePatterns.size() > 500, 
            "Generator should produce diverse patterns");
    }
}
----

=== Best Practices

1. **Always use TypedGenerator interface** - Ensures type safety
2. **Use Generator class, never Random** - Maintains determinism  
3. **Respect configuration limits** - Check DEFAULT_* constants
4. **Document attack sources** - Include CVE/OWASP references
5. **Test generators themselves** - Task G10 validates all generators
6. **Use @GeneratorsSource** - For comprehensive parameterized testing
7. **Combine generators** - Test interaction between different attack types
8. **Track failure types** - Ensure attacks are caught for the right reasons

=== Additional Test Examples

[source,java]
----
/**
 * False positive prevention tests.
 * Implements: link:plan.adoc#_phase_710_false_positive_prevention_tests[Tasks T31-T33]
 */
public class FalsePositiveTest {
    
    private final HttpSecurityValidator validator = createValidator();
    
    @ParameterizedTest(name = "Valid URLs should pass [{index}]: {0}")
    @GeneratorsSource(value = GeneratorType.VALID_URL, limit = 500)
    void testValidURLsNoFalsePositives(String validUrl, String generatorType) {
        // T31: Legitimate paths should pass validation
        String result = assertDoesNotThrow(
            () -> validator.execute(validUrl),
            "False positive on valid URL: " + validUrl
        );
        
        // Result should be non-null and potentially normalized
        assertNotNull(result);
    }
    
    @ParameterizedTest(name = "Invalid URLs should fail [{index}]: {0}")
    @GeneratorsSource(value = GeneratorType.INVALID_URL, limit = 200)
    void testInvalidURLsDetected(String invalidUrl, String generatorType) {
        // T32: Malformed URLs should be rejected
        assertThrows(
            UrlSecurityException.class,
            () -> validator.execute(invalidUrl),
            "Failed to detect invalid URL: " + invalidUrl
        );
    }
}

/**
 * Performance validation tests.
 * Implements: link:plan.adoc#_phase_711_performance_validation_tests[Tasks T34-T36]
 */
public class PerformanceValidationTest {
    
    private final HttpSecurityValidator validator = createValidator();
    
    @ParameterizedTest(name = "Performance test [{index}]")
    @GeneratorsSource(value = {
        GeneratorType.VALID_URL,
        GeneratorType.PATH_TRAVERSAL,
        GeneratorType.ENCODING
    }, limit = 1000)
    void testPerformanceUnderLoad_T34(String input, String generatorType) {
        // T34-T36: Verify <1ms performance requirement
        long startTime = System.nanoTime();
        
        try {
            validator.execute(input);
        } catch (UrlSecurityException e) {
            // Expected for attack inputs
        }
        
        long duration = System.nanoTime() - startTime;
        long durationMs = duration / 1_000_000;
        
        // Must complete within 1ms
        assertTrue(durationMs < 1, 
            "Validation took " + durationMs + "ms for " + generatorType);
    }
}

/**
 * Cookie and HTTP body validation tests.
 */
public class HTTPDataValidationTest {
    
    private final HttpSecurityValidator cookieValidator = createCookieValidator();
    private final HttpSecurityValidator bodyValidator = createBodyValidator();
    
    @ParameterizedTest(name = "Cookie validation [{index}]")
    @GeneratorsSource(value = GeneratorType.COOKIE, limit = 100)
    void testCookieValidation(String cookieValue, String generatorType) {
        // CookieGenerator creates both valid and attack cookies
        try {
            String result = cookieValidator.execute(cookieValue);
            // Valid cookie
            assertNotNull(result);
        } catch (UrlSecurityException e) {
            // Attack cookie detected
            assertNotNull(e.getFailureType());
        }
    }
    
    @ParameterizedTest(name = "HTTP body validation [{index}]")
    @GeneratorsSource(value = GeneratorType.HTTP_BODY, limit = 100)
    void testHTTPBodyValidation(String bodyContent, String generatorType) {
        // HTTPBodyGenerator creates various body content types
        try {
            String result = bodyValidator.execute(bodyContent);
            // Valid body content
            assertNotNull(result);
        } catch (UrlSecurityException e) {
            // Malicious body content detected
            assertNotNull(e.getFailureType());
        }
    }
}

/**
 * Combined attack tests using multiple generators.
 */
public class CombinedAttackTest {
    
    private final HttpSecurityValidator validator = createValidator();
    
    @ParameterizedTest(name = "Combined attacks [{index}]: {1}")
    @GeneratorsSource(value = {
        GeneratorType.PATH_TRAVERSAL,
        GeneratorType.ENCODING,
        GeneratorType.UNICODE,
        GeneratorType.BOUNDARY
    }, limit = 50)  // 50 each = 200 total tests
    void testAllAttackTypes(String attack, String generatorType) {
        // Test that all attack types are properly detected
        UrlSecurityException exception = assertThrows(
            UrlSecurityException.class,
            () -> validator.execute(attack),
            "Failed to detect " + generatorType + " attack: " + attack
        );
        
        // Track which failure types are triggered by which generators
        logger.info("Generator: {} -> FailureType: {}", 
            generatorType, exception.getFailureType());
    }
    
    @ParameterizedTest(name = "Mixed valid/invalid [{index}]: {1}")
    @GeneratorsSource(value = {
        GeneratorType.VALID_URL,
        GeneratorType.INVALID_URL,
        GeneratorType.PATH_TRAVERSAL
    }, limit = 33)  // ~100 total tests mixed
    void testMixedInputs(String input, String generatorType) {
        // Test mix of valid and invalid inputs
        boolean isValid = generatorType.equals("VALID_URL");
        
        if (isValid) {
            assertDoesNotThrow(() -> validator.execute(input));
        } else {
            assertThrows(UrlSecurityException.class, 
                () -> validator.execute(input));
        }
    }
}
----

== Success Criteria

The test harness achieves success when:

1. ✅ **ALL tests pass** - No failures accepted
2. ✅ All 10 generators (G1-G10) implemented and tested
3. ✅ All 36 test cases (T1-T36) passing
4. ✅ 100% of known CVE patterns blocked
5. ✅ OWASP Top 10 compliance achieved
6. ✅ <1ms performance for ALL validations
7. ✅ Zero false positives - valid URLs must pass
8. ✅ Zero false negatives - all attacks must be detected
8. ✅ CI/CD integration complete
9. ✅ Comprehensive reporting available