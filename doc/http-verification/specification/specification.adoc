= URL Security Validation Architecture and Design
:toc: left
:toclevels: 3
:sectnums:
:icons: font

link:../README.adoc[← Back to Documentation Overview]

[IMPORTANT]
====
This document describes HOW the URL Security Validation system architecture works.
For WHAT tasks to implement, see link:plan.adoc[Implementation Plan].
For HOW to test the system, see link:testing.adoc[Testing Framework].
====

== Executive Summary

The URL Security Validation system provides comprehensive protection against path traversal attacks, encoding bypasses, and injection attempts through a layered, immutable, high-performance architecture in the `de.cuioss.tools.security.http` package.

=== Java 21+ Features Utilized

This architecture leverages modern Java 21+ features for improved code quality and maintainability:

* **String Templates** - Clean formatting without String.format complexity
* **Enhanced Pattern Matching** - Modern switch expressions with type patterns and record deconstruction
* **Records** - Immutable data carriers replacing @Value classes
* **Modern Collections** - Efficient collection processing with streams
* **JSpecify Annotations** - Null-safety guarantees with @NonNull/@Nullable
* **Optional Integration** - Explicit null handling for sensitive data
* **Switch Expressions** - Concise, exhaustive pattern matching

== Design Principles

[cols="2,3"]
|===
|Principle |Implementation

|Defense in Depth
|Sequential validation stages, each catching different attack classes

|Fail Secure
|String/throws pattern - reject on any security violation

|Secure Defaults
|Configuration constants based on OWASP/RFC with documented sources

|Immutability
|All validation stages immutable after construction for thread safety

|Performance First
|Pre-compiled patterns, optimized algorithms, <1ms requirement

|Transparency
|Structured logging via LogRecord pattern, security event counting
|===

== System Architecture

=== High-Level Architecture

----
┌─────────────────────────────────────────────────────────┐
│                    Client Request                        │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│              HttpSecurityValidator                       │
│         (Core validation interface)                      │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│              Validation Pipeline                         │
│         (Sequential stage execution)                     │
├──────────────────────────────────────────────────────────┤
│  Stage 1: LengthValidationStage                         │
│  Stage 2: CharacterValidationStage                      │
│  Stage 3: DecodingStage                                 │
│  Stage 4: NormalizationStage                            │
│  Stage 5: PatternMatchingStage                          │
└──────────────────────────────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│          Security Event Tracking                         │
│    (Counter + LogRecord based logging)                   │
└──────────────────────────────────────────────────────────┘
----

=== Package Structure

----
de.cuioss.tools.security.http/
├── HttpSecurityValidator.java         # Core validation interface
├── UrlSecurityException.java          # Main exception with ValidationType
├── UrlSecurityFailureType.java        # Comprehensive failure enum  
├── ValidationType.java                # Input type classification
│
├── config/
│   ├── SecurityConfiguration.java    # Main security configuration record
│   └── SecurityConfigurationBuilder.java # Builder for security config
│
├── security/
│   ├── SecurityEventCounter.java     # Thread-safe event counting
│   └── URLSecurityLogMessages.java   # LogRecord pattern messages
│
├── validation/
│   ├── LengthValidationStage.java    # Size limit validation (FIRST!)
│   ├── CharacterValidationStage.java # RFC character validation (SECOND!)
│   ├── DecodingStage.java            # Multi-layer decoding
│   ├── NormalizationStage.java       # Path normalization
│   └── PatternMatchingStage.java     # Attack pattern detection
│
└── pipeline/
    ├── URLPathValidationPipeline.java        # URL path validation pipeline
    ├── URLParameterValidationPipeline.java   # URL parameter validation pipeline  
    ├── HTTPHeaderValidationPipeline.java     # HTTP header validation pipeline
    ├── HTTPBodyValidationPipeline.java       # HTTP body validation pipeline
    └── PipelineFactory.java                  # Factory for creating validation pipelines
----

== Core Components

=== Core Interfaces and Data Types

[source,java]
----
package de.cuioss.tools.security.http;

import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

/**
 * Core functional interface for HTTP security validation.
 * Follows the String/throws pattern consistently.
 * Can be used with lambda expressions and method references.
 * Implemented by: link:plan.adoc#_phase_2_base_structure_and_core_components[Task B3]
 */
@FunctionalInterface
public interface HttpSecurityValidator {
    /**
     * Validates the input and returns the sanitized/normalized version.
     * @param value The input to validate (may be null)
     * @return The validated/normalized value
     * @throws UrlSecurityException on any security violation
     */
    @NonNull
    String validate(@Nullable String value) throws UrlSecurityException;
}

/**
 * Classification of input types for appropriate validation.
 * Implemented by: link:plan.adoc#_phase_2_base_structure_and_core_components[Task B3]
 */
public enum ValidationType {
    URL_PATH,           // URL path segments
    PARAMETER_NAME,     // Query parameter names
    PARAMETER_VALUE,    // Query parameter values
    HEADER_NAME,        // HTTP header names
    HEADER_VALUE,       // HTTP header values
    COOKIE_NAME,        // Cookie names
    COOKIE_VALUE,       // Cookie values
    BODY;               // Request/response bodies
    
    /**
     * Check if this validation type requires URL decoding.
     * Used in pattern matching scenarios.
     */
    public boolean requiresDecoding() {
        return this == URL_PATH || 
               this == PARAMETER_NAME || 
               this == PARAMETER_VALUE;
    }
    
    /**
     * Check if this type represents a key/name component.
     */
    public boolean isKey() {
        return this == PARAMETER_NAME || 
               this == HEADER_NAME || 
               this == COOKIE_NAME;
    }
    
    /**
     * Check if this type represents a value component.
     */
    public boolean isValue() {
        return this == PARAMETER_VALUE || 
               this == HEADER_VALUE || 
               this == COOKIE_VALUE;
    }
}

/**
 * Comprehensive enumeration of security failure types.
 * Implemented by: link:plan.adoc#_phase_2_base_structure_and_core_components[Task B1]
 */
public enum UrlSecurityFailureType {
    // Encoding Issues
    INVALID_ENCODING("Invalid URL encoding detected"),
    DOUBLE_ENCODING("Double URL encoding detected"),
    UNICODE_NORMALIZATION_CHANGED("Unicode normalization altered input"),
    
    // Path Traversal
    PATH_TRAVERSAL_DETECTED("Path traversal pattern detected"),
    DIRECTORY_ESCAPE_ATTEMPT("Directory escape attempt detected"),
    
    // Character Issues
    INVALID_CHARACTER("Invalid character detected"),
    NULL_BYTE_INJECTION("Null byte injection detected"),
    CONTROL_CHARACTERS("Control characters detected"),
    
    // Length/Size Issues
    PATH_TOO_LONG("Path exceeds maximum length"),
    EXCESSIVE_NESTING("Excessive directory nesting"),
    
    // Pattern Matches
    SUSPICIOUS_PATTERN("Suspicious pattern detected"),
    KNOWN_ATTACK_SIGNATURE("Known attack signature detected"),
    
    // Structural Issues
    MALFORMED_INPUT("Malformed input structure"),
    INVALID_STRUCTURE("Invalid input structure"),
    
    // Protocol Issues  
    PROTOCOL_VIOLATION("Protocol specification violation"),
    RFC_VIOLATION("RFC specification violation");
    
    private final String description;
    
    UrlSecurityFailureType(String description) {
        this.description = description;
    }
}

/**
 * Main exception for security violations.
 * Extends RuntimeException for clean functional interface usage.
 * Implemented by: link:plan.adoc#_phase_2_base_structure_and_core_components[Task B2]
 */
@Getter
@Builder
@EqualsAndHashCode(callSuper = true)
@ToString
public class UrlSecurityException extends RuntimeException {
    @NonNull private final UrlSecurityFailureType failureType;
    @NonNull private final ValidationType validationType;
    @NonNull private final String originalInput;
    @Nullable private final String sanitizedInput;
    @Nullable private final String detail;
    
    @Builder
    private UrlSecurityException(
            @NonNull UrlSecurityFailureType failureType,
            @NonNull ValidationType validationType,
            @NonNull String originalInput,
            @Nullable String sanitizedInput,
            @Nullable String detail,
            @Nullable Throwable cause) {
        super(buildMessage(failureType, validationType, originalInput, detail), cause);
        this.failureType = failureType;
        this.validationType = validationType;
        this.originalInput = originalInput;
        this.sanitizedInput = sanitizedInput;
        this.detail = detail;
        if (cause != null) {
            initCause(cause);
        }
    }
    
    private static String buildMessage(UrlSecurityFailureType failureType,
                                        ValidationType validationType,
                                        String originalInput,
                                        String detail) {
        StringBuilder sb = new StringBuilder();
        sb.append("Security validation failed [").append(validationType).append("]: ");
        sb.append(failureType);
        if (detail != null) {
            sb.append(" - ").append(detail);
        }
        sb.append(" (input: '").append(originalInput).append("')");
        return sb.toString();
    }
    
    /**
     * Get sanitized input as Optional.
     */
    public Optional<String> getSanitizedInputOptional() {
        return Optional.ofNullable(sanitizedInput);
    }
}
----

=== Data Records

[source,java]
----
package de.cuioss.tools.security.http;

/**
 * Data records used throughout the system.
 * Implemented by: link:plan.adoc#_phase_2_base_structure_and_core_components[Task B3]
 */
public record URLParameter(
    @NonNull String key, 
    @Nullable String value
) {
    /**
     * Check if this parameter contains sensitive data based on key name.
     */
    public boolean isSensitive() {
        String lowerKey = key.toLowerCase();
        return lowerKey.contains("password") || 
               lowerKey.contains("token") || 
               lowerKey.contains("secret") ||
               lowerKey.contains("api_key");
    }
}

public record Cookie(
    @NonNull String name, 
    @Nullable String value, 
    @NonNull Map<String, String> attributes
) {
    /**
     * Check if this is a security-sensitive cookie.
     */
    public boolean isSecuritySensitive() {
        String lowerName = name.toLowerCase();
        return lowerName.contains("session") || 
               lowerName.contains("auth") || 
               lowerName.contains("csrf");
    }
}

public record HTTPBody(
    @NonNull String contentType, 
    byte @NonNull [] content
) {
    /**
     * Get content length safely.
     */
    public int length() {
        return content.length;
    }
}
----

== Configuration Architecture

Configuration follows the embedded constants pattern from `ParserConfig`:

=== Security Configuration Architecture

The HTTP security framework uses a single immutable configuration record that contains all security policies:

[source,java]
----
package de.cuioss.tools.security.http.config;

import de.cuioss.http.security.config.SecurityConfigurationBuilder; /**
 * Immutable record representing comprehensive security configuration for HTTP validation.
 * Provides type-safe, immutable configuration object shared across multiple validation operations.
 */
public record SecurityConfiguration(
    // Path Security Settings
    int maxPathLength,
    boolean pathTraversalDetectionEnabled,
    Set<String> allowedPathPatterns,
    
    // Parameter Security Settings  
    int maxParameterNameLength,
    int maxParameterValueLength,
    boolean parameterInjectionDetectionEnabled,
    
    // Header Security Settings
    int maxHeaderNameLength, 
    int maxHeaderValueLength,
    boolean headerInjectionDetectionEnabled,
    
    // Body Security Settings
    long maxBodySize,
    boolean bodyInjectionDetectionEnabled,
    
    // Encoding Security Settings
    boolean doubleEncodingDetectionEnabled,
    boolean unicodeNormalizationEnabled,
    
    // General Security Policies
    boolean strictModeEnabled,
    SecurityLevel securityLevel
) {
    
    /**
     * Creates a SecurityConfiguration with secure defaults.
     * All security features enabled, strict limits applied.
     */
    public static SecurityConfiguration defaults() {
        return builder()
            .maxPathLength(1024)
            .maxParameterNameLength(256)
            .maxParameterValueLength(4096)
            .maxHeaderNameLength(256)
            .maxHeaderValueLength(8192)
            .maxBodySize(1048576L) // 1MB
            .pathTraversalDetectionEnabled(true)
            .parameterInjectionDetectionEnabled(true) 
            .headerInjectionDetectionEnabled(true)
            .bodyInjectionDetectionEnabled(true)
            .doubleEncodingDetectionEnabled(true)
            .unicodeNormalizationEnabled(true)
            .strictModeEnabled(true)
            .securityLevel(SecurityLevel.STRICT)
            .build();
    }
    
    public static SecurityConfigurationBuilder builder() {
        return new SecurityConfigurationBuilder();
    }
}
----

=== Security Levels

[source,java]
----
/**
 * Security levels that determine the strictness of validation policies.
 */
enum SecurityLevel {
    /** Maximum security - All validation enabled, strict limits */
    STRICT,
    
    /** Balanced security - Most validation enabled, moderate limits */  
    DEFAULT,
    
    /** Relaxed security - Basic validation only, lenient limits */
    LENIENT
}
----

=== Configuration Builder Pattern

The SecurityConfiguration uses a builder pattern for flexible configuration creation:

[source,java]
----
// Create configuration with custom settings
SecurityConfiguration config = SecurityConfiguration.builder()
    .maxPathLength(2048)
    .maxParameterValueLength(8192)
    .securityLevel(SecurityLevel.DEFAULT)
    .pathTraversalDetectionEnabled(true)
    .doubleEncodingDetectionEnabled(true)
    .build();

// Or use secure defaults
SecurityConfiguration defaultConfig = SecurityConfiguration.defaults();
    
    /**
     * Maximum directory traversal depth.
     * Default: 10 based on typical filesystem depth and OWASP recommendations.
     * @see <a href="https://owasp.org/www-community/attacks/Path_Traversal">OWASP Path Traversal</a>
     */
    public static final int DEFAULT_MAX_DIRECTORY_DEPTH = 10;
    
    /**
     * Maximum parameter value length.
     * Default: 4096 based on common server configurations.
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.1">RFC 7230</a>
     */
    public static final int DEFAULT_MAX_PARAMETER_LENGTH = 4096;
    
    /**
     * Maximum number of parameters.
     * Default: 100 to prevent parameter pollution attacks.
     * @see <a href="https://owasp.org/www-community/attacks/HTTP_Parameter_Pollution">OWASP HPP</a>
     */
    public static final int DEFAULT_MAX_PARAMETER_COUNT = 100;
    
    /**
     * Enable Unicode normalization (NFC).
     * Default: true per OWASP guidelines for Unicode security.
     * @see <a href="https://owasp.org/www-community/attacks/Unicode_Encoding">OWASP Unicode</a>
     */
    public static final boolean DEFAULT_UNICODE_NORMALIZATION = true;
    
    /**
     * Reject null bytes in input.
     * Default: true to prevent null byte injection attacks.
     * @see <a href="https://owasp.org/www-community/attacks/Null_Byte_Injection">OWASP Null Byte</a>
     */
    public static final boolean DEFAULT_REJECT_NULL_BYTES = true;
    
    @Builder.Default
    int maxPathLength = DEFAULT_MAX_PATH_LENGTH;
    
    @Builder.Default
    int maxDirectoryDepth = DEFAULT_MAX_DIRECTORY_DEPTH;
    
    @Builder.Default
    int maxParameterLength = DEFAULT_MAX_PARAMETER_LENGTH;
    
    @Builder.Default
    int maxParameterCount = DEFAULT_MAX_PARAMETER_COUNT;
    
    @Builder.Default
    boolean unicodeNormalization = DEFAULT_UNICODE_NORMALIZATION;
    
    @Builder.Default
    boolean rejectNullBytes = DEFAULT_REJECT_NULL_BYTES;
}

/**
 * Configuration for URL path validation.
 * Implements ConfigStageProvider with URL_PATH specific stages.
 */
@Value
public class URLPathConfig implements ConfigStageProvider {
    
    UrlSecurityConfig baseConfig;
    ValidationType validationType = ValidationType.URL_PATH;
    
    // Cached stage instances - created once, reused everywhere
    @Getter(lazy = true)
    LengthValidationStage lengthValidationStage = 
        new LengthValidationStage(baseConfig, ValidationType.URL_PATH);
    
    @Getter(lazy = true)
    CharacterValidationStage characterValidationStage = 
        new CharacterValidationStage(baseConfig, ValidationType.URL_PATH);
    
    @Getter(lazy = true)
    DecodingStage decodingStage = 
        new DecodingStage(baseConfig, ValidationType.URL_PATH);
    
    @Getter(lazy = true)
    NormalizationStage normalizationStage = 
        new NormalizationStage(baseConfig, ValidationType.URL_PATH);
    
    @Getter(lazy = true)
    PatternMatchingStage patternMatchingStage = 
        new PatternMatchingStage(baseConfig, ValidationType.URL_PATH);
    
    public URLPathConfig(UrlSecurityConfig baseConfig) {
        this.baseConfig = baseConfig;
    }
    
    @Override
    public ValidationType getValidationType() {
        return validationType;
    }
    
    @Override
    public List<HttpSecurityValidator> getStages() {
        return new ArrayList<>(List.of(
            getLengthValidationStage(),
            getCharacterValidationStage(),
            getDecodingStage(),
            getNormalizationStage(),
            getPatternMatchingStage()
        ));
    }
}

/**
 * Configuration for URL parameter name validation.
 * Implements ConfigStageProvider with PARAMETER_NAME specific stages.
 */
@Value
public class URLParameterNameConfig implements ConfigStageProvider {
    
    UrlSecurityConfig baseConfig;
    ValidationType validationType = ValidationType.PARAMETER_NAME;
    
    @Getter(lazy = true)
    LengthValidationStage lengthValidationStage = 
        new LengthValidationStage(baseConfig, ValidationType.PARAMETER_NAME);
    
    @Getter(lazy = true)
    CharacterValidationStage characterValidationStage = 
        new CharacterValidationStage(baseConfig, ValidationType.PARAMETER_NAME);
    
    @Getter(lazy = true)
    DecodingStage decodingStage = 
        new DecodingStage(baseConfig, ValidationType.PARAMETER_NAME);
    
    @Getter(lazy = true)
    PatternMatchingStage patternMatchingStage = 
        new PatternMatchingStage(baseConfig, ValidationType.PARAMETER_NAME);
    
    public URLParameterNameConfig(UrlSecurityConfig baseConfig) {
        this.baseConfig = baseConfig;
    }
    
    @Override
    public ValidationType getValidationType() {
        return validationType;
    }
    
    @Override
    public HttpSecurityValidator getNormalizationStage() {
        return IdentityValidator.PARAMETER_NAME; // Not used for parameter names
    }
    
    @Override
    public List<HttpSecurityValidator> getStages() {
        return new ArrayList<>(List.of(
            getLengthValidationStage(),
            getCharacterValidationStage(),
            getDecodingStage(),
            getPatternMatchingStage()
        ));
    }
}

/**
 * Configuration for URL parameter value validation.
 * Implements ConfigStageProvider with PARAMETER_VALUE specific stages.
 */
@Value
public class URLParameterValueConfig implements ConfigStageProvider {
    
    UrlSecurityConfig baseConfig;
    ValidationType validationType = ValidationType.PARAMETER_VALUE;
    
    @Getter(lazy = true)
    LengthValidationStage lengthValidationStage = 
        new LengthValidationStage(baseConfig, ValidationType.PARAMETER_VALUE);
    
    @Getter(lazy = true)
    CharacterValidationStage characterValidationStage = 
        new CharacterValidationStage(baseConfig, ValidationType.PARAMETER_VALUE);
    
    @Getter(lazy = true)
    DecodingStage decodingStage = 
        new DecodingStage(baseConfig, ValidationType.PARAMETER_VALUE);
    
    @Getter(lazy = true)
    PatternMatchingStage patternMatchingStage = 
        new PatternMatchingStage(baseConfig, ValidationType.PARAMETER_VALUE);
    
    public URLParameterValueConfig(UrlSecurityConfig baseConfig) {
        this.baseConfig = baseConfig;
    }
    
    @Override
    public ValidationType getValidationType() {
        return validationType;
    }
    
    @Override
    public HttpSecurityValidator getNormalizationStage() {
        return IdentityValidator.PARAMETER_VALUE; // Not used for parameter values
    }
    
    @Override
    public List<HttpSecurityValidator> getStages() {
        return new ArrayList<>(List.of(
            getLengthValidationStage(),
            getCharacterValidationStage(),
            getDecodingStage(),
            getPatternMatchingStage()
        ));
    }
}

/**
 * Configuration for HTTP header name validation.
 * Implements ConfigStageProvider with HEADER_NAME specific stages.
 */
@Value
public class HTTPHeaderNameConfig implements ConfigStageProvider {
    
    UrlSecurityConfig baseConfig;
    ValidationType validationType = ValidationType.HEADER_NAME;
    
    @Getter(lazy = true)
    LengthValidationStage lengthValidationStage = 
        new LengthValidationStage(baseConfig, ValidationType.HEADER_NAME);
    
    @Getter(lazy = true)
    CharacterValidationStage characterValidationStage = 
        new CharacterValidationStage(baseConfig, ValidationType.HEADER_NAME);
    
    @Getter(lazy = true)
    PatternMatchingStage patternMatchingStage = 
        new PatternMatchingStage(baseConfig, ValidationType.HEADER_NAME);
    
    public HTTPHeaderNameConfig(UrlSecurityConfig baseConfig) {
        this.baseConfig = baseConfig;
    }
    
    @Override
    public ValidationType getValidationType() {
        return validationType;
    }
    
    @Override
    public HttpSecurityValidator getDecodingStage() {
        return IdentityValidator.HEADER_NAME; // Not used for header names
    }
    
    @Override
    public HttpSecurityValidator getNormalizationStage() {
        return IdentityValidator.HEADER_NAME; // Not used for header names
    }
    
    @Override
    public List<HttpSecurityValidator> getStages() {
        return new ArrayList<>(List.of(
            getLengthValidationStage(),
            getCharacterValidationStage(),
            getPatternMatchingStage()
        ));
    }
}

/**
 * Configuration for HTTP header value validation.
 * Implements ConfigStageProvider with HEADER_VALUE specific stages.
 */
@Value
public class HTTPHeaderValueConfig implements ConfigStageProvider {
    
    UrlSecurityConfig baseConfig;
    ValidationType validationType = ValidationType.HEADER_VALUE;
    
    @Getter(lazy = true)
    LengthValidationStage lengthValidationStage = 
        new LengthValidationStage(baseConfig, ValidationType.HEADER_VALUE);
    
    @Getter(lazy = true)
    CharacterValidationStage characterValidationStage = 
        new CharacterValidationStage(baseConfig, ValidationType.HEADER_VALUE);
    
    @Getter(lazy = true)
    PatternMatchingStage patternMatchingStage = 
        new PatternMatchingStage(baseConfig, ValidationType.HEADER_VALUE);
    
    public HTTPHeaderValueConfig(UrlSecurityConfig baseConfig) {
        this.baseConfig = baseConfig;
    }
    
    @Override
    public ValidationType getValidationType() {
        return validationType;
    }
    
    @Override
    public HttpSecurityValidator getDecodingStage() {
        return IdentityValidator.HEADER_VALUE; // Not used for header values
    }
    
    @Override
    public HttpSecurityValidator getNormalizationStage() {
        return IdentityValidator.HEADER_VALUE; // Not used for header values
    }
    
    @Override
    public List<HttpSecurityValidator> getStages() {
        return new ArrayList<>(List.of(
            getLengthValidationStage(),
            getCharacterValidationStage(),
            getPatternMatchingStage()
        ));
    }
}
----

== Validation Stages

All validation stages follow these principles:

1. **Immutability**: Configuration stored in final fields, no runtime state changes
2. **Performance**: Pre-compiled patterns, optimized algorithms, <1ms per stage
3. **Thread Safety**: No mutable state, safe for concurrent use
4. **Clear Contracts**: String input/output with UrlSecurityException on violations

=== IdentityValidator

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.Getter;
import lombok.EqualsAndHashCode;
import lombok.ToString;

/**
 * Identity validator that performs no validation - just returns the input unchanged.
 * Used as a placeholder for stages that are not applicable to certain validation types.
 * Thread-safe and immutable.
 */
@EqualsAndHashCode
@ToString
public final class IdentityValidator implements HttpSecurityValidator {
    
    private final ValidationType validationType;
    
    /**
     * Singleton instances for each validation type to avoid unnecessary object creation.
     */
    public static final IdentityValidator URL_PATH = new IdentityValidator(ValidationType.URL_PATH);
    public static final IdentityValidator PARAMETER_NAME = new IdentityValidator(ValidationType.PARAMETER_NAME);
    public static final IdentityValidator PARAMETER_VALUE = new IdentityValidator(ValidationType.PARAMETER_VALUE);
    public static final IdentityValidator HEADER_NAME = new IdentityValidator(ValidationType.HEADER_NAME);
    public static final IdentityValidator HEADER_VALUE = new IdentityValidator(ValidationType.HEADER_VALUE);
    public static final IdentityValidator HTTP_BODY = new IdentityValidator(ValidationType.BODY);
    public static final IdentityValidator COOKIE_NAME = new IdentityValidator(ValidationType.COOKIE_NAME);
    public static final IdentityValidator COOKIE_VALUE = new IdentityValidator(ValidationType.COOKIE_VALUE);
    
    private IdentityValidator(ValidationType validationType) {
        this.validationType = validationType;
    }
    
    @Override
    public String validate(String value) {
        // Identity function - return input unchanged
        return value;
    }
}
----

=== LengthValidationStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.EqualsAndHashCode;
import lombok.ToString;

/**
 * Length validation MUST be the first stage to prevent DoS attacks.
 * Rejects oversized inputs before any processing.
 * Immutable and thread-safe.
 * Implemented by: link:plan.adoc#_phase_5_validation_stages[Task V4]
 */
@EqualsAndHashCode
@ToString
public final class LengthValidationStage implements HttpSecurityValidator {
    
    private final int maxLength;
    private final int maxDepth;
    private final ValidationType validationType;
    
    public LengthValidationStage(UrlSecurityConfig config, ValidationType validationType) {
        this.maxLength = config.getMaxPathLength();
        this.maxDepth = config.getMaxDirectoryDepth();
        this.validationType = validationType;
    }
    
    @Override
    public String validate(String value) throws UrlSecurityException {
        // First check: total length
        if (value.length() > maxLength) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.PATH_TOO_LONG)
                .validationType(validationType)
                .originalInput(value)
                .build();
        }
        
        // Second check: nesting depth
        long depth = value.chars().filter(ch -> ch == '/' || ch == '\\').count();
        if (depth > maxDepth) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.EXCESSIVE_NESTING)
                .validationType(validationType)
                .originalInput(value)
                .build();
        }
        
        return value;
    }
}
----

=== DecodingStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.Value;
import java.text.Normalizer;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.regex.Pattern;

/**
 * HTTP protocol-layer decoding with security checks.
 * LIMITED SCOPE: URL encoding, UTF-8 overlong detection, Unicode normalization only.
 * EXCLUDES: HTML entities, JavaScript escapes, Base64 (application-layer concerns).
 * Immutable and thread-safe.
 * Implemented by: link:plan.adoc#_phase_5_validation_stages[Task V1]
 */
@Value
public class DecodingStage implements HttpSecurityValidator {
    
    // Static pattern shared across all instances
    private static final Pattern DOUBLE_ENCODING_PATTERN = Pattern.compile("%25[0-9a-fA-F]{2}");
    
    UrlSecurityConfig config;
    ValidationType validationType;
    
    @Override
    public String validate(String value) throws UrlSecurityException {
        // Detect double encoding before decoding
        if (DOUBLE_ENCODING_PATTERN.matcher(value).find()) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.DOUBLE_ENCODING)
                .validationType(validationType)
                .originalInput(value)
                .build();
        }
        
        // URL decode
        String decoded;
        try {
            decoded = URLDecoder.decode(value, StandardCharsets.UTF_8);
        } catch (IllegalArgumentException e) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.INVALID_ENCODING)
                .validationType(validationType)
                .originalInput(value)
                .cause(e)
                .build();
        }
        
        // Unicode normalization with change detection
        if (config.isUnicodeNormalization()) {
            String normalized = Normalizer.normalize(decoded, Normalizer.Form.NFC);
            if (!decoded.equals(normalized)) {
                // Normalization changed the string - potential attack
                throw UrlSecurityException.builder()
                    .failureType(UrlSecurityFailureType.UNICODE_NORMALIZATION_CHANGED)
                    .validationType(validationType)
                    .originalInput(value)
                    .sanitizedInput(normalized)
                    .build();
            }
            decoded = normalized;
        }
        
        // Note: Null byte detection moved to CharacterValidationStage for earlier detection
        
        return decoded;
    }
}
----

=== Character Validation Constants

[source,java]
----
package de.cuioss.tools.security.http.validation;

import java.util.BitSet;

/**
 * Pre-computed character sets for validation according to RFC specifications.
 * These BitSets are read-only after initialization and thread-safe for concurrent reads.
 * Implemented by: link:plan.adoc#_phase_5_validation_stages[Task V5]
 */
public final class CharacterValidationConstants {
    
    private CharacterValidationConstants() {
        // Utility class
    }
    
    // RFC 3986 unreserved characters: ALPHA / DIGIT / "-" / "." / "_" / "~"
    public static final BitSet RFC3986_UNRESERVED;
    
    // RFC 3986 path characters including unreserved + path-specific
    public static final BitSet RFC3986_PATH_CHARS;
    
    // RFC 3986 query characters including unreserved + query-specific  
    public static final BitSet RFC3986_QUERY_CHARS;
    
    // RFC 7230 header field characters (visible ASCII minus delimiters)
    public static final BitSet RFC7230_HEADER_CHARS;
    
    static {
        // Initialize RFC3986_UNRESERVED
        BitSet unreserved = new BitSet(256);
        // ALPHA
        for (int i = 'A'; i <= 'Z'; i++) unreserved.set(i);
        for (int i = 'a'; i <= 'z'; i++) unreserved.set(i);
        // DIGIT
        for (int i = '0'; i <= '9'; i++) unreserved.set(i);
        // "-" / "." / "_" / "~"
        unreserved.set('-');
        unreserved.set('.');
        unreserved.set('_');
        unreserved.set('~');
        RFC3986_UNRESERVED = unreserved;
        
        // Initialize RFC3986_PATH_CHARS
        BitSet pathChars = new BitSet(256);
        pathChars.or(unreserved);  // Include all unreserved chars
        pathChars.set('/');
        pathChars.set('@');
        pathChars.set(':');
        // sub-delims for path: "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
        "!$&'()*+,;=".chars().forEach(pathChars::set);
        RFC3986_PATH_CHARS = pathChars;
        
        // Initialize RFC3986_QUERY_CHARS
        BitSet queryChars = new BitSet(256);
        queryChars.or(unreserved);  // Include all unreserved chars
        queryChars.set('?');
        queryChars.set('&');
        queryChars.set('=');
        // sub-delims for query
        "!$'()*+,;".chars().forEach(queryChars::set);
        RFC3986_QUERY_CHARS = queryChars;
        
        // Initialize RFC7230_HEADER_CHARS
        BitSet headerChars = new BitSet(256);
        // RFC 7230: VCHAR = %x21-7E (visible ASCII)
        for (int i = 33; i <= 126; i++) {
            // Exclude HTTP delimiters: " ( ) , / : ; < = > ? @ [ \ ] { }
            if (!"\"(),/:;<=>?@[\\]{}".contains(String.valueOf((char)i))) {
                headerChars.set(i);
            }
        }
        headerChars.set(' '); // Space is allowed in headers
        RFC7230_HEADER_CHARS = headerChars;
    }
    
    /**
     * Returns the character set for the given validation type.
     * Note: Returns the actual BitSet, not a copy. Do not modify!
     */
    @NonNull
    public static BitSet getCharacterSet(@NonNull ValidationType type) {
        return switch (type) {
            case URL_PATH -> RFC3986_PATH_CHARS;
            case PARAMETER_NAME, PARAMETER_VALUE -> RFC3986_QUERY_CHARS;
            case HEADER_NAME, HEADER_VALUE -> RFC7230_HEADER_CHARS;
            case BODY, COOKIE_NAME, COOKIE_VALUE -> RFC3986_UNRESERVED;
        };
    }
}
----

=== CharacterValidationStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import de.cuioss.http.security.validation.CharacterValidationConstants;import lombok.EqualsAndHashCode;
import lombok.ToString;
import lombok.Getter;
import java.util.BitSet;

/**
 * Validates characters according to RFC 3986 for URLs.
 * MUST be the second stage after length validation.
 * Rejects invalid characters BEFORE any decoding/processing.
 * Immutable and thread-safe.
 * Implemented by: link:plan.adoc#_phase_5_validation_stages[Task V5]
 */
@EqualsAndHashCode
@ToString
public final class CharacterValidationStage implements HttpSecurityValidator {
    
    private final BitSet allowedChars;
    private final ValidationType validationType;
    private final boolean allowPercentEncoding;
    
    public CharacterValidationStage(UrlSecurityConfig config, ValidationType type) {
        this.validationType = type;
        // Use the shared BitSet directly - it's read-only after initialization
        this.allowedChars = CharacterValidationConstants.getCharacterSet(type);
        
        // Determine if percent encoding is allowed based on type
        this.allowPercentEncoding = switch (type) {
            case URL_PATH, PARAMETER_NAME, PARAMETER_VALUE -> true;
            default -> false;  // HEADER_NAME, HEADER_VALUE and others don't allow percent encoding
        };
    }
    
    @Override
    public String validate(String value) throws UrlSecurityException {
        // Quick check for null/empty
        if (value == null || value.isEmpty()) {
            return value;
        }
        
        // Check each character
        for (int i = 0; i < value.length(); i++) {
            char ch = value.charAt(i);
            
            // Check for null byte FIRST (highest priority security check)
            if (ch == '\0') {
                throw UrlSecurityException.builder()
                    .failureType(UrlSecurityFailureType.NULL_BYTE_INJECTION)
                    .validationType(validationType)
                    .originalInput(value)
                    .detail("Null byte detected at position " + i)
                    .build();
            }
            
            // Handle percent encoding
            if (ch == '%' && allowPercentEncoding) {
                // Must be followed by two hex digits
                if (i + 2 >= value.length()) {
                    throw UrlSecurityException.builder()
                        .failureType(UrlSecurityFailureType.INVALID_ENCODING)
                        .validationType(validationType)
                        .originalInput(value)
                        .detail("Incomplete percent encoding at position " + i)
                        .build();
                }
                
                char hex1 = value.charAt(i + 1);
                char hex2 = value.charAt(i + 2);
                if (isNotHexDigit(hex1) || isNotHexDigit(hex2)) {
                    throw UrlSecurityException.builder()
                        .failureType(UrlSecurityFailureType.INVALID_ENCODING)
                        .validationType(validationType)
                        .originalInput(value)
                        .detail("Invalid hex digits in percent encoding at position " + i)
                        .build();
                }
                
                // Check for encoded null byte %00
                if (hex1 == '0' && hex2 == '0') {
                    throw UrlSecurityException.builder()
                        .failureType(UrlSecurityFailureType.NULL_BYTE_INJECTION)
                        .validationType(validationType)
                        .originalInput(value)
                        .detail("Encoded null byte (%00) detected at position " + i)
                        .build();
                }
                
                i += 2; // Skip the two hex digits
                continue;
            }
            
            // Check if character is allowed
            if (ch > 255 || !allowedChars.get(ch)) {
                throw UrlSecurityException.builder()
                    .failureType(UrlSecurityFailureType.INVALID_CHARACTER)
                    .validationType(validationType)
                    .originalInput(value)
                    .detail(STR."Invalid character '\{ch}' (0x\{Integer.toHexString(ch).toUpperCase()}) at position \{i}")
                    .build();
            }
        }
        
        return value;
    }
    
    private boolean isNotHexDigit(char ch) {
        return !((ch >= '0' && ch <= '9') || 
                 (ch >= 'A' && ch <= 'F') || 
                 (ch >= 'a' && ch <= 'f'));
    }
}
----

=== NormalizationStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.Value;
import java.nio.file.Paths;

/**
 * Path normalization stage to resolve . and .. segments.
 * Follows RFC 3986 Section 5.2.4 for path normalization.
 * Immutable and thread-safe.
 * Implemented by: link:plan.adoc#_phase_5_validation_stages[Task V2]
 */
@Value
public class NormalizationStage implements HttpSecurityValidator {
    
    UrlSecurityConfig config;
    ValidationType validationType;
    
    @Override
    public String validate(String value) throws UrlSecurityException {
        if (value == null || value.isEmpty()) {
            return value;
        }
        
        // Save original for comparison
        String original = value;
        
        // Normalize path segments (resolve . and ..)
        String normalized = normalizePath(value);
        
        // Check if normalization revealed path traversal
        if (containsPathTraversal(normalized)) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED)
                .validationType(validationType)
                .originalInput(original)
                .sanitizedInput(normalized)
                .detail("Path normalization revealed traversal attempt")
                .build();
        }
        
        // Check if path escapes root after normalization
        if (escapesRoot(normalized)) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.DIRECTORY_ESCAPE_ATTEMPT)
                .validationType(validationType)
                .originalInput(original)
                .sanitizedInput(normalized)
                .detail("Path attempts to escape root directory")
                .build();
        }
        
        return normalized;
    }
    
    private String normalizePath(String path) {
        // RFC 3986 path segment normalization with recursion protection
        String[] segments = path.split("/", -1);
        StringBuilder result = new StringBuilder();
        int depth = 0;
        int totalSegments = 0;
        
        // Prevent stack overflow with excessive segments
        final int MAX_SEGMENTS = 1000; // Reasonable limit for path segments
        if (segments.length > MAX_SEGMENTS) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.EXCESSIVE_NESTING)
                .validationType(validationType)
                .originalInput(path)
                .detail(STR."Path contains too many segments: \{segments.length} (max: \{MAX_SEGMENTS})")
                .build();
        }
        
        for (String segment : segments) {
            totalSegments++;
            
            // Additional recursion protection
            if (totalSegments > MAX_SEGMENTS) {
                throw UrlSecurityException.builder()
                    .failureType(UrlSecurityFailureType.EXCESSIVE_NESTING)
                    .validationType(validationType)
                    .originalInput(path)
                    .detail(STR."Processing exceeded maximum segment count: \{MAX_SEGMENTS}")
                    .build();
            }
            
            switch (segment) {
                case "." -> {
                    // Current directory - skip
                }
                case ".." -> {
                    // Parent directory
                    if (!result.isEmpty()) {
                        // Remove last segment
                        int lastSlash = result.lastIndexOf("/");
                        if (lastSlash >= 0) {
                            result.setLength(lastSlash);
                            depth = Math.max(0, depth - 1); // Prevent negative depth
                        }
                    } else {
                        // Trying to go above root
                        depth = Math.max(0, depth - 1);
                    }
                }
                case "" -> {
                    // Empty segment - skip
                }
                default -> {
                    // Normal segment
                    if (!result.isEmpty() || path.startsWith("/")) {
                        result.append("/");
                    }
                    result.append(segment);
                    depth++;
                    
                    // Check depth limit during processing
                    if (depth > config.getMaxDirectoryDepth()) {
                        throw UrlSecurityException.builder()
                            .failureType(UrlSecurityFailureType.EXCESSIVE_NESTING)
                            .validationType(validationType)
                            .originalInput(path)
                            .sanitizedInput(result.toString())
                            .detail(STR."Path depth \{depth} exceeds maximum \{config.getMaxDirectoryDepth()}")
                            .build();
                    }
                }
            }
        }
        
        // Preserve trailing slash if present
        if (path.endsWith("/") && !result.toString().endsWith("/")) {
            result.append("/");
        }
        
        return result.toString();
    }
    
    private boolean containsPathTraversal(String path) {
        // After normalization, there should be no .. segments
        return path.contains("../") || path.contains("..\\") || path.equals("..");
    }
    
    private boolean escapesRoot(String path) {
        // Check if normalized path tries to escape root
        return path.startsWith("../") || path.startsWith("..\\");
    }
}
----

=== PatternMatchingStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.Value;
import java.util.regex.Pattern;

/**
 * Pattern-based attack detection using pre-compiled patterns.
 * Immutable and optimized for performance.
 * Implemented by: link:plan.adoc#_phase_5_validation_stages[Task V3]
 */
@Value
public class PatternMatchingStage implements HttpSecurityValidator {
    
    // Static patterns shared across all instances
    private static final Pattern PATH_TRAVERSAL_PATTERN = Pattern.compile(
        "(?:^|/)\\.\\.(?:/|$)"
    );
    private static final Pattern ENCODED_TRAVERSAL_PATTERN = Pattern.compile(
        "%(?:2e|2E)%(?:2e|2E)"
    );
    
    UrlSecurityConfig config; // Keep for consistency even if not used
    ValidationType validationType;
    
    @Override
    public String validate(String value) throws UrlSecurityException {
        // Check all patterns efficiently
        if (PATH_TRAVERSAL_PATTERN.matcher(value).find() ||
            ENCODED_TRAVERSAL_PATTERN.matcher(value).find()) {
            
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED)
                .validationType(validationType)
                .originalInput(value)
                .build();
        }
        
        return value;
    }
}
----

== Pipeline Architecture

[NOTE]
====
For detailed pipeline selection guidelines and architecture standards, see link:pipeline-architecture-standards.adoc[Pipeline Architecture Standards].
====

=== Unified Validation Pipeline

A single pipeline implementation handles all validation types through configuration:

[source,java]
----
package de.cuioss.tools.security.http.pipeline;

import lombok.EqualsAndHashCode;
import lombok.ToString;
import java.util.List;
import java.util.Objects;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

/**
 * Specialized validation pipelines for different HTTP component types.
 * Each pipeline is optimized for its specific validation context.
 */
public abstract class AbstractValidationPipeline implements HttpSecurityValidator {
    
    private final @NonNull ConfigStageProvider config;
    private final @NonNull List<HttpSecurityValidator> stages;
    private final @NonNull SecurityEventCounter eventCounter;
    private final @NonNull ValidationType validationType;
    
    public UnifiedValidationPipeline(ConfigStageProvider config, 
                                    SecurityEventCounter eventCounter) {
        this.config = Objects.requireNonNull(config, "Config must not be null");
        this.eventCounter = Objects.requireNonNull(eventCounter, "EventCounter must not be null");
        this.validationType = config.getValidationType();
        
        // Get stages from config - it knows which stages to use
        this.stages = config.getStages();
        
        if (stages.isEmpty()) {
            throw new IllegalArgumentException("Configuration must provide at least one stage");
        }
    }
    
    @Override
    public String validate(String value) throws UrlSecurityException {
        String result = value;
        
        // Sequential execution with early termination
        for (HttpSecurityValidator stage : stages) {
            // Skip null stages and identity validators
            if (stage != null && !(stage instanceof IdentityValidator)) {
                try {
                    result = stage.validate(result);
                } catch (UrlSecurityException e) {
                    // Re-throw with builder pattern
                    throw UrlSecurityException.builder()
                        .failureType(e.getFailureType())
                        .validationType(this.validationType)
                        .originalInput(e.getOriginalInput())
                        .sanitizedInput(e.getSanitizedInput())
                        .detail(e.getMessage())
                        .cause(e.getCause())
                        .build();
                    
                    // Track security event
                    eventCounter.increment(e.getFailureType());
                    
                    // Log via URLSecurityLogMessages
                    logSecurityEvent(e);
                    
                    // Re-throw
                    throw e;
                }
            }
        }
        
        return result;
    }
    
    private void logSecurityEvent(UrlSecurityException e) {
        // Log security events based on failure type with pattern guards
        CuiLogger logger = new CuiLogger(UnifiedValidationPipeline.class);
        
        // Sanitize sensitive data before logging (only values, not keys/URLs)
        String sanitizedInput = sanitizeForLogging(e.originalInput(), e.validationType());
        
        // Use direct enum switch - proper Java 21 syntax (no 'when' guards)
        switch (e.failureType()) {
            case PATH_TRAVERSAL_DETECTED ->
                logger.warn(URLSecurityLogMessages.WARN.PATH_TRAVERSAL_DETECTED, 
                    sanitizedInput);
            case DOUBLE_ENCODING ->
                logger.warn(URLSecurityLogMessages.WARN.DOUBLE_ENCODING_DETECTED, 
                    sanitizedInput);
            case UNICODE_NORMALIZATION_CHANGED ->
                logger.warn(URLSecurityLogMessages.WARN.UNICODE_ATTACK_DETECTED);
            default ->
                logger.error(URLSecurityLogMessages.ERROR.VALIDATION_FAILED, 
                    e.failureType(), e.getMessage());
        }
    }
    
    /**
     * Sanitizes sensitive data for logging.
     * Only sanitizes parameter values and header values, not keys or URLs themselves.
     */
    private String sanitizeForLogging(@NonNull String input, @NonNull ValidationType type) {
        return switch (type) {
            case PARAMETER_VALUE -> {
                // Sanitize parameter values only
                String[] parts = input.split("=", 2);
                yield parts.length == 2 ? STR."\{parts[0]}=***" : input;
            }
    }
}

// Specialized pipeline architecture ensures each HTTP component
// uses validation stages optimized for its security requirements
//
// - URLPathValidationPipeline: Path traversal, encoding attacks
// - URLParameterValidationPipeline: XSS, injection via parameters  
// - HTTPHeaderValidationPipeline: Header injection, CRLF attacks
// - HTTPBodyValidationPipeline: Content-based attacks, DoS patterns
----

== Security Event Tracking

=== Event Counter Pattern

[source,java]
----
package de.cuioss.tools.security.http.security;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Thread-safe security event counter.
 * Tracks occurrences of each UrlSecurityFailureType.
 * Implemented by: link:plan.adoc#_phase_4_security_tracking_and_monitoring[Task S1]
 */
public class SecurityEventCounter {
    
    private final ConcurrentHashMap<UrlSecurityFailureType, AtomicLong> counters = 
        new ConcurrentHashMap<>();
    
    /**
     * Increment counter for a failure type.
     * @return new count value
     */
    public long increment(UrlSecurityFailureType type) {
        return counters.computeIfAbsent(type, k -> new AtomicLong(0))
                      .incrementAndGet();
    }
    
    /**
     * Get current count for a failure type.
     */
    public long getCount(@NonNull UrlSecurityFailureType type) {
        return Optional.ofNullable(counters.get(type))
            .map(AtomicLong::get)
            .orElse(0L);
    }
}
----

=== Structured Logging

[source,java]
----
package de.cuioss.tools.security.http.security;

import de.cuioss.tools.logging.LogRecord;
import de.cuioss.tools.logging.LogRecordModel;

/**
 * Structured log messages for URL security events.
 * Follows cui-jwt-validation LogRecord pattern.
 * Implemented by: link:plan.adoc#_phase_4_security_tracking_and_monitoring[Task S2]
 */
public final class URLSecurityLogMessages {
    
    private static final String PREFIX = "URLSecurity";
    
    public static final class WARN {
        
        public static final LogRecord PATH_TRAVERSAL_DETECTED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(301)
                .template("Path traversal attempt detected: %s")
                .build();
        
        public static final LogRecord DOUBLE_ENCODING_DETECTED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(302)
                .template("Double encoding attack detected: %s")
                .build();
        
        public static final LogRecord UNICODE_ATTACK_DETECTED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(303)
                .template("Unicode normalization attack detected")
                .build();
    }
    
    public static final class ERROR {
        
        public static final LogRecord VALIDATION_FAILED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(401)
                .template("URL validation failed: %s - %s")
                .build();
    }
}
----

== Performance Optimization

=== Optimization Strategies

1. **Pre-compilation**: All patterns compiled during construction
2. **Immutable Caching**: Configuration and patterns stored in final fields
3. **Early Termination**: Stop processing on first security violation
4. **Efficient Algorithms**: Use StringBuilder, BitSet for character validation
5. **Memory Management**: Minimize string allocations

=== Performance Requirements

- Individual stage: <0.2ms per stage
- Complete pipeline: <1ms total for typical inputs (5 stages × 0.2ms)
- Memory: O(n) where n is input length
- Thread safety: No synchronization needed (immutable)
- Benchmark: 95th percentile must meet these requirements

== Usage Example

[source,java]
----
// Create security configuration with defaults
SecurityConfiguration config = SecurityConfiguration.defaults();
SecurityEventCounter eventCounter = new SecurityEventCounter();

// Create specialized validation pipelines using PipelineFactory
HttpSecurityValidator pathValidator = PipelineFactory.createUrlPathPipeline(config, eventCounter);
HttpSecurityValidator paramValidator = PipelineFactory.createUrlParameterPipeline(config, eventCounter);
HttpSecurityValidator headerNameValidator = PipelineFactory.createHeaderNamePipeline(config, eventCounter);
HttpSecurityValidator headerValueValidator = PipelineFactory.createHeaderValuePipeline(config, eventCounter);
HttpSecurityValidator bodyValidator = PipelineFactory.createBodyPipeline(config, eventCounter);

// Or use generic factory method with ValidationType
HttpSecurityValidator genericValidator = PipelineFactory.createPipeline(
    ValidationType.URL_PATH, config, eventCounter);

// Convenience method for common pipeline set
PipelineFactory.PipelineSet pipelines = PipelineFactory.createCommonPipelines(config, eventCounter);

// Use specialized validators for different HTTP components
try {
    String safePath = pathValidator.validate("/api/users/123");
    String safeParam = paramValidator.validate("test%20query");
    String safeHeaderName = headerNameValidator.validate("Authorization");
    String safeHeaderValue = headerValueValidator.validate("Bearer abc123");
    String safeBody = bodyValidator.validate("{\"user\":\"test\"}");
} catch (UrlSecurityException e) {
    // Exception includes failure type and original input
    log.warn("Security violation: {} - {}", 
        e.getFailureType(), 
        e.getOriginalInput());
}

// PipelineFactory provides type-safe pipeline creation
// Each specialized pipeline optimizes validation stages for its HTTP component:
//
// URLPathValidationPipeline:
//   - DecodingStage (URL decoding, path normalization)
//   - PatternMatchingStage (path traversal patterns: ../, ..\ variations)
//   - LengthValidationStage (path length limits)
//   - CharacterValidationStage (valid path characters)
//
// URLParameterValidationPipeline:
//   - DecodingStage (URL parameter decoding)
//   - PatternMatchingStage (XSS, injection patterns)
//   - LengthValidationStage (parameter value limits)
//   - CharacterValidationStage (parameter character restrictions)
//
// HTTPHeaderValidationPipeline:
//   - NormalizationStage (header name/value normalization)
//   - PatternMatchingStage (header injection, CRLF patterns)
//   - LengthValidationStage (header length limits per RFC 7230)
//   - CharacterValidationStage (valid header characters)
//
// HTTPBodyValidationPipeline:
//   - DecodingStage (content encoding handling)
//   - PatternMatchingStage (content-based attack patterns)
//   - LengthValidationStage (body size limits, DoS prevention)
//   - CharacterValidationStage (content character validation)
----

=== Pipeline Factory Pattern

The `PipelineFactory` provides centralized creation of all HTTP security validation pipelines:

[source,java]
----
/**
 * Factory class for creating HTTP security validation pipelines.
 * Provides centralized creation with consistent configuration and monitoring.
 */
public final class PipelineFactory {
    
    // Specialized factory methods for common use cases
    public static HttpSecurityValidator createUrlPathPipeline(
            SecurityConfiguration config, SecurityEventCounter eventCounter);
    
    public static HttpSecurityValidator createUrlParameterPipeline(
            SecurityConfiguration config, SecurityEventCounter eventCounter);
    
    public static HttpSecurityValidator createHeaderNamePipeline(
            SecurityConfiguration config, SecurityEventCounter eventCounter);
    
    public static HttpSecurityValidator createHeaderValuePipeline(
            SecurityConfiguration config, SecurityEventCounter eventCounter);
    
    public static HttpSecurityValidator createBodyPipeline(
            SecurityConfiguration config, SecurityEventCounter eventCounter);
    
    // Generic factory method based on validation type
    public static HttpSecurityValidator createPipeline(
            ValidationType validationType, 
            SecurityConfiguration config, 
            SecurityEventCounter eventCounter);
    
    // Convenience method for common pipeline set
    public static PipelineSet createCommonPipelines(
            SecurityConfiguration config, 
            SecurityEventCounter eventCounter);
}
----

== Security Considerations

=== Attack Coverage

- Path traversal: ../, ..\, encoded variants
- HTTP protocol encoding attacks: Double/triple URL encoding, UTF-8 overlong encoding, mixed case hex encoding
- Unicode attacks: Normalization, homographs, control characters
- Injection: XSS, SQL, LDAP, command injection patterns
- Protocol attacks: Header injection, request smuggling
- DoS: Size limits, algorithmic complexity

=== Default Security Posture

- All defaults follow maximum security (OWASP/RFC)
- No lenient modes - security by default
- Explicit overrides required for less restrictive settings
- Comprehensive logging and monitoring