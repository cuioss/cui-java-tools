= OWASP Path Traversal Prevention Best Practices
:toc: left
:toclevels: 3
:sectnums:
:icons: font

link:README.adoc[‚Üê Back to Documentation Index]

== Executive Summary

This document consolidates OWASP's comprehensive guidelines for preventing path traversal vulnerabilities, based on extensive research of the OWASP Web Security Testing Guide, Prevention Cheat Sheets, and real-world vulnerability analysis. Path traversal attacks accounted for 2.7% of vulnerabilities in open-source projects in 2024, with an 85% increase in closed-source projects, highlighting the critical importance of proper prevention techniques.

== Core Prevention Principles

=== Primary Defense: Avoid User Input in File Operations

The most effective defense against path traversal is to completely avoid passing user-supplied input to filesystem APIs.

**Implementation Strategies:**
* Use indirect reference maps (user selects from numbered options)
* Generate internal identifiers mapped to actual resources
* Store files with system-generated names, maintaining original names separately

=== Defense in Depth Architecture

When user input cannot be avoided, implement multiple layers of defense:

[cols="1,3,2"]
|===
|Layer |Control |Purpose

|1
|Input Validation (Whitelist)
|Accept only known-good values

|2
|Path Canonicalization
|Resolve to absolute paths

|3
|Containment Validation
|Ensure paths stay within boundaries

|4
|Access Controls
|Limit filesystem permissions

|5
|Monitoring & Logging
|Detect and respond to attacks

|===

== OWASP Recommended Implementation

=== Input Validation Techniques

==== Whitelist Validation (Preferred)
```java
// Define allowed files
Set<String> allowedFiles = Set.of("report.pdf", "summary.doc", "data.csv");

// Validate input
if (!allowedFiles.contains(userInput)) {
    throw new SecurityException("Invalid file requested");
}
```

==== Character Validation
```java
// Allow only alphanumeric and specific characters
Pattern VALID_FILE_PATTERN = Pattern.compile("^[a-zA-Z0-9._-]+$");

if (!VALID_FILE_PATTERN.matcher(userInput).matches()) {
    throw new SecurityException("Invalid characters in filename");
}
```

=== Path Canonicalization and Validation

==== Java Implementation Pattern
```java
public Path validatePath(String userInput, Path baseDirectory) 
        throws SecurityException {
    // Step 1: Resolve the path
    Path resolvedPath = baseDirectory.resolve(userInput).normalize();
    
    // Step 2: Get canonical path
    Path canonicalPath = resolvedPath.toRealPath();
    
    // Step 3: Verify containment
    if (!canonicalPath.startsWith(baseDirectory.toRealPath())) {
        throw new SecurityException("Path traversal detected");
    }
    
    return canonicalPath;
}
```

==== Platform-Specific Considerations
* **Windows**: Handle both forward and backward slashes
* **Unix/Linux**: Consider case sensitivity
* **All Platforms**: Handle symbolic links appropriately

=== Encoding and Decoding Handling

==== Common Encoding Schemes to Address

[cols="2,3,2"]
|===
|Encoding Type |Example |Decoded Value

|URL Encoding
|`%2e%2e%2f`
|`../`

|Double Encoding
|`%252e%252e%252f`
|`../` (after double decode)

|Unicode
|`\u002e\u002e\u002f`
|`../`

|Mixed Case (Windows)
|`..\\..\\`
|`../../`

|Null Bytes
|`file.pdf%00.jpg`
|`file.pdf` (bypasses extension check)

|===

==== Comprehensive Decoding Implementation
```java
public String normalizeInput(String input) {
    // Decode URL encoding
    String decoded = URLDecoder.decode(input, StandardCharsets.UTF_8);
    
    // Normalize Unicode
    decoded = Normalizer.normalize(decoded, Normalizer.Form.NFC);
    
    // Remove null bytes
    decoded = decoded.replace("\0", "");
    
    // Normalize path separators
    decoded = decoded.replace('\\', '/');
    
    return decoded;
}
```

== OWASP Testing Methodology

=== Input Vector Enumeration

Identify all potential entry points for path traversal:

1. **HTTP Parameters**
   - GET parameters: `?file=`, `?page=`, `?doc=`
   - POST body parameters
   - Multipart form data

2. **HTTP Headers**
   - Custom headers
   - Cookie values
   - Referer headers

3. **File Upload**
   - Filename parameters
   - Content-Type headers
   - Archive contents (Zip Slip)

=== Test Cases from OWASP Guide

==== Basic Traversal Patterns
```
../../../etc/passwd
..\..\..\..\windows\win.ini
....//....//....//etc/passwd
..;/..;/..;/etc/passwd
```

==== Encoded Traversal Patterns
```
%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd
%252e%252e%252f
..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
```

==== Advanced Bypass Techniques
```
/var/www/../../etc/passwd
C:\inetpub\wwwroot\..\..\Windows\win.ini
/../../../../../../../../etc/passwd%00.jpg
....\/....\/....\/etc/passwd
```

=== Validation Testing Approach

1. **Positive Testing**: Verify legitimate file access works
2. **Negative Testing**: Confirm malicious patterns are blocked
3. **Boundary Testing**: Test edge cases and limits
4. **Encoding Testing**: Verify all encoding schemes handled
5. **Platform Testing**: Test OS-specific patterns

== Security Patterns and Architecture

=== Secure File Access Pattern

```java
public class SecureFileAccess {
    private final Path baseDirectory;
    private final Set<String> allowedExtensions;
    
    public SecureFileAccess(Path baseDirectory) {
        this.baseDirectory = baseDirectory.toAbsolutePath().normalize();
        this.allowedExtensions = Set.of(".pdf", ".txt", ".doc");
    }
    
    public byte[] readFile(String filename) throws IOException {
        // 1. Validate filename format
        if (!isValidFilename(filename)) {
            throw new SecurityException("Invalid filename");
        }
        
        // 2. Check extension
        if (!hasAllowedExtension(filename)) {
            throw new SecurityException("File type not allowed");
        }
        
        // 3. Resolve and validate path
        Path filePath = baseDirectory.resolve(filename).normalize();
        Path realPath = filePath.toRealPath();
        
        if (!realPath.startsWith(baseDirectory)) {
            throw new SecurityException("Path traversal attempted");
        }
        
        // 4. Additional access control check
        if (!Files.isReadable(realPath)) {
            throw new SecurityException("File not accessible");
        }
        
        // 5. Read with size limit
        long fileSize = Files.size(realPath);
        if (fileSize > MAX_FILE_SIZE) {
            throw new SecurityException("File too large");
        }
        
        return Files.readAllBytes(realPath);
    }
}
```

=== Container and Isolation Strategies

==== Chroot Jail Implementation
```bash
# Create chroot environment
chroot /var/www/sandbox /usr/bin/app

# Application sees /var/www/sandbox as root
# Cannot access files outside sandbox
```

==== Docker Container Isolation
```dockerfile
FROM openjdk:11-slim
# Create non-root user
RUN useradd -m -u 1000 appuser
# Set restricted directory
WORKDIR /app
# Copy only necessary files
COPY --chown=appuser:appuser ./target/app.jar .
# Run as non-root
USER appuser
# Minimal permissions
RUN chmod 400 /app/app.jar
```

== Real-World Attack Patterns and Prevention

=== Zip Slip Prevention

The Zip Slip vulnerability (affecting thousands of projects) demonstrates archive extraction risks:

==== Vulnerable Pattern
```java
// VULNERABLE CODE - DO NOT USE
Enumeration<ZipEntry> entries = zip.getEntries();
while (entries.hasMoreElements()) {
    ZipEntry entry = entries.nextElement();
    File file = new File(destinationDir, entry.getName()); // VULNERABLE
    // ... extract file
}
```

==== Secure Implementation
```java
// SECURE IMPLEMENTATION
public void extractZip(ZipFile zip, Path destinationDir) throws IOException {
    Enumeration<ZipEntry> entries = zip.entries();
    while (entries.hasMoreElements()) {
        ZipEntry entry = entries.nextElement();
        
        // Validate entry name
        Path entryPath = destinationDir.resolve(entry.getName()).normalize();
        if (!entryPath.startsWith(destinationDir)) {
            throw new SecurityException("Zip entry escapes target directory");
        }
        
        // Safe extraction
        if (entry.isDirectory()) {
            Files.createDirectories(entryPath);
        } else {
            Files.createDirectories(entryPath.getParent());
            try (InputStream is = zip.getInputStream(entry)) {
                Files.copy(is, entryPath, StandardCopyOption.REPLACE_EXISTING);
            }
        }
    }
}
```

=== URL Path Validation

For web applications handling URL paths:

```java
public class URLPathValidator {
    
    public boolean isValidURLPath(String urlPath) {
        // Decode URL encoding
        String decoded = URLDecoder.decode(urlPath, StandardCharsets.UTF_8);
        
        // Check for double encoding
        String doubleDecoded = URLDecoder.decode(decoded, StandardCharsets.UTF_8);
        if (!decoded.equals(doubleDecoded)) {
            return false; // Double encoding detected
        }
        
        // Check for traversal patterns
        if (decoded.contains("..") || 
            decoded.contains("./") || 
            decoded.contains("/.") ||
            decoded.contains("\\")) {
            return false;
        }
        
        // Additional checks for URL-specific patterns
        if (decoded.contains("%") || // Remaining encoding
            decoded.contains("~") ||  // User directory access
            decoded.contains(":")) {  // Protocol or drive letter
            return false;
        }
        
        return true;
    }
}
```

== Monitoring and Detection

=== Logging Strategy

```java
public class PathTraversalMonitor {
    private static final Logger logger = LoggerFactory.getLogger(PathTraversalMonitor.class);
    private static final Logger securityLogger = LoggerFactory.getLogger("SECURITY");
    
    public void logSuspiciousAccess(String userId, String requestedPath, String clientIP) {
        securityLogger.warn("Potential path traversal attempt - User: {}, Path: {}, IP: {}", 
                           userId, requestedPath, clientIP);
        
        // Alert if multiple attempts
        if (getRecentAttemptCount(userId) > THRESHOLD) {
            securityLogger.error("Multiple path traversal attempts detected from user: {}", userId);
            // Trigger security response
            blockUser(userId);
        }
    }
}
```

=== Detection Patterns

Monitor for these indicators:
* Multiple `../` sequences in requests
* Encoded traversal patterns
* Requests for known sensitive files (`/etc/passwd`, `web.config`)
* Unusual file extensions or paths
* Rapid successive requests with different paths

== CVE Case Studies and Lessons

=== CVE-2023-32235 (Ghost CMS)

**Attack Vector**: URL-encoded path traversal
```
/assets/built%2F..%2F..%2F/package.json
```

**Lesson**: Always decode before validation

=== CVE-2023-50164 (Apache Struts)

**Attack Vector**: File upload path manipulation
**Impact**: Remote code execution via uploaded JSP shells

**Lesson**: Validate upload destinations and content types

=== CVE-2021-29425 (Apache Commons IO)

**Attack Vector**: Malformed paths like `//../foo`
**Impact**: Parent directory access

**Lesson**: Edge cases in normalization logic

== Implementation Checklist

- [ ] Avoid user input in file operations where possible
- [ ] Implement whitelist validation for allowed files
- [ ] Use canonical path resolution
- [ ] Validate path containment after resolution
- [ ] Handle all encoding schemes (URL, Unicode, double)
- [ ] Implement proper error handling without information disclosure
- [ ] Set restrictive file permissions
- [ ] Use chroot/container isolation where appropriate
- [ ] Log and monitor suspicious access patterns
- [ ] Regular security testing with OWASP methodology
- [ ] Keep libraries updated for security patches
- [ ] Implement rate limiting for file access
- [ ] Validate file extensions and content types
- [ ] Use secure defaults in frameworks
- [ ] Document security assumptions and boundaries

== HTTP/URL Standards and Validation

=== RFC Compliance for URL Validation

==== RFC 3986 - URI Generic Syntax

* **Unreserved Characters**: `A-Z`, `a-z`, `0-9`, `-`, `.`, `_`, `~`
* **Reserved Characters**: `:`, `/`, `?`, `#`, `[`, `]`, `@`, `!`, `$`, `&`, `'`, `(`, `)`, `*`, `+`, `,`, `;`, `=`
* **Percent-Encoding Required**: For all other characters
* **Path Segment Rules**: Cannot contain unencoded `?` or `#`

==== RFC 7230 - HTTP/1.1 Message Syntax

* **Request-URI**: Must be properly encoded
* **Header Field Names**: Token characters only
* **Path Normalization**: Remove dot-segments
* **Case Sensitivity**: Path components are case-sensitive

=== HTTP Parameter Validation

```java
public class HTTPParameterValidator {
    // RFC 7230 token characters
    private static final Pattern VALID_PARAM_NAME = 
        Pattern.compile("^[a-zA-Z0-9!#$%&'*+\\-.^_`|~]+$");
    
    // RFC 3986 query string validation
    private static final Pattern VALID_PARAM_VALUE = 
        Pattern.compile("^[\\x21-\\x7E\\x80-\\xFF]*$");
    
    public boolean isValidParameterName(String name) {
        return VALID_PARAM_NAME.matcher(name).matches();
    }
    
    public boolean isValidParameterValue(String value) {
        // Decode first, then validate
        String decoded = URLDecoder.decode(value, StandardCharsets.UTF_8);
        return !containsPathTraversal(decoded);
    }
}
```

== References

* OWASP Web Security Testing Guide v4.2
* OWASP Path Traversal Prevention Cheat Sheet
* OWASP Top 10 2021 - A01:2021 Broken Access Control
* CISA/FBI Security by Design Alert (2024)
* CVE Database and National Vulnerability Database
* Snyk Security Research on Zip Slip
* PortSwigger Web Security Academy

**Source URLs:**
* https://owasp.org/www-project-web-security-testing-guide/
* https://cheatsheetseries.owasp.org/cheatsheets/Path_Traversal_Defense_Cheat_Sheet.html
* https://portswigger.net/web-security/file-path-traversal

_Document generated: 2025-01-06_
_Based on OWASP guidelines and real-world vulnerability research_