= Path Traversal Security Architecture and Design Document
:toc: left
:toclevels: 3
:sectnums:
:icons: font

link:README.adoc[← Back to Documentation Index]

== Executive Summary

This document presents a comprehensive architecture and design for HTTP URL path traversal security validation leveraging Java 21+ built-in types. The design focuses exclusively on HTTP/URL contexts, utilizing Java's native URL, URI, URLDecoder, and Pattern classes to minimize custom code while maintaining robust security.

== Design Goals and Principles

=== Primary Goals

1. **HTTP/URL Focus**: Specialized validation for HTTP request paths and parameters
2. **Java Built-in Types**: Leverage Java 21+ native URL/URI validation capabilities
3. **Zero False Negatives**: Block all known HTTP path traversal patterns
4. **RFC Compliance**: Full RFC 3986 and RFC 7230 compliance using Java's URI class
5. **Performance**: Sub-millisecond validation using native Java types
6. **Simplicity**: Minimal custom code by leveraging Java standard library
7. **Security by Default**: Combine Java's syntactic validation with semantic security

=== Design Principles

[cols="2,3"]
|===
|Principle |Implementation

|Defense in Depth
|Multiple validation layers, each catching different attack classes

|Fail Secure
|Reject ambiguous or unparseable input rather than attempting correction

|Least Privilege
|Minimal permissions required for validation operations

|Separation of Concerns
|Distinct components for different validation aspects

|Zero Trust
|Assume all input is malicious until proven otherwise

|Transparency
|Clear logging and audit trail for security decisions

|===

== System Architecture

=== High-Level Architecture Using Java 21+ Built-in Types

```
┌─────────────────────────────────────────────────────────┐
│                 HTTP URL Validator                       │
│         (Leveraging Java 21 Built-in Types)             │
└─────────────┬───────────────────────────────────────────┘
              │
┌─────────────▼───────────────────────────────────────────┐
│              Validation Pipeline                         │
│     Using Java Standard Library Components               │
├──────────────┬────────────┬────────────┬───────────────┤
│ URLDecoder   │    URI     │  Pattern   │   Custom      │
│ (Built-in)   │ (Built-in) │ (Built-in) │  Security     │
└──────────────┴────────────┴────────────┴───────────────┘
```

=== Component Architecture

==== Core Components

```java
package de.cuioss.tools.security.http;

import java.net.URI;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

/**
 * HTTP URL path validator using Java 21 built-in types
 */
public final class HttpUrlValidator {
    
    /**
     * Validates an HTTP URL path using Java's built-in validation
     */
    public ValidationResult validateUrlPath(String urlPath) {
        // Step 1: Decode using Java's URLDecoder
        String decoded = fullyDecode(urlPath);
        
        // Step 2: Check for double encoding (security issue)
        if (hasDoubleEncoding(urlPath, decoded)) {
            return ValidationResult.blocked("Double encoding detected");
        }
        
        // Step 3: Use Java's URI for RFC 3986 validation and normalization
        try {
            // Create URI with just the path component for validation
            URI uri = new URI(null, null, null, -1, decoded, null, null);
            String normalized = uri.normalize().getPath();
            
            // Step 4: Check if normalization revealed traversal
            if (normalized != null && !normalized.equals(decoded)) {
                if (normalized.contains("..")) {
                    return ValidationResult.blocked("Path traversal detected after normalization");
                }
            }
            
            // Step 5: Use conditional checks (pattern matching with guards requires preview features)
            if (decoded.contains("..")) {
                return ValidationResult.blocked("Direct traversal pattern");
            }
            if (decoded.contains("./")) {
                return ValidationResult.blocked("Current directory reference");
            }
            if (decoded.contains("//")) {
                return ValidationResult.blocked("Double slash pattern");
            }
            if (decoded.matches(".*[\\x00-\\x1f].*")) {
                return ValidationResult.blocked("Control characters detected");
            }
            return ValidationResult.allowed();
            
        } catch (URISyntaxException e) {
            return ValidationResult.blocked("Invalid URI syntax: " + e.getMessage());
        }
    }
    
    private String fullyDecode(String input) {
        String decoded = input;
        String previous;
        int iterations = 0;
        
        do {
            previous = decoded;
            try {
                decoded = URLDecoder.decode(decoded, StandardCharsets.UTF_8);
            } catch (IllegalArgumentException e) {
                // Invalid encoding, return current state
                break;
            }
            iterations++;
        } while (!decoded.equals(previous) && iterations < 10);
        
        return decoded;
    }
    
    private boolean hasDoubleEncoding(String original, String decoded) {
        try {
            String doubleDecoded = URLDecoder.decode(decoded, StandardCharsets.UTF_8);
            return !decoded.equals(doubleDecoded);
        } catch (IllegalArgumentException e) {
            return false;
        }
    }
}
```

=== Validation Pipeline Using Java 21 Built-in Types

==== Pipeline Design with Native Java Components

```java
import java.net.URI;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.regex.Pattern;

/**
 * HTTP validation pipeline leveraging Java 21 features
 */
public class HttpValidationPipeline {
    
    // Java 21 Pattern for attack detection
    private static final Pattern TRAVERSAL_PATTERN = Pattern.compile(
        "(\\.\\./)|(%2e%2e%2f)|(%252e%252e%252f)|(\\.\\.\\\\)|" +
        "(%5c%2e%2e%5c)|(%255c%252e%252e%255c)",
        Pattern.CASE_INSENSITIVE
    );
    
    public sealed interface ValidationResult 
        permits Allowed, Blocked {
        
        record Allowed() implements ValidationResult {}
        record Blocked(String reason) implements ValidationResult {}
    }
    
    public ValidationResult validate(String urlPath) {
        // Stage 1: URL Decoding with Java's URLDecoder
        var decoded = decodeUrl(urlPath);
        if (decoded instanceof DecodingResult.Failed failed) {
            return new Blocked(failed.reason());
        }
        
        // Stage 2: URI Normalization with Java's URI class
        var normalized = normalizeUri(((DecodingResult.Success) decoded).value());
        if (normalized instanceof NormalizationResult.Failed failed) {
            return new Blocked(failed.reason());
        }
        
        // Stage 3: Pattern-based validation using Java regex
        var validated = validatePatterns(((NormalizationResult.Success) normalized).value());
        if (validated instanceof Blocked) {
            return validated;
        }
        
        // Stage 4: Semantic validation
        return validateSemantics(((NormalizationResult.Success) normalized).value());
    }
    
    private DecodingResult decodeUrl(String input) {
        try {
            String decoded = URLDecoder.decode(input, StandardCharsets.UTF_8);
            
            // Check for double encoding
            String doubleDecoded = URLDecoder.decode(decoded, StandardCharsets.UTF_8);
            if (!decoded.equals(doubleDecoded)) {
                return new DecodingResult.Failed("Double encoding detected");
            }
            
            return new DecodingResult.Success(decoded);
        } catch (IllegalArgumentException e) {
            return new DecodingResult.Failed("Invalid URL encoding");
        }
    }
    
    private NormalizationResult normalizeUri(String path) {
        try {
            // Create URI with path component only
            URI uri = new URI(null, null, null, -1, path, null, null);
            String normalized = uri.normalize().getPath();
            
            if (normalized == null) {
                return new NormalizationResult.Failed("Invalid path");
            }
            
            // Check if normalization changed the path (potential traversal)
            if (!normalized.equals(path) && normalized.contains("..")) {
                return new NormalizationResult.Failed("Path traversal via normalization");
            }
            
            return new NormalizationResult.Success(normalized);
        } catch (URISyntaxException e) {
            return new NormalizationResult.Failed("Invalid URI syntax");
        }
    }
    
    private ValidationResult validatePatterns(String path) {
        if (TRAVERSAL_PATTERN.matcher(path).find()) {
            return new Blocked("Traversal pattern detected");
        }
        return new Allowed();
    }
    
    private ValidationResult validateSemantics(String path) {
        // Semantic validation using simple conditionals
        if (path.startsWith("/admin")) {
            return new Blocked("Admin path access denied");
        }
        if (path.contains("WEB-INF")) {
            return new Blocked("Protected directory access");
        }
        if (path.contains("META-INF")) {
            return new Blocked("Protected directory access");
        }
        return new Allowed();
    }
    
    // Java 21 sealed classes for type-safe results
    private sealed interface DecodingResult 
        permits DecodingResult.Success, DecodingResult.Failed {
        record Success(String value) implements DecodingResult {}
        record Failed(String reason) implements DecodingResult {}
    }
    
    private sealed interface NormalizationResult 
        permits NormalizationResult.Success, NormalizationResult.Failed {
        record Success(String value) implements NormalizationResult {}
        record Failed(String reason) implements NormalizationResult {}
    }
}
```

==== Stage Implementations

```java
/**
 * Decoding stage - handles all encoding schemes
 */
public class DecodingStage implements ValidationStage {
    
    private final List<Decoder> decoders = Arrays.asList(
        new UrlDecoderWrapper(),
        new UnicodeDecoder(),
        new HTMLEntityDecoder(),
        new Base64DecoderWrapper(),
        new DoubleEncodingDetector()
    );
    
    @Override
    public StageResult process(ValidationData data) {
        String path = data.getPath();
        
        for (Decoder decoder : decoders) {
            if (decoder.canDecode(path)) {
                path = decoder.decode(path);
                data.addDecodingStep(decoder.getName());
            }
        }
        
        // Check for remaining encoding
        if (hasRemainingEncoding(path)) {
            return StageResult.blocked("Undecodeable content detected");
        }
        
        return StageResult.proceed(data.withPath(path));
    }
}

/**
 * Normalization stage - platform-aware path normalization
 */
public class NormalizationStage implements ValidationStage {
    
    @Override
    public StageResult process(ValidationData data) {
        String normalized = normalizePath(data.getPath(), data.getPlatform());
        
        // Detect normalization bypass attempts
        if (isNormalizationBypass(data.getPath(), normalized)) {
            return StageResult.blocked("Normalization bypass detected");
        }
        
        return StageResult.proceed(data.withPath(normalized));
    }
    
    private String normalizePath(String path, Platform platform) {
        // Platform-specific normalization
        return platform.getNormalizer().normalize(path);
    }
}
```

== Security Validation Strategies

=== Multi-Layer Validation Approach

```java
public class ValidationEngine {
    
    private final List<Validator> validators = Arrays.asList(
        new BlacklistValidator(),      // Known attack patterns
        new WhitelistValidator(),      // Allowed patterns only
        new ContainmentValidator(),    // Path containment checks
        new CanonicalValidator(),      // Canonical path validation
        new SemanticValidator()        // Context-aware validation
    );
    
    public ValidationResult validate(ValidationContext context) {
        for (Validator validator : validators) {
            if (validator.appliesTo(context)) {
                ValidationResult result = validator.validate(context);
                if (result.isBlocked()) {
                    return result;
                }
            }
        }
        return ValidationResult.allowed();
    }
}
```

=== Attack Pattern Detection

```java
public class AttackPatternDetector {
    
    private final PatternMatcher patterns;
    
    public AttackPatternDetector() {
        this.patterns = new PatternMatcher();
        loadCVEPatterns();
        loadOWASPPatterns();
        loadCustomPatterns();
    }
    
    public boolean detectAttack(String path) {
        // Direct pattern matching
        if (patterns.matches(path)) {
            return true;
        }
        
        // Semantic analysis
        if (hasTraversalSemantics(path)) {
            return true;
        }
        
        // Anomaly detection
        if (isAnomalous(path)) {
            return true;
        }
        
        return false;
    }
    
    private void loadCVEPatterns() {
        // Load patterns from CVE database
        patterns.addPattern("CVE-2021-29425", "//../*");
        patterns.addPattern("CVE-2023-32235", "*%2F..%2F..%2F*");
        patterns.addPattern("CVE-2023-50164", "../../WEB-INF/*");
        // ... more CVE patterns
    }
}
```


=== Comprehensive HTTP Parameter Validation

==== URL Query Parameter Value Validation

```java
public class URLParameterValueValidator {
    
    // RFC 3986 query component validation with comprehensive checks
    public ValidationResult validateQueryParameter(String name, String value) {
        // 1. Validate parameter name (RFC 7230 token)
        if (!isValidParameterName(name)) {
            return ValidationResult.blocked("Invalid parameter name: " + name);
        }
        
        // 2. Check raw value for suspicious patterns before decoding
        if (hasDoubleEncoding(value)) {
            return ValidationResult.blocked("Double encoding detected in: " + name);
        }
        
        // 3. Fully decode the parameter value
        String decoded = fullyDecode(value);
        
        // 4. Validate based on parameter context
        if (isURLParameter(name)) {
            return validateURLValue(name, decoded);
        } else if (isNumericParameter(name)) {
            return validateNumericValue(name, decoded);
        }
        
        // 5. Generic validation for all parameters
        return validateGenericValue(name, decoded);
    }
    
    private ValidationResult validateGenericValue(String name, String value) {
        // Path traversal patterns
        if (containsPathTraversal(value)) {
            return ValidationResult.blocked("Path traversal in: " + name);
        }
        
        // Null byte injection
        if (value.contains("\0")) {
            return ValidationResult.blocked("Null byte in: " + name);
        }
        
        return ValidationResult.allowed();
    }
    
    private ValidationResult validateURLValue(String name, String value) {
        // Check for javascript: protocol
        if (value.toLowerCase().startsWith("javascript:")) {
            return ValidationResult.blocked("JavaScript protocol in: " + name);
        }
        
        // Check for data: protocol (potential XSS)
        if (value.toLowerCase().startsWith("data:")) {
            return ValidationResult.blocked("Data protocol in: " + name);
        }
        
        // Validate URL format
        try {
            URL url = new URL(value);
            // Check for non-HTTP protocols
            String protocol = url.getProtocol();
            if (!"http".equalsIgnoreCase(protocol) && !"https".equalsIgnoreCase(protocol)) {
                return ValidationResult.blocked("Only HTTP/HTTPS protocols allowed: " + name);
            }
        } catch (MalformedURLException e) {
            return ValidationResult.blocked("Invalid URL format: " + name);
        }
        
        return ValidationResult.allowed();
    }
    
    private boolean isValidParameterName(String name) {
        // RFC 7230 token characters
        return name.matches("^[a-zA-Z0-9!#$%&'*+\\-.^_`|~]+$");
    }
    
    private String fullyDecode(String value) {
        String decoded = value;
        String previous;
        int iterations = 0;
        
        do {
            previous = decoded;
            try {
                decoded = URLDecoder.decode(decoded, StandardCharsets.UTF_8);
            } catch (IllegalArgumentException e) {
                break;
            }
            iterations++;
        } while (!decoded.equals(previous) && iterations < 10);
        
        return decoded;
    }
}
```

==== HTTP POST Body Parameter Value Validation

```java
public class BodyParameterValueValidator {
    
    private static final int MAX_FORM_FIELD_LENGTH = 8192;
    
    // Content-Type specific validation
    public ValidationResult validateBodyParameter(String contentType, String name, String value) {
        switch (contentType.toLowerCase()) {
            case "application/x-www-form-urlencoded":
                return validateFormEncodedValue(name, value);
            case "application/json":
                return validateJsonValue(name, value);
            case "multipart/form-data":
                return validateMultipartValue(name, value);
            case "application/xml":
            case "text/xml":
                return validateXmlValue(name, value);
            default:
                return validateGenericValue(name, value);
        }
    }
    
    private ValidationResult validateFormEncodedValue(String name, String value) {
        // URL decode the value
        String decoded = URLDecoder.decode(value, StandardCharsets.UTF_8);
        
        // Check for path traversal
        if (containsPathTraversal(decoded)) {
            return ValidationResult.blocked("Path traversal in form field: " + name);
        }
        
        // Check length limits
        if (decoded.length() > MAX_FORM_FIELD_LENGTH) {
            return ValidationResult.blocked("Form field too long: " + name);
        }
        
        // Check for SQL injection patterns
        if (containsSQLInjection(decoded)) {
            return ValidationResult.blocked("SQL injection pattern in: " + name);
        }
        
        return ValidationResult.allowed();
    }
    
    private ValidationResult validateJsonValue(String name, String value) {
        // Check for JSON injection attacks
        if (value.contains("$where") || value.contains("$regex")) {
            return ValidationResult.blocked("NoSQL injection pattern in: " + name);
        }
        
        // Validate string values for path traversal
        if (containsPathTraversal(value)) {
            return ValidationResult.blocked("Path traversal in JSON: " + name);
        }
        
        // Check for prototype pollution
        if (name.equals("__proto__") || name.equals("constructor") || name.equals("prototype")) {
            return ValidationResult.blocked("Prototype pollution attempt: " + name);
        }
        
        return ValidationResult.allowed();
    }
    
    private ValidationResult validateMultipartValue(String name, String value) {
        // Validate Content-Disposition filename parameter
        if (name.equals("filename")) {
            // Check for path traversal patterns in filename
            if (value.contains("..") || value.contains("/") || value.contains("\\")) {
                return ValidationResult.blocked("Path traversal in filename parameter");
            }
            
            // Check for null bytes
            if (value.contains("\0")) {
                return ValidationResult.blocked("Null byte in filename");
            }
        }
        
        return ValidationResult.allowed();
    }
}
```

=== Cookie Path Validation

```java
public class CookiePathValidator {
    
    // RFC 6265 - HTTP State Management
    public ValidationResult validateCookiePath(String path) {
        // RFC 6265 Section 5.1.4 - Paths
        if (!path.startsWith("/")) {
            return ValidationResult.blocked("Cookie path must start with /");
        }
        
        // Check for path traversal in cookie paths
        if (containsPathTraversal(path)) {
            return ValidationResult.blocked("Path traversal in cookie path");
        }
        
        return ValidationResult.allowed();
    }
}
```

== URL Path Validation (Primary Focus)

=== HTTP Standards Compliance

==== RFC 3986 - URI Generic Syntax Implementation

```java
public class RFC3986Validator {
    
    // RFC 3986 Section 2.2 - Reserved Characters
    private static final String RESERVED = ":/?#[]@!$&'()*+,;=";
    private static final String UNRESERVED = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    
    public boolean isValidURIPath(String path) {
        // RFC 3986 Section 3.3 - Path validation
        for (char c : path.toCharArray()) {
            if (!isUnreserved(c) && !isReserved(c) && !isPercentEncoded(path, c)) {
                return false;
            }
        }
        return true;
    }
    
    private boolean isPercentEncoded(String path, char c) {
        // RFC 3986 Section 2.1 - Percent-Encoding
        return c == '%' && isHexDigit(path.charAt(path.indexOf(c) + 1)) 
                        && isHexDigit(path.charAt(path.indexOf(c) + 2));
    }
}
```

==== RFC 7230 - HTTP/1.1 Message Syntax

```java
public class RFC7230Validator {
    
    // RFC 7230 Section 3.2 - Header Field Structure
    private static final Pattern TOKEN = Pattern.compile("^[!#$%&'*+\\-.0-9A-Z^_`a-z|~]+$");
    
    // RFC 7230 Section 5.3 - Request Target
    public ValidationResult validateRequestTarget(String target) {
        // origin-form = absolute-path [ "?" query ]
        if (target.startsWith("/")) {
            return validateOriginForm(target);
        }
        // absolute-form = absolute-URI
        else if (target.matches("^https?://.*")) {
            return validateAbsoluteForm(target);
        }
        return ValidationResult.blocked("Invalid request target format");
    }
    
    public boolean isValidHeaderName(String name) {
        return TOKEN.matcher(name).matches();
    }
}
```

=== URL-Specific Security

```java
public class URLPathSecurityValidator {
    
    public ValidationResult validateURLPath(String urlPath) {
        // Decode URL encoding
        String decoded = fullyDecode(urlPath);
        
        // Check for double encoding
        if (hasDoubleEncoding(urlPath)) {
            return ValidationResult.blocked("Double encoding detected");
        }
        
        // Validate URL path components
        String[] segments = decoded.split("/");
        for (String segment : segments) {
            if (isTraversalSegment(segment)) {
                return ValidationResult.blocked("Path traversal in URL");
            }
        }
        
        // Check for URL-specific attacks
        if (hasURLAttackPattern(decoded)) {
            return ValidationResult.blocked("URL attack pattern detected");
        }
        
        return ValidationResult.allowed();
    }
    
    private String fullyDecode(String url) {
        String decoded = url;
        String previous;
        
        do {
            previous = decoded;
            decoded = URLDecoder.decode(decoded, StandardCharsets.UTF_8);
        } while (!decoded.equals(previous));
        
        return decoded;
    }
}
```

== Performance Optimization

=== Caching Strategy

```java
public class ValidationCache {
    
    private final Map<String, ValidationResult> cache = new ConcurrentHashMap<>();
    private final Set<String> knownMalicious = Collections.synchronizedSet(new HashSet<>());
    
    public ValidationCache() {
        // Initialize cache with size limit using a simple LRU approach
        // In production, consider using Caffeine or a proper cache library
        // For now, we'll use a simple map with manual eviction
    }
    
    public Optional<ValidationResult> get(String path) {
        // Quick check for known malicious
        if (knownMalicious.contains(path)) {
            return Optional.of(ValidationResult.blocked("Known attack pattern"));
        }
        
        return Optional.ofNullable(cache.get(path));
    }
    
    public void put(String path, ValidationResult result) {
        cache.put(path, result);
        
        if (result.isBlocked()) {
            knownMalicious.add(path);
        }
    }
}
```

=== Performance Metrics

```java
public class PerformanceMonitor {
    
    private final MeterRegistry registry;
    
    public PerformanceMonitor(MeterRegistry registry) {
        this.registry = registry;
    }
    
    public <T> T measure(String operation, Supplier<T> task) {
        return Timer.Sample
            .start(registry)
            .stop(registry.timer("path.validation", "operation", operation))
            .recordCallable(task);
    }
    
    public void recordValidation(ValidationContext context, long duration) {
        registry.timer("path.validation.duration",
            "type", context.getType().name(),
            "result", context.getResult().name()
        ).record(duration, TimeUnit.NANOSECONDS);
        
        registry.counter("path.validation.count",
            "type", context.getType().name()
        ).increment();
    }
}
```

== Security Configuration

=== Configuration Model

```java
@ConfigurationProperties(prefix = "security.path")
public class PathSecurityConfiguration {
    
    /**
     * Validation strictness level
     */
    private StrictnessLevel strictness = StrictnessLevel.HIGH;
    
    /**
     * Allowed content types for multipart uploads
     */
    private Set<String> allowedContentTypes = Set.of(
        "text/plain", "application/json", "application/xml"
    );
    
    /**
     * Maximum path length
     */
    private int maxPathLength = 4096;
    
    /**
     * Enable caching
     */
    private boolean cachingEnabled = true;
    
    /**
     * Custom validation rules
     */
    private List<CustomRule> customRules = new ArrayList<>();
    
    /**
     * HTTP-specific settings
     */
    private HttpSettings httpSettings = new HttpSettings();
    
    public enum StrictnessLevel {
        LOW,      // Basic validation only
        MEDIUM,   // Standard validation
        HIGH,     // Strict validation (default)
        PARANOID  // Maximum security, may block legitimate paths
    }
}
```

== Error Handling and Logging

=== Security-Aware Error Handling

```java
public class SecurityErrorHandler {
    
    /**
     * Handle validation errors without information disclosure
     */
    public ErrorResponse handleError(ValidationException e) {
        // Log detailed error internally
        securityLogger.error("Validation failed", e);
        
        // Return generic error to client
        return ErrorResponse.builder()
            .code("INVALID_PATH")
            .message("The requested path is invalid")
            .build();
    }
    
    /**
     * Audit logging for security events
     */
    public void auditValidation(ValidationContext context, ValidationResult result) {
        AuditEvent event = AuditEvent.builder()
            .timestamp(Instant.now())
            .principal(context.getPrincipal())
            .action("PATH_VALIDATION")
            .resource(sanitizePath(context.getPath()))
            .result(result.isAllowed() ? "ALLOWED" : "BLOCKED")
            .reason(result.getReason())
            .build();
            
        auditLogger.log(event);
    }
}
```

== Integration Patterns


== Monitoring and Observability

=== Metrics Collection

```java
@Component
public class PathSecurityMetrics {
    
    private final MeterRegistry registry;
    
    public void recordValidation(ValidationMetrics metrics) {
        // Record validation counts
        registry.counter("path.validation.total",
            "type", metrics.getType(),
            "result", metrics.getResult()
        ).increment();
        
        // Record performance metrics
        registry.timer("path.validation.duration",
            "type", metrics.getType()
        ).record(metrics.getDuration());
        
        // Record attack detection
        if (metrics.isAttackDetected()) {
            registry.counter("path.validation.attacks",
                "pattern", metrics.getAttackPattern()
            ).increment();
        }
    }
    
    public void exportMetrics() {
        // Prometheus format
        String metrics = registry.scrape();
        
        // Custom format for security dashboard
        SecurityMetrics securityMetrics = SecurityMetrics.builder()
            .totalValidations(getTotalValidations())
            .blockedAttempts(getBlockedAttempts())
            .averageLatency(getAverageLatency())
            .topAttackPatterns(getTopAttackPatterns())
            .build();
    }
}
```

== Future Enhancements

=== Planned Features

1. **Machine Learning Integration**
   - Anomaly detection for zero-day patterns
   - Adaptive threat modeling
   - Behavioral analysis

2. **Cloud-Native Support**
   - S3/Azure Blob/GCS path validation
   - Serverless function path security
   - Container registry path validation

3. **Advanced Threat Intelligence**
   - Real-time CVE feed integration
   - Threat intelligence platform integration
   - Automated pattern updates

4. **Formal Verification**
   - Mathematical proof of security properties
   - Model checking for validation logic
   - Automated security proof generation

== Conclusion

This architecture provides a comprehensive, extensible, and performant solution for path traversal security that addresses the limitations found in existing libraries while incorporating lessons learned from real-world vulnerabilities. The design's modular nature allows for easy extension and adaptation to new threats while maintaining backward compatibility through migration adapters.

== References

=== Security Standards and Frameworks

* link:https://owasp.org/www-project-application-security-verification-standard/[OWASP Application Security Architecture Guide]
* link:https://www.nist.gov/cyberframework[NIST Cybersecurity Framework]
* link:https://www.iso.org/standard/44378.html[ISO/IEC 27034 - Application Security]
* link:https://www.commoncriteriaportal.org/[Common Criteria for Information Technology Security Evaluation]
* link:https://attack.mitre.org/[MITRE ATT&CK Framework]
* link:https://csrc.nist.gov/publications/detail/sp/800-207/final[Zero Trust Architecture (NIST SP 800-207)]

=== HTTP and URL Standards

* link:https://www.rfc-editor.org/rfc/rfc3986[RFC 3986 - Uniform Resource Identifier (URI): Generic Syntax]
* link:https://www.rfc-editor.org/rfc/rfc7230[RFC 7230 - Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing]
* link:https://www.rfc-editor.org/rfc/rfc6265[RFC 6265 - HTTP State Management Mechanism]
* link:https://www.rfc-editor.org/rfc/rfc8941[RFC 8941 - Structured Field Values for HTTP]
* link:https://www.rfc-editor.org/rfc/rfc3987[RFC 3987 - Internationalized Resource Identifiers (IRIs)]

=== Vulnerability Resources

* link:https://cwe.mitre.org/data/definitions/22.html[CWE-22: Improper Limitation of a Pathname to a Restricted Directory]
* link:https://nvd.nist.gov/[National Vulnerability Database]
* link:https://www.first.org/cvss/[Common Vulnerability Scoring System (CVSS)]

_Document generated: 2025-01-06_
_Comprehensive architecture for unified path traversal security_