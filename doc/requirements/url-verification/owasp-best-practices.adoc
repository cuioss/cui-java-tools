= OWASP Path Traversal Prevention Best Practices
:toc: left
:toclevels: 3
:sectnums:
:icons: font

link:README.adoc[‚Üê Back to Documentation Index]

== Executive Summary

This document consolidates OWASP's comprehensive guidelines for preventing path traversal vulnerabilities, based on extensive research of the OWASP Web Security Testing Guide, Prevention Cheat Sheets, and real-world vulnerability analysis. Path traversal attacks accounted for 2.7% of vulnerabilities in open-source projects in 2024, with an 85% increase in closed-source projects, highlighting the critical importance of proper prevention techniques.

== Core Prevention Principles

=== Primary Defense: Avoid User Input in File Operations

The most effective defense against path traversal is to completely avoid passing user-supplied input to filesystem APIs.

**Implementation Strategies:**

* Use indirect reference maps (user selects from numbered options)
* Generate internal identifiers mapped to actual resources
* Store files with system-generated names, maintaining original names separately

=== Defense in Depth Architecture

When user input cannot be avoided, implement multiple layers of defense:

[cols="1,3,2"]
|===
|Layer |Control |Purpose

|1
|Input Validation (Whitelist)
|Accept only known-good values

|2
|Path Canonicalization
|Resolve to absolute paths

|3
|Containment Validation
|Ensure paths stay within boundaries

|4
|Access Controls
|Limit filesystem permissions

|5
|Monitoring & Logging
|Detect and respond to attacks

|===

== OWASP Recommended Implementation

=== Input Validation Techniques

==== Whitelist Validation (Preferred)
[source,java]
----
// Define allowed files
Set<String> allowedFiles = Set.of("report.pdf", "summary.doc", "data.csv");

// Validate input
if (!allowedFiles.contains(userInput)) {
    throw new SecurityException("Invalid file requested");
}
----

==== Character Validation
[source,java]
----
// Allow only alphanumeric and specific characters
Pattern VALID_FILE_PATTERN = Pattern.compile("^[a-zA-Z0-9._-]+$");

if (!VALID_FILE_PATTERN.matcher(userInput).matches()) {
    throw new SecurityException("Invalid characters in filename");
}
----

=== Path Canonicalization and Validation

==== Java Implementation Pattern
[source,java]
----
public Path validatePath(String userInput, Path baseDirectory) 
        throws SecurityException {
    // Step 1: Resolve the path
    Path resolvedPath = baseDirectory.resolve(userInput).normalize();
    
    // Step 2: Get canonical path
    Path canonicalPath = resolvedPath.toRealPath();
    
    // Step 3: Verify containment
    if (!canonicalPath.startsWith(baseDirectory.toRealPath())) {
        throw new SecurityException("Path traversal detected");
    }
    
    return canonicalPath;
}
----

==== Platform-Specific Considerations

* **Windows**: Handle both forward and backward slashes
* **Unix/Linux**: Consider case sensitivity
* **All Platforms**: Handle symbolic links appropriately

=== Encoding and Decoding Handling

==== Common Encoding Schemes to Address

[cols="2,3,2"]
|===
|Encoding Type |Example |Decoded Value

|URL Encoding
|`%2e%2e%2f`
|`../`

|Double Encoding
|`%252e%252e%252f`
|`../` (after double decode)

|Unicode
|`\u002e\u002e\u002f`
|`../`

|Mixed Case (Windows)
|`..\\..\\`
|`../../`

|Null Bytes
|`file.pdf%00.jpg`
|`file.pdf` (bypasses extension check)

|===

==== Comprehensive Decoding Implementation
[source,java]
----
public String normalizeInput(String input) {
    // Decode URL encoding
    String decoded = URLDecoder.decode(input, StandardCharsets.UTF_8);
    
    // Normalize Unicode
    decoded = Normalizer.normalize(decoded, Normalizer.Form.NFC);
    
    // Remove null bytes
    decoded = decoded.replace("\0", "");
    
    // Normalize path separators
    decoded = decoded.replace('\\', '/');
    
    return decoded;
}
----

== OWASP Testing Methodology

=== Input Vector Enumeration

Identify all potential entry points for path traversal:

. **HTTP Parameters**
  * GET parameters: `?file=`, `?page=`, `?doc=`
  * POST body parameters
  * Multipart form data

. **HTTP Headers**
  * Custom headers
  * Cookie values
  * Referer headers

. **File Upload**
  * Filename parameters
  * Content-Type headers

=== Test Cases from OWASP Guide

==== Basic Traversal Patterns
----
../../../etc/passwd
..\..\..\..\windows\win.ini
....//....//....//etc/passwd
..;/..;/..;/etc/passwd
----

==== Encoded Traversal Patterns
----
%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd
%252e%252e%252f
..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
----

==== Advanced Bypass Techniques
----
/var/www/../../etc/passwd
C:\inetpub\wwwroot\..\..\Windows\win.ini
/../../../../../../../../etc/passwd%00.jpg
....\/....\/....\/etc/passwd
----

=== Validation Testing Approach

. **Positive Testing**: Verify legitimate file access works
. **Negative Testing**: Confirm malicious patterns are blocked
. **Boundary Testing**: Test edge cases and limits
. **Encoding Testing**: Verify all encoding schemes handled
. **Platform Testing**: Test OS-specific patterns

== Security Patterns and Architecture

=== Secure File Access Pattern

[source,java]
----
public class SecureFileAccess {
    private final Path baseDirectory;
    private final Set<String> allowedExtensions;
    
    public SecureFileAccess(Path baseDirectory) {
        this.baseDirectory = baseDirectory.toAbsolutePath().normalize();
        this.allowedExtensions = Set.of(".pdf", ".txt", ".doc");
    }
    
    public byte[] readFile(String filename) throws IOException {
        // 1. Validate filename format
        if (!isValidFilename(filename)) {
            throw new SecurityException("Invalid filename");
        }
        
        // 2. Check extension
        if (!hasAllowedExtension(filename)) {
            throw new SecurityException("File type not allowed");
        }
        
        // 3. Resolve and validate path
        Path filePath = baseDirectory.resolve(filename).normalize();
        Path realPath = filePath.toRealPath();
        
        if (!realPath.startsWith(baseDirectory)) {
            throw new SecurityException("Path traversal attempted");
        }
        
        // 4. Additional access control check
        if (!Files.isReadable(realPath)) {
            throw new SecurityException("File not accessible");
        }
        
        // 5. Read with size limit
        long fileSize = Files.size(realPath);
        if (fileSize > MAX_FILE_SIZE) {
            throw new SecurityException("File too large");
        }
        
        return Files.readAllBytes(realPath);
    }
}
----

=== Web Application Security Headers

==== Security Headers for Path Traversal Prevention
[source,java]
----
public class SecurityHeaderFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        // Prevent directory listing
        httpResponse.setHeader("X-Content-Type-Options", "nosniff");
        
        // Prevent clickjacking that might bypass path controls
        httpResponse.setHeader("X-Frame-Options", "DENY");
        
        // Content Security Policy to limit resource loading
        httpResponse.setHeader("Content-Security-Policy", 
            "default-src 'self'; script-src 'self'; object-src 'none';");
        
        // Strict Transport Security
        httpResponse.setHeader("Strict-Transport-Security", 
            "max-age=31536000; includeSubDomains");
        
        chain.doFilter(request, response);
    }
}
----

== Real-World Attack Patterns and Prevention

=== URL Path Validation

For web applications handling URL paths:

[source,java]
----
public class URLPathValidator {
    
    public boolean isValidURLPath(String urlPath) {
        // Decode URL encoding
        String decoded = URLDecoder.decode(urlPath, StandardCharsets.UTF_8);
        
        // Check for double encoding
        String doubleDecoded = URLDecoder.decode(decoded, StandardCharsets.UTF_8);
        if (!decoded.equals(doubleDecoded)) {
            return false; // Double encoding detected
        }
        
        // Check for traversal patterns
        if (decoded.contains("..") || 
            decoded.contains("./") || 
            decoded.contains("/.") ||
            decoded.contains("\\")) {
            return false;
        }
        
        // Additional checks for URL-specific patterns
        if (decoded.contains("%") || // Remaining encoding
            decoded.contains("~") ||  // User directory access
            decoded.contains(":")) {  // Protocol or drive letter
            return false;
        }
        
        return true;
    }
}
----

== Monitoring and Detection

=== Logging Strategy

[source,java]
----
public class PathTraversalMonitor {
    private static final Logger logger = LoggerFactory.getLogger(PathTraversalMonitor.class);
    private static final Logger securityLogger = LoggerFactory.getLogger("SECURITY");
    
    public void logSuspiciousAccess(String userId, String requestedPath, String clientIP) {
        securityLogger.warn("Potential path traversal attempt - User: {}, Path: {}, IP: {}", 
                           userId, requestedPath, clientIP);
        
        // Alert if multiple attempts
        if (getRecentAttemptCount(userId) > THRESHOLD) {
            securityLogger.error("Multiple path traversal attempts detected from user: {}", userId);
            // Trigger security response
            blockUser(userId);
        }
    }
}
----

=== Detection Patterns

Monitor for these indicators:
* Multiple `../` sequences in requests
* Encoded traversal patterns
* Requests for known sensitive files (`/etc/passwd`, `web.config`)
* Unusual file extensions or paths
* Rapid successive requests with different paths

== CVE Case Studies and Lessons

=== CVE-2023-32235 (Ghost CMS)

**Attack Vector**: URL-encoded path traversal
----
/assets/built%2F..%2F..%2F/package.json
----

**Lesson**: Always decode before validation

=== CVE-2023-50164 (Apache Struts)

**Attack Vector**: File upload path manipulation
**Impact**: Remote code execution via uploaded JSP shells

**Lesson**: Validate upload destinations and content types

=== CVE-2021-29425 (Apache Commons IO)

**Attack Vector**: Malformed paths like `//../foo`
**Impact**: Parent directory access

**Lesson**: Edge cases in normalization logic

== Implementation Checklist

- [ ] Avoid user input in file operations where possible
- [ ] Implement whitelist validation for allowed files
- [ ] Use canonical path resolution
- [ ] Validate path containment after resolution
- [ ] Handle all encoding schemes (URL, Unicode, double)
- [ ] Implement proper error handling without information disclosure
- [ ] Set restrictive file permissions
- [ ] Use chroot/container isolation where appropriate
- [ ] Log and monitor suspicious access patterns
- [ ] Regular security testing with OWASP methodology
- [ ] Keep libraries updated for security patches
- [ ] Implement rate limiting for file access
- [ ] Validate file extensions and content types
- [ ] Use secure defaults in frameworks
- [ ] Document security assumptions and boundaries

== HTTP/URL Standards and Validation

=== RFC Compliance for URL Validation

==== RFC 3986 - URI Generic Syntax

* **Unreserved Characters**: `A-Z`, `a-z`, `0-9`, `-`, `.`, `_`, `~`
* **Reserved Characters**: `:`, `/`, `?`, `#`, `[`, `]`, `@`, `!`, `$`, `&`, `'`, `(`, `)`, `*`, `+`, `,`, `;`, `=`
* **Percent-Encoding Required**: For all other characters
* **Path Segment Rules**: Cannot contain unencoded `?` or `#`

==== RFC 7230 - HTTP/1.1 Message Syntax

* **Request-URI**: Must be properly encoded
* **Header Field Names**: Token characters only
* **Path Normalization**: Remove dot-segments
* **Case Sensitivity**: Path components are case-sensitive

=== HTTP Parameter Validation

==== URL Query Parameter Validation

URL query parameters require special attention as they are often used in path construction:

[source,java]
----
public class URLParameterValidator {
    // RFC 7230 token characters for parameter names
    private static final Pattern VALID_PARAM_NAME = 
        Pattern.compile("^[a-zA-Z0-9!#$%&'*+\\-.^_`|~]+$");
    
    // RFC 3986 Section 3.4 - Query component allowed characters
    private static final String QUERY_ALLOWED = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*+,;=";
    
    public ValidationResult validateQueryParameter(String name, String value) {
        // Validate parameter name
        if (!isValidParameterName(name)) {
            return ValidationResult.blocked("Invalid parameter name: " + name);
        }
        
        // Decode parameter value (handle multiple encoding layers)
        String decoded = fullyDecode(value);
        
        // Check for path traversal patterns
        if (containsPathTraversal(decoded)) {
            return ValidationResult.blocked("Path traversal in parameter: " + name);
        }
        
        // Check for null byte injection
        if (decoded.contains("\0") || decoded.contains("%00")) {
            return ValidationResult.blocked("Null byte in parameter: " + name);
        }
        
        // Validate against maximum length (prevent buffer overflow)
        if (decoded.length() > MAX_PARAM_LENGTH) {
            return ValidationResult.blocked("Parameter too long: " + name);
        }
        
        return ValidationResult.allowed();
    }
    
    private String fullyDecode(String value) {
        String decoded = value;
        String previous;
        int iterations = 0;
        
        do {
            previous = decoded;
            try {
                decoded = URLDecoder.decode(decoded, StandardCharsets.UTF_8);
            } catch (IllegalArgumentException e) {
                // Invalid encoding, return as-is for validation
                break;
            }
            iterations++;
        } while (!decoded.equals(previous) && iterations < 10);
        
        return decoded;
    }
}
----

==== HTTP Body Parameter Validation

HTTP POST body parameters (form-data, JSON, XML) require different validation approaches:

[source,java]
----
public class BodyParameterValidator {
    
    // Form-encoded body validation (application/x-www-form-urlencoded)
    public ValidationResult validateFormParameter(String name, String value) {
        // Similar to URL parameters but may contain more data
        String decoded = URLDecoder.decode(value, StandardCharsets.UTF_8);
        
        // Check for path traversal
        if (containsPathTraversal(decoded)) {
            return ValidationResult.blocked("Path traversal in form parameter: " + name);
        }
        
        // Validate against content-type specific rules
        if (isFilePathParameter(name)) {
            return validateFilePath(name, decoded);
        }
        
        return ValidationResult.allowed();
    }
    
    // JSON body validation
    public ValidationResult validateJsonParameter(JsonNode node, String path) {
        if (node.isTextual()) {
            String value = node.asText();
            
            // Check for encoded path traversal
            if (containsEncodedTraversal(value)) {
                return ValidationResult.blocked("Encoded traversal in JSON: " + path);
            }
            
            // Check for path traversal patterns
            if (containsPathTraversal(value)) {
                return ValidationResult.blocked("Path traversal in JSON: " + path);
            }
        }
        
        // Recursively validate nested objects
        if (node.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> field = fields.next();
                ValidationResult result = validateJsonParameter(
                    field.getValue(), 
                    path + "." + field.getKey()
                );
                if (result.isBlocked()) {
                    return result;
                }
            }
        }
        
        return ValidationResult.allowed();
    }
    
    // Multipart form data validation (file uploads)
    public ValidationResult validateMultipartParameter(Part part) throws IOException {
        String filename = extractFilename(part);
        
        if (filename != null) {
            // Validate filename for path traversal
            if (containsPathTraversal(filename)) {
                return ValidationResult.blocked("Path traversal in filename: " + filename);
            }
            
            // Check for double extensions (bypass attempts)
            if (hasDoubleExtension(filename)) {
                return ValidationResult.blocked("Double extension detected: " + filename);
            }
        }
        
        // Validate content if it's text-based
        if (isTextContent(part.getContentType())) {
            try (InputStream is = part.getInputStream()) {
                String content = new String(is.readAllBytes(), StandardCharsets.UTF_8);
                if (containsPathTraversal(content)) {
                    return ValidationResult.blocked("Path traversal in file content");
                }
            }
        }
        
        return ValidationResult.allowed();
    }
}
----

==== Common Parameter Attack Patterns

[cols="2,3,2"]
|===
|Attack Type |Example |Detection Method

|Direct Traversal
|`file=../../../etc/passwd`
|Pattern matching

|Encoded Traversal
|`file=%2e%2e%2f%2e%2e%2f`
|Decode then validate

|Double Encoding
|`file=%252e%252e%252f`
|Recursive decoding

|Unicode Encoding
|`file=%u002e%u002e%u002f`
|Unicode normalization

|Null Byte Injection
|`file=image.jpg%00.pdf`
|Null byte detection

|Parameter Pollution
|`file=safe.txt&file=../etc/passwd`
|Validate all occurrences

|Case Variation
|`file=..%2F..%2f`
|Case-insensitive matching

|===

== References

* link:https://owasp.org/www-project-web-security-testing-guide/[OWASP Web Security Testing Guide v4.2]
* link:https://cheatsheetseries.owasp.org/cheatsheets/Path_Traversal_Defense_Cheat_Sheet.html[OWASP Path Traversal Prevention Cheat Sheet]
* link:https://owasp.org/www-project-top-ten/[OWASP Top 10 2021 - A01:2021 Broken Access Control]
* link:https://nvd.nist.gov/[CVE Database and National Vulnerability Database]
* link:https://snyk.io/research/zip-slip-vulnerability[Snyk Security Research on Zip Slip]
* link:https://portswigger.net/web-security/file-path-traversal[PortSwigger Web Security Academy]

=== RFC Standards

* link:https://www.rfc-editor.org/rfc/rfc3986[RFC 3986 - Uniform Resource Identifier (URI): Generic Syntax]
* link:https://www.rfc-editor.org/rfc/rfc7230[RFC 7230 - Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing]
* link:https://www.rfc-editor.org/rfc/rfc3987[RFC 3987 - Internationalized Resource Identifiers (IRIs)]
* link:https://www.rfc-editor.org/rfc/rfc6265[RFC 6265 - HTTP State Management Mechanism]
* link:https://www.rfc-editor.org/rfc/rfc8941[RFC 8941 - Structured Field Values for HTTP]

