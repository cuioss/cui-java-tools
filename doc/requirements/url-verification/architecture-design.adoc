= URL Security Validation Architecture and Design
:toc: left
:toclevels: 3
:sectnums:
:icons: font

link:README.adoc[← Back to Documentation Index]

[IMPORTANT]
====
This document describes HOW the URL Security Validation system architecture works.
For WHAT tasks to implement, see link:../../../plan.adoc[Implementation Plan].
For HOW to test the system, see link:test-harness-design.adoc[Test Harness Design].
====

== Executive Summary

The URL Security Validation system provides comprehensive protection against path traversal attacks, encoding bypasses, and injection attempts through a layered, immutable, high-performance architecture in the `de.cuioss.tools.security.http` package.

== Design Principles

[cols="2,3"]
|===
|Principle |Implementation

|Defense in Depth
|Sequential validation stages, each catching different attack classes

|Fail Secure
|String/throws pattern - reject on any security violation

|Secure Defaults
|Configuration constants based on OWASP/RFC with documented sources

|Immutability
|All validation stages immutable after construction for thread safety

|Performance First
|Pre-compiled patterns, optimized algorithms, <1ms requirement

|Transparency
|Structured logging via LogRecord pattern, security event counting
|===

== System Architecture

=== High-Level Architecture

----
┌─────────────────────────────────────────────────────────┐
│                    Client Request                        │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│              HttpSecurityValidator                       │
│         (Core validation interface)                      │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│              Validation Pipeline                         │
│         (Sequential stage execution)                     │
├──────────────────────────────────────────────────────────┤
│  Stage 1: LengthValidationStage                         │
│  Stage 2: CharacterValidationStage                      │
│  Stage 3: DecodingStage                                 │
│  Stage 4: NormalizationStage                            │
│  Stage 5: PatternMatchingStage                          │
└──────────────────────────────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│          Security Event Tracking                         │
│    (Counter + LogRecord based logging)                   │
└──────────────────────────────────────────────────────────┘
----

=== Package Structure

----
de.cuioss.tools.security.http/
├── HttpSecurityValidator.java         # Core validation interface
├── UrlSecurityException.java          # Main exception with ValidationType
├── UrlSecurityFailureType.java        # Comprehensive failure enum  
├── ValidationType.java                # Input type classification
│
├── config/
│   ├── ConfigStageProvider.java      # Stage provider interface
│   ├── UrlSecurityConfig.java        # Base configuration with defaults
│   ├── URLPathConfig.java            # URL path specific config
│   ├── URLParameterConfig.java       # Parameter validation config
│   ├── HTTPHeaderConfig.java         # HTTP header config
│   ├── HTTPBodyConfig.java           # HTTP body validation config
│   └── CookieConfig.java              # Cookie validation config
│
├── security/
│   ├── SecurityEventCounter.java     # Thread-safe event counting
│   └── URLSecurityLogMessages.java   # LogRecord pattern messages
│
├── validation/
│   ├── LengthValidationStage.java    # Size limit validation (FIRST!)
│   ├── CharacterValidationStage.java # RFC character validation (SECOND!)
│   ├── DecodingStage.java            # Multi-layer decoding
│   ├── NormalizationStage.java       # Path normalization
│   └── PatternMatchingStage.java     # Attack pattern detection
│
└── pipeline/
    ├── UnifiedValidationPipeline.java # Single pipeline for all types
    └── ValidationFactory.java         # Factory for creating validators
----

== Core Components

=== Core Interfaces and Data Types

[source,java]
----
package de.cuioss.tools.security.http;

/**
 * Core interface for HTTP security validation.
 * Follows the String/throws pattern consistently.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B3]
 */
public interface HttpSecurityValidator {
    /**
     * Validates the input and returns the sanitized version.
     * @param value The input to validate
     * @return The validated/normalized value
     * @throws UrlSecurityException on any security violation
     */
    String execute(String value) throws UrlSecurityException;
    
    /**
     * @return The type of validation this validator performs
     */
    ValidationType getValidationType();
}

/**
 * Classification of input types for appropriate validation.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B3]
 */
public enum ValidationType {
    URL_PATH,        // URL path segments
    URL_PARAMETER,   // Query parameters
    HTTP_HEADER,     // HTTP headers
    HTTP_BODY,       // Request/response bodies
    COOKIE          // HTTP cookies
}

/**
 * Comprehensive enumeration of security failure types.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B1]
 */
public enum UrlSecurityFailureType {
    // Encoding Issues
    INVALID_ENCODING("Invalid URL encoding detected"),
    DOUBLE_ENCODING("Double URL encoding detected"),
    UNICODE_NORMALIZATION_CHANGED("Unicode normalization altered input"),
    
    // Path Traversal
    PATH_TRAVERSAL_DETECTED("Path traversal pattern detected"),
    DIRECTORY_ESCAPE_ATTEMPT("Directory escape attempt detected"),
    
    // Character Issues
    INVALID_CHARACTER("Invalid character detected"),
    NULL_BYTE_INJECTION("Null byte injection detected"),
    CONTROL_CHARACTERS("Control characters detected"),
    
    // Length/Size Issues
    PATH_TOO_LONG("Path exceeds maximum length"),
    EXCESSIVE_NESTING("Excessive directory nesting"),
    
    // Pattern Matches
    SUSPICIOUS_PATTERN("Suspicious pattern detected"),
    KNOWN_ATTACK_SIGNATURE("Known attack signature detected"),
    
    // Structural Issues
    MALFORMED_INPUT("Malformed input structure"),
    INVALID_STRUCTURE("Invalid input structure"),
    
    // Protocol Issues  
    PROTOCOL_VIOLATION("Protocol specification violation"),
    RFC_VIOLATION("RFC specification violation");
    
    private final String description;
    
    UrlSecurityFailureType(String description) {
        this.description = description;
    }
}

/**
 * Main exception for security violations.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B2]
 */
@Value
@Builder
public class UrlSecurityException extends RuntimeException {
    UrlSecurityFailureType failureType;
    ValidationType validationType;
    String originalInput;
    String sanitizedInput;
    String detail;
    
    public UrlSecurityException(UrlSecurityFailureType failureType, 
                               ValidationType validationType,
                               String originalInput, 
                               String sanitizedInput, 
                               String detail,
                               Throwable cause) {
        super(detail, cause);
        this.failureType = failureType;
        this.validationType = validationType;
        this.originalInput = originalInput;
        this.sanitizedInput = sanitizedInput;
        this.detail = detail;
    }
}
----

=== Data Records

[source,java]
----
package de.cuioss.tools.security.http;

/**
 * Data records used throughout the system.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B3]
 */
public record URLParameter(String key, String value) {}

public record Cookie(
    String name, 
    String value, 
    Map<String, String> attributes
) {}

public record HTTPBody(
    String contentType, 
    byte[] content
) {}
----

== Configuration Architecture

Configuration follows the embedded constants pattern from `ParserConfig`:

=== ConfigStageProvider Interface

[source,java]
----
package de.cuioss.tools.security.http.config;

/**
 * Provides factory methods for creating pre-configured validation stages.
 * This interface decouples pipelines from concrete configuration implementations.
 * All methods return HttpSecurityValidator for flexibility.
 */
public interface ConfigStageProvider {
    
    /**
     * @return The type of validation this configuration is for
     */
    ValidationType getValidationType();
    
    /**
     * @return Pre-configured length validation stage
     */
    HttpSecurityValidator getLengthValidationStage();
    
    /**
     * @return Pre-configured character validation stage appropriate for the ValidationType
     */
    HttpSecurityValidator getCharacterValidationStage();
    
    /**
     * @return Pre-configured decoding stage with security checks
     */
    HttpSecurityValidator getDecodingStage();
    
    /**
     * @return Pre-configured normalization stage
     */
    HttpSecurityValidator getNormalizationStage();
    
    /**
     * @return Pre-configured pattern matching stage
     */
    HttpSecurityValidator getPatternMatchingStage();
    
    /**
     * @return List of stages to use in the pipeline, in the correct order
     */
    List<HttpSecurityValidator> getStages();
}
----

=== Configuration Implementations

[source,java]
----
package de.cuioss.tools.security.http.config;

import lombok.Builder;
import lombok.Value;

/**
 * Base configuration with security defaults.
 * All defaults are based on OWASP guidelines and RFC specifications.
 * Implemented by: link:../../../plan.adoc#_phase_3_configuration_system[Tasks C1-C2]
 */
@Builder
@Value
public class UrlSecurityConfig {
    
    /**
     * Maximum URL path length in characters.
     * Default: 2048 based on RFC 3986 Section 3.3 and common browser limits.
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-3.3">RFC 3986</a>
     * @see <a href="https://owasp.org/www-community/vulnerabilities/Buffer_Overflow">OWASP Buffer Overflow</a>
     */
    public static final int DEFAULT_MAX_PATH_LENGTH = 2048;
    
    /**
     * Maximum directory traversal depth.
     * Default: 10 based on typical filesystem depth and OWASP recommendations.
     * @see <a href="https://owasp.org/www-community/attacks/Path_Traversal">OWASP Path Traversal</a>
     */
    public static final int DEFAULT_MAX_DIRECTORY_DEPTH = 10;
    
    /**
     * Maximum parameter value length.
     * Default: 4096 based on common server configurations.
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.1">RFC 7230</a>
     */
    public static final int DEFAULT_MAX_PARAMETER_LENGTH = 4096;
    
    /**
     * Maximum number of parameters.
     * Default: 100 to prevent parameter pollution attacks.
     * @see <a href="https://owasp.org/www-community/attacks/HTTP_Parameter_Pollution">OWASP HPP</a>
     */
    public static final int DEFAULT_MAX_PARAMETER_COUNT = 100;
    
    /**
     * Enable Unicode normalization (NFC).
     * Default: true per OWASP guidelines for Unicode security.
     * @see <a href="https://owasp.org/www-community/attacks/Unicode_Encoding">OWASP Unicode</a>
     */
    public static final boolean DEFAULT_UNICODE_NORMALIZATION = true;
    
    /**
     * Reject null bytes in input.
     * Default: true to prevent null byte injection attacks.
     * @see <a href="https://owasp.org/www-community/attacks/Null_Byte_Injection">OWASP Null Byte</a>
     */
    public static final boolean DEFAULT_REJECT_NULL_BYTES = true;
    
    @Builder.Default
    int maxPathLength = DEFAULT_MAX_PATH_LENGTH;
    
    @Builder.Default
    int maxDirectoryDepth = DEFAULT_MAX_DIRECTORY_DEPTH;
    
    @Builder.Default
    int maxParameterLength = DEFAULT_MAX_PARAMETER_LENGTH;
    
    @Builder.Default
    int maxParameterCount = DEFAULT_MAX_PARAMETER_COUNT;
    
    @Builder.Default
    boolean unicodeNormalization = DEFAULT_UNICODE_NORMALIZATION;
    
    @Builder.Default
    boolean rejectNullBytes = DEFAULT_REJECT_NULL_BYTES;
}

/**
 * Configuration for URL path validation.
 * Implements ConfigStageProvider with URL_PATH specific stages.
 */
@Value
public class URLPathConfig implements ConfigStageProvider {
    
    UrlSecurityConfig baseConfig;
    ValidationType validationType = ValidationType.URL_PATH;
    
    // Cached stage instances - created once, reused everywhere
    @Getter(lazy = true)
    LengthValidationStage lengthValidationStage = 
        new LengthValidationStage(baseConfig, ValidationType.URL_PATH);
    
    @Getter(lazy = true)
    CharacterValidationStage characterValidationStage = 
        new CharacterValidationStage(baseConfig, ValidationType.URL_PATH);
    
    @Getter(lazy = true)
    DecodingStage decodingStage = 
        new DecodingStage(baseConfig, ValidationType.URL_PATH);
    
    @Getter(lazy = true)
    NormalizationStage normalizationStage = 
        new NormalizationStage(baseConfig, ValidationType.URL_PATH);
    
    @Getter(lazy = true)
    PatternMatchingStage patternMatchingStage = 
        new PatternMatchingStage(baseConfig, ValidationType.URL_PATH);
    
    public URLPathConfig(UrlSecurityConfig baseConfig) {
        this.baseConfig = baseConfig;
    }
    
    @Override
    public ValidationType getValidationType() {
        return validationType;
    }
    
    @Override
    public List<HttpSecurityValidator> getStages() {
        return List.of(
            getLengthValidationStage(),
            getCharacterValidationStage(),
            getDecodingStage(),
            getNormalizationStage(),
            getPatternMatchingStage()
        );
    }
}

/**
 * Configuration for URL parameter validation.
 * Implements ConfigStageProvider with URL_PARAMETER specific stages.
 */
@Value
public class URLParameterConfig implements ConfigStageProvider {
    
    UrlSecurityConfig baseConfig;
    ValidationType validationType = ValidationType.URL_PARAMETER;
    
    @Getter(lazy = true)
    LengthValidationStage lengthValidationStage = 
        new LengthValidationStage(baseConfig, ValidationType.URL_PARAMETER);
    
    @Getter(lazy = true)
    CharacterValidationStage characterValidationStage = 
        new CharacterValidationStage(baseConfig, ValidationType.URL_PARAMETER);
    
    @Getter(lazy = true)
    DecodingStage decodingStage = 
        new DecodingStage(baseConfig, ValidationType.URL_PARAMETER);
    
    @Getter(lazy = true)
    PatternMatchingStage patternMatchingStage = 
        new PatternMatchingStage(baseConfig, ValidationType.URL_PARAMETER);
    
    public URLParameterConfig(UrlSecurityConfig baseConfig) {
        this.baseConfig = baseConfig;
    }
    
    @Override
    public ValidationType getValidationType() {
        return validationType;
    }
    
    @Override
    public HttpSecurityValidator getNormalizationStage() {
        return IdentityValidator.URL_PARAMETER; // Not used for parameters
    }
    
    @Override
    public List<HttpSecurityValidator> getStages() {
        return List.of(
            getLengthValidationStage(),
            getCharacterValidationStage(),
            getDecodingStage(),
            getPatternMatchingStage()
        );
    }
}

/**
 * Configuration for HTTP header validation.
 * Implements ConfigStageProvider with HTTP_HEADER specific stages.
 */
@Value
public class HTTPHeaderConfig implements ConfigStageProvider {
    
    UrlSecurityConfig baseConfig;
    ValidationType validationType = ValidationType.HTTP_HEADER;
    
    @Getter(lazy = true)
    LengthValidationStage lengthValidationStage = 
        new LengthValidationStage(baseConfig, ValidationType.HTTP_HEADER);
    
    @Getter(lazy = true)
    CharacterValidationStage characterValidationStage = 
        new CharacterValidationStage(baseConfig, ValidationType.HTTP_HEADER);
    
    @Getter(lazy = true)
    PatternMatchingStage patternMatchingStage = 
        new PatternMatchingStage(baseConfig, ValidationType.HTTP_HEADER);
    
    public HTTPHeaderConfig(UrlSecurityConfig baseConfig) {
        this.baseConfig = baseConfig;
    }
    
    @Override
    public ValidationType getValidationType() {
        return validationType;
    }
    
    @Override
    public HttpSecurityValidator getDecodingStage() {
        return IdentityValidator.HTTP_HEADER; // Not used for headers
    }
    
    @Override
    public HttpSecurityValidator getNormalizationStage() {
        return IdentityValidator.HTTP_HEADER; // Not used for headers
    }
    
    @Override
    public List<HttpSecurityValidator> getStages() {
        return List.of(
            getLengthValidationStage(),
            getCharacterValidationStage(),
            getPatternMatchingStage()
        );
    }
}
----

== Validation Stages

All validation stages follow these principles:

1. **Immutability**: Configuration stored in final fields, no runtime state changes
2. **Performance**: Pre-compiled patterns, optimized algorithms, <1ms per stage
3. **Thread Safety**: No mutable state, safe for concurrent use
4. **Clear Contracts**: String input/output with UrlSecurityException on violations

=== IdentityValidator

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.Getter;
import lombok.EqualsAndHashCode;
import lombok.ToString;

/**
 * Identity validator that performs no validation - just returns the input unchanged.
 * Used as a placeholder for stages that are not applicable to certain validation types.
 * Thread-safe and immutable.
 */
@EqualsAndHashCode
@ToString
public final class IdentityValidator implements HttpSecurityValidator {
    
    @Getter
    private final ValidationType validationType;
    
    /**
     * Singleton instances for each validation type to avoid unnecessary object creation.
     */
    public static final IdentityValidator URL_PATH = new IdentityValidator(ValidationType.URL_PATH);
    public static final IdentityValidator URL_PARAMETER = new IdentityValidator(ValidationType.URL_PARAMETER);
    public static final IdentityValidator HTTP_HEADER = new IdentityValidator(ValidationType.HTTP_HEADER);
    public static final IdentityValidator HTTP_BODY = new IdentityValidator(ValidationType.HTTP_BODY);
    public static final IdentityValidator COOKIE = new IdentityValidator(ValidationType.COOKIE);
    
    private IdentityValidator(ValidationType validationType) {
        this.validationType = validationType;
    }
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        // Identity function - return input unchanged
        return value;
    }
}
----

=== LengthValidationStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.EqualsAndHashCode;
import lombok.ToString;

/**
 * Length validation MUST be the first stage to prevent DoS attacks.
 * Rejects oversized inputs before any processing.
 * Immutable and thread-safe.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V4]
 */
@EqualsAndHashCode
@ToString
public final class LengthValidationStage implements HttpSecurityValidator {
    
    private final int maxLength;
    private final int maxDepth;
    @Getter
    private final ValidationType validationType;
    
    public LengthValidationStage(UrlSecurityConfig config, ValidationType validationType) {
        this.maxLength = config.getMaxPathLength();
        this.maxDepth = config.getMaxDirectoryDepth();
        this.validationType = validationType;
    }
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        // First check: total length
        if (value.length() > maxLength) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.PATH_TOO_LONG)
                .validationType(validationType)
                .originalInput(value)
                .build();
        }
        
        // Second check: nesting depth
        long depth = value.chars().filter(ch -> ch == '/' || ch == '\\').count();
        if (depth > maxDepth) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.EXCESSIVE_NESTING)
                .validationType(validationType)
                .originalInput(value)
                .build();
        }
        
        return value;
    }
}
----

=== DecodingStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.Value;
import java.text.Normalizer;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.regex.Pattern;

/**
 * Multi-layer decoding with security checks.
 * Immutable and thread-safe.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V1]
 */
@Value
public class DecodingStage implements HttpSecurityValidator {
    
    // Static pattern shared across all instances
    private static final Pattern DOUBLE_ENCODING_PATTERN = Pattern.compile("%25[0-9a-fA-F]{2}");
    
    UrlSecurityConfig config;
    ValidationType validationType;
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        // Detect double encoding before decoding
        if (DOUBLE_ENCODING_PATTERN.matcher(value).find()) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.DOUBLE_ENCODING)
                .validationType(validationType)
                .originalInput(value)
                .build();
        }
        
        // URL decode
        String decoded;
        try {
            decoded = URLDecoder.decode(value, StandardCharsets.UTF_8);
        } catch (IllegalArgumentException e) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.INVALID_ENCODING)
                .validationType(validationType)
                .originalInput(value)
                .cause(e)
                .build();
        }
        
        // Unicode normalization with change detection
        if (config.isUnicodeNormalization()) {
            String normalized = Normalizer.normalize(decoded, Normalizer.Form.NFC);
            if (!decoded.equals(normalized)) {
                // Normalization changed the string - potential attack
                throw UrlSecurityException.builder()
                    .failureType(UrlSecurityFailureType.UNICODE_NORMALIZATION_CHANGED)
                    .validationType(validationType)
                    .originalInput(value)
                    .sanitizedInput(normalized)
                    .build();
            }
            decoded = normalized;
        }
        
        // Note: Null byte detection moved to CharacterValidationStage for earlier detection
        
        return decoded;
    }
}
----

=== CharacterValidationStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.EqualsAndHashCode;
import lombok.ToString;
import java.util.BitSet;

/**
 * Validates characters according to RFC 3986 for URLs.
 * MUST be the second stage after length validation.
 * Rejects invalid characters BEFORE any decoding/processing.
 * Immutable and thread-safe.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V5]
 */
@EqualsAndHashCode
@ToString
public final class CharacterValidationStage implements HttpSecurityValidator {
    
    // RFC 3986 unreserved characters: ALPHA / DIGIT / "-" / "." / "_" / "~"
    // RFC 3986 reserved characters: gen-delims / sub-delims
    // gen-delims: ":" / "/" / "?" / "#" / "[" / "]" / "@"
    // sub-delims: "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
    // pct-encoded: "%" HEXDIG HEXDIG
    
    private final BitSet allowedChars;
    @Getter
    private final ValidationType validationType;
    private final boolean allowPercentEncoding;
    
    public CharacterValidationStage(UrlSecurityConfig config, ValidationType type) {
        this.validationType = type;
        this.allowedChars = new BitSet(256);
        
        // Initialize allowed characters based on type
        switch (type) {
            case URL_PATH -> {
                // RFC 3986 path characters
                addUnreservedChars();  // A-Z, a-z, 0-9, -, ., _, ~
                addPathChars();        // /, @, :, !, $, &, ', (, ), *, +, ,, ;, =
                this.allowPercentEncoding = true;
            }
            case URL_PARAMETER -> {
                // Query string characters
                addUnreservedChars();
                addQueryChars();       // All sub-delims plus ? and &
                this.allowPercentEncoding = true;
            }
            case HTTP_HEADER -> {
                // RFC 7230 header field characters
                addVisibleASCII();     // ASCII 33-126 except delimiters
                this.allowPercentEncoding = false;
            }
            default -> {
                // Most restrictive set
                addUnreservedChars();
                this.allowPercentEncoding = false;
            }
        }
    }
    
    private void addUnreservedChars() {
        // ALPHA
        for (int i = 'A'; i <= 'Z'; i++) allowedChars.set(i);
        for (int i = 'a'; i <= 'z'; i++) allowedChars.set(i);
        // DIGIT
        for (int i = '0'; i <= '9'; i++) allowedChars.set(i);
        // "-" / "." / "_" / "~"
        allowedChars.set('-');
        allowedChars.set('.');
        allowedChars.set('_');
        allowedChars.set('~');
    }
    
    private void addPathChars() {
        // Path-specific characters
        allowedChars.set('/');
        allowedChars.set('@');
        allowedChars.set(':');
        // sub-delims for path
        "!$&'()*+,;=".chars().forEach(allowedChars::set);
    }
    
    private void addQueryChars() {
        // Query-specific characters
        allowedChars.set('?');
        allowedChars.set('&');
        allowedChars.set('=');
        // sub-delims for query
        "!$'()*+,;".chars().forEach(allowedChars::set);
    }
    
    private void addVisibleASCII() {
        // RFC 7230: VCHAR = %x21-7E (visible ASCII)
        for (int i = 33; i <= 126; i++) {
            // Exclude HTTP delimiters
            if (!"\"(),/:;<=>?@[\\]{}".contains(String.valueOf((char)i))) {
                allowedChars.set(i);
            }
        }
        allowedChars.set(' '); // Space is allowed in headers
    }
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        // Quick check for null/empty
        if (value == null || value.isEmpty()) {
            return value;
        }
        
        // Check each character
        for (int i = 0; i < value.length(); i++) {
            char ch = value.charAt(i);
            
            // Check for null byte FIRST (highest priority security check)
            if (ch == '\0') {
                throw UrlSecurityException.builder()
                    .failureType(UrlSecurityFailureType.NULL_BYTE_INJECTION)
                    .validationType(validationType)
                    .originalInput(value)
                    .detail("Null byte detected at position " + i)
                    .build();
            }
            
            // Handle percent encoding
            if (ch == '%' && allowPercentEncoding) {
                // Must be followed by two hex digits
                if (i + 2 >= value.length()) {
                    throw UrlSecurityException.builder()
                        .failureType(UrlSecurityFailureType.INVALID_ENCODING)
                        .validationType(validationType)
                        .originalInput(value)
                        .detail("Incomplete percent encoding at position " + i)
                        .build();
                }
                
                char hex1 = value.charAt(i + 1);
                char hex2 = value.charAt(i + 2);
                if (!isHexDigit(hex1) || !isHexDigit(hex2)) {
                    throw UrlSecurityException.builder()
                        .failureType(UrlSecurityFailureType.INVALID_ENCODING)
                        .originalInput(value)
                        .detail("Invalid hex digits in percent encoding at position " + i)
                        .build();
                }
                
                // Check for encoded null byte %00
                if (hex1 == '0' && hex2 == '0') {
                    throw UrlSecurityException.builder()
                        .failureType(UrlSecurityFailureType.NULL_BYTE_INJECTION)
                        .validationType(validationType)
                        .originalInput(value)
                        .detail("Encoded null byte (%00) detected at position " + i)
                        .build();
                }
                
                i += 2; // Skip the two hex digits
                continue;
            }
            
            // Check if character is allowed
            if (ch > 255 || !allowedChars.get(ch)) {
                throw UrlSecurityException.builder()
                    .failureType(UrlSecurityFailureType.INVALID_CHARACTER)
                    .validationType(validationType)
                    .originalInput(value)
                    .detail(String.format("Invalid character '%c' (0x%02X) at position %d", 
                                        ch, (int)ch, i))
                    .build();
            }
        }
        
        return value;
    }
    
    private boolean isHexDigit(char ch) {
        return (ch >= '0' && ch <= '9') || 
               (ch >= 'A' && ch <= 'F') || 
               (ch >= 'a' && ch <= 'f');
    }
}
----

=== NormalizationStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.Value;
import java.nio.file.Paths;

/**
 * Path normalization stage to resolve . and .. segments.
 * Follows RFC 3986 Section 5.2.4 for path normalization.
 * Immutable and thread-safe.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V2]
 */
@Value
public class NormalizationStage implements HttpSecurityValidator {
    
    UrlSecurityConfig config;
    ValidationType validationType;
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        if (value == null || value.isEmpty()) {
            return value;
        }
        
        // Save original for comparison
        String original = value;
        
        // Normalize path segments (resolve . and ..)
        String normalized = normalizePath(value);
        
        // Check if normalization revealed path traversal
        if (containsPathTraversal(normalized)) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED)
                .validationType(validationType)
                .originalInput(original)
                .sanitizedInput(normalized)
                .detail("Path normalization revealed traversal attempt")
                .build();
        }
        
        // Check if path escapes root after normalization
        if (escapesRoot(normalized)) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.DIRECTORY_ESCAPE_ATTEMPT)
                .validationType(validationType)
                .originalInput(original)
                .sanitizedInput(normalized)
                .detail("Path attempts to escape root directory")
                .build();
        }
        
        return normalized;
    }
    
    private String normalizePath(String path) {
        // RFC 3986 path segment normalization
        String[] segments = path.split("/", -1);
        StringBuilder result = new StringBuilder();
        int depth = 0;
        
        for (String segment : segments) {
            if (".".equals(segment)) {
                // Current directory - skip
                continue;
            } else if ("..".equals(segment)) {
                // Parent directory
                if (result.length() > 0) {
                    // Remove last segment
                    int lastSlash = result.lastIndexOf("/");
                    if (lastSlash >= 0) {
                        result.setLength(lastSlash);
                        depth--;
                    }
                } else {
                    // Trying to go above root
                    depth--;
                }
            } else if (!segment.isEmpty()) {
                // Normal segment
                if (result.length() > 0 || path.startsWith("/")) {
                    result.append("/");
                }
                result.append(segment);
                depth++;
            }
        }
        
        // Check depth limit
        if (depth > config.getMaxDirectoryDepth()) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.EXCESSIVE_NESTING)
                .validationType(validationType)
                .originalInput(path)
                .detail("Path depth " + depth + " exceeds maximum " + config.getMaxDirectoryDepth())
                .build();
        }
        
        // Preserve trailing slash if present
        if (path.endsWith("/") && !result.toString().endsWith("/")) {
            result.append("/");
        }
        
        return result.toString();
    }
    
    private boolean containsPathTraversal(String path) {
        // After normalization, there should be no .. segments
        return path.contains("../") || path.contains("..\\") || path.equals("..");
    }
    
    private boolean escapesRoot(String path) {
        // Check if normalized path tries to escape root
        return path.startsWith("../") || path.startsWith("..\\");
    }
}
----

=== PatternMatchingStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.Value;
import java.util.regex.Pattern;

/**
 * Pattern-based attack detection using pre-compiled patterns.
 * Immutable and optimized for performance.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V3]
 */
@Value
public class PatternMatchingStage implements HttpSecurityValidator {
    
    // Static patterns shared across all instances
    private static final Pattern PATH_TRAVERSAL_PATTERN = Pattern.compile(
        "(?:^|/)\\.\\.(?:/|$)"
    );
    private static final Pattern ENCODED_TRAVERSAL_PATTERN = Pattern.compile(
        "%(?:2e|2E)%(?:2e|2E)"
    );
    
    UrlSecurityConfig config; // Keep for consistency even if not used
    ValidationType validationType;
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        // Check all patterns efficiently
        if (PATH_TRAVERSAL_PATTERN.matcher(value).find() ||
            ENCODED_TRAVERSAL_PATTERN.matcher(value).find()) {
            
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED)
                .validationType(validationType)
                .originalInput(value)
                .build();
        }
        
        return value;
    }
}
----

== Pipeline Architecture

=== Unified Validation Pipeline

A single pipeline implementation handles all validation types through configuration:

[source,java]
----
package de.cuioss.tools.security.http.pipeline;

import lombok.EqualsAndHashCode;
import lombok.ToString;
import java.util.List;
import java.util.Objects;

/**
 * Unified validation pipeline that works with any ConfigStageProvider.
 * The validation type and stage selection is determined by the configuration.
 * Implemented by: link:../../../plan.adoc#_phase_6_pipeline_implementation[Tasks P1-P5]
 */
@EqualsAndHashCode
@ToString
public final class UnifiedValidationPipeline implements HttpSecurityValidator {
    
    private final ConfigStageProvider config;
    private final List<HttpSecurityValidator> stages;
    private final SecurityEventCounter eventCounter;
    @Getter
    private final ValidationType validationType;
    
    public UnifiedValidationPipeline(ConfigStageProvider config, 
                                    SecurityEventCounter eventCounter) {
        this.config = Objects.requireNonNull(config, "Config must not be null");
        this.eventCounter = Objects.requireNonNull(eventCounter, "EventCounter must not be null");
        this.validationType = config.getValidationType();
        
        // Get stages from config - it knows which stages to use
        this.stages = config.getStages();
        
        if (stages.isEmpty()) {
            throw new IllegalArgumentException("Configuration must provide at least one stage");
        }
    }
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        String result = value;
        
        // Sequential execution with early termination
        for (HttpSecurityValidator stage : stages) {
            // Skip null stages and identity validators
            if (stage != null && !(stage instanceof IdentityValidator)) {
                try {
                    result = stage.execute(result);
                } catch (UrlSecurityException e) {
                    // Add validation type to exception if not already set
                    if (e.getValidationType() == null) {
                        throw UrlSecurityException.builder()
                            .failureType(e.getFailureType())
                            .validationType(this.validationType)
                            .originalInput(e.getOriginalInput())
                            .sanitizedInput(e.getSanitizedInput())
                            .detail(e.getMessage())
                            .cause(e.getCause())
                            .build();
                    }
                    
                    // Track security event
                    eventCounter.increment(e.getFailureType());
                    
                    // Log via URLSecurityLogMessages
                    logSecurityEvent(e);
                    
                    // Re-throw
                    throw e;
                }
            }
        }
        
        return result;
    }
    
    private void logSecurityEvent(UrlSecurityException e) {
        // Log security events based on failure type
        CuiLogger logger = new CuiLogger(UnifiedValidationPipeline.class);
        
        switch (e.getFailureType()) {
            case PATH_TRAVERSAL_DETECTED ->
                logger.warn(URLSecurityLogMessages.WARN.PATH_TRAVERSAL_DETECTED, 
                    e.getOriginalInput());
            case DOUBLE_ENCODING ->
                logger.warn(URLSecurityLogMessages.WARN.DOUBLE_ENCODING_DETECTED, 
                    e.getOriginalInput());
            case UNICODE_NORMALIZATION_CHANGED ->
                logger.warn(URLSecurityLogMessages.WARN.UNICODE_ATTACK_DETECTED);
            default ->
                logger.error(URLSecurityLogMessages.ERROR.VALIDATION_FAILED, 
                    e.getFailureType(), e.getMessage());
        }
    }
}
----

== Security Event Tracking

=== Event Counter Pattern

[source,java]
----
package de.cuioss.tools.security.http.security;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Thread-safe security event counter.
 * Tracks occurrences of each UrlSecurityFailureType.
 * Implemented by: link:../../../plan.adoc#_phase_4_security_tracking_and_monitoring[Task S1]
 */
public class SecurityEventCounter {
    
    private final ConcurrentHashMap<UrlSecurityFailureType, AtomicLong> counters = 
        new ConcurrentHashMap<>();
    
    /**
     * Increment counter for a failure type.
     * @return new count value
     */
    public long increment(UrlSecurityFailureType type) {
        return counters.computeIfAbsent(type, k -> new AtomicLong(0))
                      .incrementAndGet();
    }
    
    /**
     * Get current count for a failure type.
     */
    public long getCount(UrlSecurityFailureType type) {
        AtomicLong counter = counters.get(type);
        return counter != null ? counter.get() : 0;
    }
}
----

=== Structured Logging

[source,java]
----
package de.cuioss.tools.security.http.security;

import de.cuioss.tools.logging.LogRecord;
import de.cuioss.tools.logging.LogRecordModel;

/**
 * Structured log messages for URL security events.
 * Follows cui-jwt-validation LogRecord pattern.
 * Implemented by: link:../../../plan.adoc#_phase_4_security_tracking_and_monitoring[Task S2]
 */
public final class URLSecurityLogMessages {
    
    private static final String PREFIX = "URLSecurity";
    
    public static final class WARN {
        
        public static final LogRecord PATH_TRAVERSAL_DETECTED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(301)
                .template("Path traversal attempt detected: %s")
                .build();
        
        public static final LogRecord DOUBLE_ENCODING_DETECTED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(302)
                .template("Double encoding attack detected: %s")
                .build();
        
        public static final LogRecord UNICODE_ATTACK_DETECTED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(303)
                .template("Unicode normalization attack detected")
                .build();
    }
    
    public static final class ERROR {
        
        public static final LogRecord VALIDATION_FAILED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(401)
                .template("URL validation failed: %s - %s")
                .build();
    }
}
----

== Performance Optimization

=== Optimization Strategies

1. **Pre-compilation**: All patterns compiled during construction
2. **Immutable Caching**: Configuration and patterns stored in final fields
3. **Early Termination**: Stop processing on first security violation
4. **Efficient Algorithms**: Use StringBuilder, BitSet for character validation
5. **Memory Management**: Minimize string allocations

=== Performance Requirements

- Individual stage: <0.2ms per stage
- Complete pipeline: <1ms total for typical inputs (5 stages × 0.2ms)
- Memory: O(n) where n is input length
- Thread safety: No synchronization needed (immutable)
- Benchmark: 95th percentile must meet these requirements

== Usage Example

[source,java]
----
// Create base configuration with secure defaults
UrlSecurityConfig baseConfig = UrlSecurityConfig.builder()
    .maxPathLength(2048)  // Uses DEFAULT_MAX_PATH_LENGTH
    .build();

// Create specific configurations for different validation types
ConfigStageProvider pathConfig = new URLPathConfig(baseConfig);
ConfigStageProvider paramConfig = new URLParameterConfig(baseConfig);
ConfigStageProvider headerConfig = new HTTPHeaderConfig(baseConfig);

// Create unified pipelines with different configurations
SecurityEventCounter eventCounter = new SecurityEventCounter();

HttpSecurityValidator pathValidator = new UnifiedValidationPipeline(
    pathConfig,    // URL_PATH configuration
    eventCounter
);

HttpSecurityValidator paramValidator = new UnifiedValidationPipeline(
    paramConfig,   // URL_PARAMETER configuration  
    eventCounter
);

HttpSecurityValidator headerValidator = new UnifiedValidationPipeline(
    headerConfig,  // HTTP_HEADER configuration
    eventCounter
);

// Use validators - they all share the same pipeline implementation
try {
    String safePath = pathValidator.execute("/api/users/123");
    String safeParam = paramValidator.execute("search=test%20query");
    String safeHeader = headerValidator.execute("Bearer abc123");
} catch (UrlSecurityException e) {
    // Exception now includes ValidationType
    log.warn("Security violation in {}: {} - {}", 
        e.getValidationType(), 
        e.getFailureType(), 
        e.getOriginalInput());
}

// Alternative: Factory pattern for cleaner creation
public class ValidationFactory {
    
    private final UrlSecurityConfig baseConfig;
    private final SecurityEventCounter eventCounter;
    
    public HttpSecurityValidator createValidator(ValidationType type) {
        ConfigStageProvider config = switch (type) {
            case URL_PATH -> new URLPathConfig(baseConfig);
            case URL_PARAMETER -> new URLParameterConfig(baseConfig);
            case HTTP_HEADER -> new HTTPHeaderConfig(baseConfig);
            case HTTP_BODY -> new HTTPBodyConfig(baseConfig);
            case COOKIE -> new CookieConfig(baseConfig);
        };
        
        return new UnifiedValidationPipeline(config, eventCounter);
    }
}
----

== Security Considerations

=== Attack Coverage

- Path traversal: ../, ..\, encoded variants
- Encoding attacks: Double/triple encoding, mixed encoding
- Unicode attacks: Normalization, homographs, control characters
- Injection: XSS, SQL, LDAP, command injection patterns
- Protocol attacks: Header injection, request smuggling
- DoS: Size limits, algorithmic complexity

=== Default Security Posture

- All defaults follow maximum security (OWASP/RFC)
- No lenient modes - security by default
- Explicit overrides required for less restrictive settings
- Comprehensive logging and monitoring