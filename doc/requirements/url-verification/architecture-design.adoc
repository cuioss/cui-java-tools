= Path Traversal Security Architecture and Design Document
:toc: left
:toclevels: 3
:sectnums:
:icons: font

link:README.adoc[← Back to Documentation Index]

== Executive Summary

This document presents a comprehensive architecture and design for HTTP URL path traversal security validation leveraging Java 21+ built-in types. The design focuses exclusively on HTTP/URL contexts, utilizing Java's native URL, URI, URLDecoder, and Pattern classes to minimize custom code while maintaining robust security.

== Design Goals and Principles

=== Primary Goals

. **HTTP/URL Focus**: Specialized validation for HTTP request paths and parameters
. **Java Built-in Types**: Leverage Java 21+ native URL/URI validation capabilities
. **Zero False Negatives**: Block all known HTTP path traversal patterns
. **RFC Compliance**: Full RFC 3986 and RFC 7230 compliance using Java's URI class
. **Performance**: Sub-millisecond validation using native Java types
. **Simplicity**: Minimal custom code by leveraging Java standard library
. **Security by Default**: Combine Java's syntactic validation with semantic security

=== Design Principles

[cols="2,3"]
|===
|Principle |Implementation

|Defense in Depth
|Multiple validation layers, each catching different attack classes

|Fail Secure
|Reject ambiguous or unparseable input rather than attempting correction

|Least Privilege
|Minimal permissions required for validation operations

|Separation of Concerns
|Distinct components for different validation aspects

|Zero Trust
|Assume all input is malicious until proven otherwise

|Transparency
|Clear logging and audit trail for security decisions

|===

== System Architecture

=== High-Level Architecture Using Java 21+ Built-in Types

----
┌─────────────────────────────────────────────────────────┐
│                 HTTP URL Validator                       │
│         (Leveraging Java 21 Built-in Types)             │
└─────────────┬───────────────────────────────────────────┘
              │
┌─────────────▼───────────────────────────────────────────┐
│              Validation Pipeline                         │
│     Using Java Standard Library Components               │
├──────────────┬────────────┬────────────┬───────────────┤
│ URLDecoder   │    URI     │  Pattern   │   Custom      │
│ (Built-in)   │ (Built-in) │ (Built-in) │  Security     │
└──────────────┴────────────┴────────────┴───────────────┘
----

=== Component Architecture

==== Core Components

[source,java]
----
package de.cuioss.tools.security.http;

import java.net.URI;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

/**
 * Enumeration of URL security validation failure types
 */
public enum UrlSecurityFailureType {
    INVALID_ENCODING("Invalid URL encoding detected"),
    DOUBLE_ENCODING("Double URL encoding detected"),
    PATH_TRAVERSAL("Path traversal pattern detected"),
    MALFORMED_URI("Malformed URI syntax"),
    CONTROL_CHARACTERS("Control characters detected"),
    NULL_BYTE_INJECTION("Null byte injection detected");
    
    private final String description;
    
    UrlSecurityFailureType(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}

/**
 * Runtime exception for URL security violations
 */
public class UrlSecurityException extends RuntimeException {
    private final UrlSecurityFailureType failureType;
    private final String originalValue;
    private final String decodedValue;
    
    public UrlSecurityException(UrlSecurityFailureType failureType, String originalValue, String decodedValue) {
        super(failureType.getDescription() + ": " + originalValue);
        this.failureType = failureType;
        this.originalValue = originalValue;
        this.decodedValue = decodedValue;
    }
    
    public UrlSecurityException(UrlSecurityFailureType failureType, String originalValue, String decodedValue, Throwable cause) {
        super(failureType.getDescription() + ": " + originalValue, cause);
        this.failureType = failureType;
        this.originalValue = originalValue;
        this.decodedValue = decodedValue;
    }
    
    public UrlSecurityFailureType getFailureType() {
        return failureType;
    }
    
    public String getOriginalValue() {
        return originalValue;
    }
    
    public String getDecodedValue() {
        return decodedValue;
    }
}

/**
 * Utility class for secure URL decoding operations
 */
public final class UrlDecodingTools {
    
    private UrlDecodingTools() {
        // Utility class
    }
    
    /**
     * Safely decodes a URL-encoded string with security validation
     * 
     * @param encodedValue the URL-encoded string to decode
     * @return the decoded string
     * @throws UrlSecurityException if security violations are detected
     */
    public static String getDecodedValue(String encodedValue) {
        if (encodedValue == null) {
            return null;
        }
        
        String decoded;
        try {
            // First decode
            decoded = URLDecoder.decode(encodedValue, StandardCharsets.UTF_8);
            
            // Check for double encoding by attempting second decode
            String doubleDecoded = URLDecoder.decode(decoded, StandardCharsets.UTF_8);
            if (!decoded.equals(doubleDecoded)) {
                throw new UrlSecurityException(
                    UrlSecurityFailureType.DOUBLE_ENCODING,
                    encodedValue,
                    decoded
                );
            }
            
            // Check for null bytes
            if (decoded.contains("\0")) {
                throw new UrlSecurityException(
                    UrlSecurityFailureType.NULL_BYTE_INJECTION,
                    encodedValue,
                    decoded
                );
            }
            
            // Check for control characters
            if (decoded.matches(".*[\\x00-\\x1f].*")) {
                throw new UrlSecurityException(
                    UrlSecurityFailureType.CONTROL_CHARACTERS,
                    encodedValue,
                    decoded
                );
            }
            
        } catch (IllegalArgumentException e) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.INVALID_ENCODING,
                encodedValue,
                null,
                e
            );
        }
        
        return decoded;
    }
}

/**
 * HTTP URL path validator using Java 21 built-in types
 */
public final class HttpUrlValidator {
    
    /**
     * Validates an HTTP URL path using Java's built-in validation
     * 
     * @param urlPath the URL path to validate
     * @return the validated and normalized path
     * @throws UrlSecurityException if validation fails
     */
    public String validateUrlPath(String urlPath) {
        // Step 1: Decode using secure utility
        String decoded = UrlDecodingTools.getDecodedValue(urlPath);
        
        // Step 2: Use Java's URI for RFC 3986 validation and normalization
        try {
            // Create URI with just the path component for validation
            URI uri = new URI(null, null, null, -1, decoded, null, null);
            String normalized = uri.normalize().getPath();
            
            // Step 3: Check if normalization revealed traversal
            if (normalized != null && !normalized.equals(decoded)) {
                if (normalized.contains("..")) {
                    throw new UrlSecurityException(
                        UrlSecurityFailureType.PATH_TRAVERSAL,
                        urlPath,
                        decoded
                    );
                }
            }
            
            // Step 4: Check for direct path traversal patterns
            if (decoded.contains("..")) {
                throw new UrlSecurityException(
                    UrlSecurityFailureType.PATH_TRAVERSAL,
                    urlPath,
                    decoded
                );
            }
            if (decoded.contains("./")) {
                throw new UrlSecurityException(
                    UrlSecurityFailureType.PATH_TRAVERSAL,
                    urlPath,
                    decoded
                );
            }
            if (decoded.contains("//")) {
                throw new UrlSecurityException(
                    UrlSecurityFailureType.PATH_TRAVERSAL,
                    urlPath,
                    decoded
                );
            }
            
            return normalized != null ? normalized : decoded;
            
        } catch (URISyntaxException e) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.MALFORMED_URI,
                urlPath,
                decoded,
                e
            );
        }
    }
}
----

=== Validation Pipeline Using Java 21 Built-in Types

==== Pipeline Design with Native Java Components

[source,java]
----
import java.net.URI;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.regex.Pattern;

/**
 * HTTP validation pipeline leveraging Java 21 features
 */
public class HttpValidationPipeline {
    
    // Java 21 Pattern for attack detection
    private static final Pattern TRAVERSAL_PATTERN = Pattern.compile(
        "(\\.\\./)|(%2e%2e%2f)|(%252e%252e%252f)|(\\.\\.\\\\)|" +
        "(%5c%2e%2e%5c)|(%255c%252e%252e%255c)",
        Pattern.CASE_INSENSITIVE
    );
    
    /**
     * Validates a URL path through the complete pipeline
     * 
     * @param urlPath the URL path to validate
     * @return the validated and normalized path
     * @throws UrlSecurityException if validation fails at any stage
     */
    public String validate(String urlPath) {
        // Stage 1: URL Decoding with Java's URLDecoder
        String decoded = UrlDecodingTools.getDecodedValue(urlPath);
        
        // Stage 2: URI Normalization with Java's URI class
        String normalized = normalizeUri(decoded, urlPath);
        
        // Stage 3: Pattern-based validation using Java regex
        validatePatterns(normalized, urlPath);
        
        // Stage 4: Semantic validation
        validateSemantics(normalized, urlPath);
        
        return normalized;
    }
    
    private String normalizeUri(String path, String originalPath) {
        try {
            // Create URI with path component only
            URI uri = new URI(null, null, null, -1, path, null, null);
            String normalized = uri.normalize().getPath();
            
            if (normalized == null) {
                throw new UrlSecurityException(
                    UrlSecurityFailureType.MALFORMED_URI,
                    originalPath,
                    path
                );
            }
            
            // Check if normalization changed the path (potential traversal)
            if (!normalized.equals(path) && normalized.contains("..")) {
                throw new UrlSecurityException(
                    UrlSecurityFailureType.PATH_TRAVERSAL,
                    originalPath,
                    path
                );
            }
            
            return normalized;
        } catch (URISyntaxException e) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.MALFORMED_URI,
                originalPath,
                path,
                e
            );
        }
    }
    
    private void validatePatterns(String path, String originalPath) {
        if (TRAVERSAL_PATTERN.matcher(path).find()) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.PATH_TRAVERSAL,
                originalPath,
                path
            );
        }
    }
    
    private void validateSemantics(String path, String originalPath) {
        // Semantic validation using simple conditionals
        if (path.startsWith("/admin")) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.PATH_TRAVERSAL,
                originalPath,
                path
            );
        }
        if (path.contains("WEB-INF")) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.PATH_TRAVERSAL,
                originalPath,
                path
            );
        }
        if (path.contains("META-INF")) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.PATH_TRAVERSAL,
                originalPath,
                path
            );
        }
    }
}
----

==== Stage Implementations

[source,java]
----
/**
 * Decoding stage - handles all encoding schemes
 */
public class DecodingStage implements ValidationStage {
    
    private final List<Decoder> decoders = Arrays.asList(
        new UrlDecoderWrapper(),
        new UnicodeDecoder(),
        new HTMLEntityDecoder(),
        new Base64DecoderWrapper(),
        new DoubleEncodingDetector()
    );
    
    @Override
    public StageResult process(ValidationData data) {
        String path = data.getPath();
        
        for (Decoder decoder : decoders) {
            if (decoder.canDecode(path)) {
                path = decoder.decode(path);
                data.addDecodingStep(decoder.getName());
            }
        }
        
        // Check for remaining encoding
        if (hasRemainingEncoding(path)) {
            return StageResult.blocked("Undecodeable content detected");
        }
        
        return StageResult.proceed(data.withPath(path));
    }
}

/**
 * Normalization stage - platform-aware path normalization
 */
public class NormalizationStage implements ValidationStage {
    
    @Override
    public StageResult process(ValidationData data) {
        String normalized = normalizePath(data.getPath(), data.getPlatform());
        
        // Detect normalization bypass attempts
        if (isNormalizationBypass(data.getPath(), normalized)) {
            return StageResult.blocked("Normalization bypass detected");
        }
        
        return StageResult.proceed(data.withPath(normalized));
    }
    
    private String normalizePath(String path, Platform platform) {
        // Platform-specific normalization
        return platform.getNormalizer().normalize(path);
    }
}
----

== Security Validation Strategies

=== Multi-Layer Validation Approach

[source,java]
----
public class ValidationEngine {
    
    private final List<Validator> validators = Arrays.asList(
        new BlacklistValidator(),      // Known attack patterns
        new WhitelistValidator(),      // Allowed patterns only
        new ContainmentValidator(),    // Path containment checks
        new CanonicalValidator(),      // Canonical path validation
        new SemanticValidator()        // Context-aware validation
    );
    
    public ValidationResult validate(ValidationContext context) {
        for (Validator validator : validators) {
            if (validator.appliesTo(context)) {
                ValidationResult result = validator.validate(context);
                if (result.isBlocked()) {
                    return result;
                }
            }
        }
        return ValidationResult.allowed();
    }
}
----

=== Attack Pattern Detection

[source,java]
----
public class AttackPatternDetector {
    
    private final PatternMatcher patterns;
    
    public AttackPatternDetector() {
        this.patterns = new PatternMatcher();
        loadCVEPatterns();
        loadOWASPPatterns();
        loadCustomPatterns();
    }
    
    public boolean detectAttack(String path) {
        // Direct pattern matching
        if (patterns.matches(path)) {
            return true;
        }
        
        // Semantic analysis
        if (hasTraversalSemantics(path)) {
            return true;
        }
        
        // Anomaly detection
        if (isAnomalous(path)) {
            return true;
        }
        
        return false;
    }
    
    private void loadCVEPatterns() {
        // Load patterns from CVE database
        patterns.addPattern("CVE-2021-29425", "//../*");
        patterns.addPattern("CVE-2023-32235", "*%2F..%2F..%2F*");
        patterns.addPattern("CVE-2023-50164", "../../WEB-INF/*");
        // ... more CVE patterns
    }
}
----


=== Comprehensive HTTP Parameter Validation

==== URL Query Parameter Value Validation

[source,java]
----
public class URLParameterValueValidator {
    
    /**
     * Validates and decodes an HTTP query parameter
     * 
     * @param name the parameter name
     * @param value the parameter value
     * @return the validated and decoded parameter value
     * @throws UrlSecurityException if validation fails
     */
    public String validateQueryParameter(String name, String value) {
        // 1. Validate parameter name (RFC 7230 token)
        if (!isValidParameterName(name)) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.INVALID_ENCODING,
                value,
                null
            );
        }
        
        // 2. Decode the parameter value using secure utility
        String decoded = UrlDecodingTools.getDecodedValue(value);
        
        // 3. Validate based on parameter context
        if (isURLParameter(name)) {
            return validateURLValue(name, decoded, value);
        } else if (isNumericParameter(name)) {
            return validateNumericValue(name, decoded, value);
        }
        
        // 4. Generic validation for all parameters
        return validateGenericValue(name, decoded, value);
    }
    
    private String validateGenericValue(String name, String value, String originalValue) {
        // Path traversal patterns
        if (containsPathTraversal(value)) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.PATH_TRAVERSAL,
                originalValue,
                value
            );
        }
        
        // Null byte injection already checked in UrlDecodingTools
        return value;
    }
    
    private String validateURLValue(String name, String value, String originalValue) {
        // Check for javascript: protocol
        if (value.toLowerCase().startsWith("javascript:")) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.PATH_TRAVERSAL,
                originalValue,
                value
            );
        }
        
        // Check for data: protocol (potential XSS)
        if (value.toLowerCase().startsWith("data:")) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.PATH_TRAVERSAL,
                originalValue,
                value
            );
        }
        
        // Validate URL format
        try {
            URL url = new URL(value);
            // Check for non-HTTP protocols
            String protocol = url.getProtocol();
            if (!"http".equalsIgnoreCase(protocol) && !"https".equalsIgnoreCase(protocol)) {
                throw new UrlSecurityException(
                    UrlSecurityFailureType.PATH_TRAVERSAL,
                    originalValue,
                    value
                );
            }
        } catch (MalformedURLException e) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.MALFORMED_URI,
                originalValue,
                value,
                e
            );
        }
        
        return value;
    }
    
    private String validateNumericValue(String name, String value, String originalValue) {
        // Implementation for numeric parameter validation
        return value;
    }
    
    private boolean isValidParameterName(String name) {
        // RFC 7230 token characters
        return name.matches("^[a-zA-Z0-9!#$%&'*+\\-.^_`|~]+$");
    }
    
}
----

==== HTTP POST Body Parameter Value Validation

[source,java]
----
public class BodyParameterValueValidator {
    
    private static final int MAX_FORM_FIELD_LENGTH = 8192;
    
    // Content-Type specific validation
    public ValidationResult validateBodyParameter(String contentType, String name, String value) {
        switch (contentType.toLowerCase()) {
            case "application/x-www-form-urlencoded":
                return validateFormEncodedValue(name, value);
            case "application/json":
                return validateJsonValue(name, value);
            case "multipart/form-data":
                return validateMultipartValue(name, value);
            case "application/xml":
            case "text/xml":
                return validateXmlValue(name, value);
            default:
                return validateGenericValue(name, value);
        }
    }
    
    private ValidationResult validateFormEncodedValue(String name, String value) {
        // URL decode the value
        String decoded = URLDecoder.decode(value, StandardCharsets.UTF_8);
        
        // Check for path traversal
        if (containsPathTraversal(decoded)) {
            return ValidationResult.blocked("Path traversal in form field: " + name);
        }
        
        // Check length limits
        if (decoded.length() > MAX_FORM_FIELD_LENGTH) {
            return ValidationResult.blocked("Form field too long: " + name);
        }
        
        // Check for SQL injection patterns
        if (containsSQLInjection(decoded)) {
            return ValidationResult.blocked("SQL injection pattern in: " + name);
        }
        
        return ValidationResult.allowed();
    }
    
    private ValidationResult validateJsonValue(String name, String value) {
        // Check for JSON injection attacks
        if (value.contains("$where") || value.contains("$regex")) {
            return ValidationResult.blocked("NoSQL injection pattern in: " + name);
        }
        
        // Validate string values for path traversal
        if (containsPathTraversal(value)) {
            return ValidationResult.blocked("Path traversal in JSON: " + name);
        }
        
        // Check for prototype pollution
        if (name.equals("__proto__") || name.equals("constructor") || name.equals("prototype")) {
            return ValidationResult.blocked("Prototype pollution attempt: " + name);
        }
        
        return ValidationResult.allowed();
    }
    
    private ValidationResult validateMultipartValue(String name, String value) {
        // Validate Content-Disposition filename parameter
        if (name.equals("filename")) {
            // Check for path traversal patterns in filename
            if (value.contains("..") || value.contains("/") || value.contains("\\")) {
                return ValidationResult.blocked("Path traversal in filename parameter");
            }
            
            // Check for null bytes
            if (value.contains("\0")) {
                return ValidationResult.blocked("Null byte in filename");
            }
        }
        
        return ValidationResult.allowed();
    }
}
----

=== Cookie Path Validation

[source,java]
----
public class CookiePathValidator {
    
    // RFC 6265 - HTTP State Management
    public ValidationResult validateCookiePath(String path) {
        // RFC 6265 Section 5.1.4 - Paths
        if (!path.startsWith("/")) {
            return ValidationResult.blocked("Cookie path must start with /");
        }
        
        // Check for path traversal in cookie paths
        if (containsPathTraversal(path)) {
            return ValidationResult.blocked("Path traversal in cookie path");
        }
        
        return ValidationResult.allowed();
    }
}
----

== URL Path Validation (Primary Focus)

=== HTTP Standards Compliance

==== RFC 3986 - URI Generic Syntax Implementation

[source,java]
----
public class RFC3986Validator {
    
    // RFC 3986 Section 2.2 - Reserved Characters
    private static final String RESERVED = ":/?#[]@!$&'()*+,;=";
    private static final String UNRESERVED = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    
    public boolean isValidURIPath(String path) {
        // RFC 3986 Section 3.3 - Path validation
        for (char c : path.toCharArray()) {
            if (!isUnreserved(c) && !isReserved(c) && !isPercentEncoded(path, c)) {
                return false;
            }
        }
        return true;
    }
    
    private boolean isPercentEncoded(String path, char c) {
        // RFC 3986 Section 2.1 - Percent-Encoding
        return c == '%' && isHexDigit(path.charAt(path.indexOf(c) + 1)) 
                        && isHexDigit(path.charAt(path.indexOf(c) + 2));
    }
}
----

==== RFC 7230 - HTTP/1.1 Message Syntax

[source,java]
----
public class RFC7230Validator {
    
    // RFC 7230 Section 3.2 - Header Field Structure
    private static final Pattern TOKEN = Pattern.compile("^[!#$%&'*+\\-.0-9A-Z^_`a-z|~]+$");
    
    // RFC 7230 Section 5.3 - Request Target
    public ValidationResult validateRequestTarget(String target) {
        // origin-form = absolute-path [ "?" query ]
        if (target.startsWith("/")) {
            return validateOriginForm(target);
        }
        // absolute-form = absolute-URI
        else if (target.matches("^https?://.*")) {
            return validateAbsoluteForm(target);
        }
        return ValidationResult.blocked("Invalid request target format");
    }
    
    public boolean isValidHeaderName(String name) {
        return TOKEN.matcher(name).matches();
    }
}
----

=== URL-Specific Security

[source,java]
----
public class URLPathSecurityValidator {
    
    /**
     * Validates a URL path for security issues
     * 
     * @param urlPath the URL path to validate
     * @return the validated and decoded URL path
     * @throws UrlSecurityException if validation fails
     */
    public String validateURLPath(String urlPath) {
        // Decode URL encoding using secure utility
        String decoded = UrlDecodingTools.getDecodedValue(urlPath);
        
        // Validate URL path components
        String[] segments = decoded.split("/");
        for (String segment : segments) {
            if (isTraversalSegment(segment)) {
                throw new UrlSecurityException(
                    UrlSecurityFailureType.PATH_TRAVERSAL,
                    urlPath,
                    decoded
                );
            }
        }
        
        // Check for URL-specific attacks
        if (hasURLAttackPattern(decoded)) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.PATH_TRAVERSAL,
                urlPath,
                decoded
            );
        }
        
        return decoded;
    }
    
}
----

== Performance Optimization

=== Caching Strategy

[source,java]
----
public class ValidationCache {
    
    private final Map<String, ValidationResult> cache = new ConcurrentHashMap<>();
    private final Set<String> knownMalicious = Collections.synchronizedSet(new HashSet<>());
    
    public ValidationCache() {
        // Initialize cache with size limit using a simple LRU approach
        // In production, consider using Caffeine or a proper cache library
        // For now, we'll use a simple map with manual eviction
    }
    
    public Optional<ValidationResult> get(String path) {
        // Quick check for known malicious
        if (knownMalicious.contains(path)) {
            return Optional.of(ValidationResult.blocked("Known attack pattern"));
        }
        
        return Optional.ofNullable(cache.get(path));
    }
    
    public void put(String path, ValidationResult result) {
        cache.put(path, result);
        
        if (result.isBlocked()) {
            knownMalicious.add(path);
        }
    }
}
----

=== Performance Metrics

[source,java]
----
public class PerformanceMonitor {
    
    private final MeterRegistry registry;
    
    public PerformanceMonitor(MeterRegistry registry) {
        this.registry = registry;
    }
    
    public <T> T measure(String operation, Supplier<T> task) {
        return Timer.Sample
            .start(registry)
            .stop(registry.timer("path.validation", "operation", operation))
            .recordCallable(task);
    }
    
    public void recordValidation(ValidationContext context, long duration) {
        registry.timer("path.validation.duration",
            "type", context.getType().name(),
            "result", context.getResult().name()
        ).record(duration, TimeUnit.NANOSECONDS);
        
        registry.counter("path.validation.count",
            "type", context.getType().name()
        ).increment();
    }
}
----

== Security Configuration

=== Configuration Model

[source,java]
----
@ConfigurationProperties(prefix = "security.path")
public class PathSecurityConfiguration {
    
    /**
     * Validation strictness level
     */
    private StrictnessLevel strictness = StrictnessLevel.HIGH;
    
    /**
     * Allowed content types for multipart uploads
     */
    private Set<String> allowedContentTypes = Set.of(
        "text/plain", "application/json", "application/xml"
    );
    
    /**
     * Maximum path length
     */
    private int maxPathLength = 4096;
    
    /**
     * Enable caching
     */
    private boolean cachingEnabled = true;
    
    /**
     * Custom validation rules
     */
    private List<CustomRule> customRules = new ArrayList<>();
    
    /**
     * HTTP-specific settings
     */
    private HttpSettings httpSettings = new HttpSettings();
    
    public enum StrictnessLevel {
        LOW,      // Basic validation only
        MEDIUM,   // Standard validation
        HIGH,     // Strict validation (default)
        PARANOID  // Maximum security, may block legitimate paths
    }
}
----

== Error Handling and Logging

=== Security-Aware Error Handling

[source,java]
----
public class SecurityErrorHandler {
    
    /**
     * Handle validation errors without information disclosure
     */
    public ErrorResponse handleError(ValidationException e) {
        // Log detailed error internally
        securityLogger.error("Validation failed", e);
        
        // Return generic error to client
        return ErrorResponse.builder()
            .code("INVALID_PATH")
            .message("The requested path is invalid")
            .build();
    }
    
    /**
     * Audit logging for security events
     */
    public void auditValidation(ValidationContext context, ValidationResult result) {
        AuditEvent event = AuditEvent.builder()
            .timestamp(Instant.now())
            .principal(context.getPrincipal())
            .action("PATH_VALIDATION")
            .resource(sanitizePath(context.getPath()))
            .result(result.isAllowed() ? "ALLOWED" : "BLOCKED")
            .reason(result.getReason())
            .build();
            
        auditLogger.log(event);
    }
}
----

== Integration Patterns


== Monitoring and Observability

=== Metrics Collection

[source,java]
----
@Component
public class PathSecurityMetrics {
    
    private final MeterRegistry registry;
    
    public void recordValidation(ValidationMetrics metrics) {
        // Record validation counts
        registry.counter("path.validation.total",
            "type", metrics.getType(),
            "result", metrics.getResult()
        ).increment();
        
        // Record performance metrics
        registry.timer("path.validation.duration",
            "type", metrics.getType()
        ).record(metrics.getDuration());
        
        // Record attack detection
        if (metrics.isAttackDetected()) {
            registry.counter("path.validation.attacks",
                "pattern", metrics.getAttackPattern()
            ).increment();
        }
    }
    
    public void exportMetrics() {
        // Prometheus format
        String metrics = registry.scrape();
        
        // Custom format for security dashboard
        SecurityMetrics securityMetrics = SecurityMetrics.builder()
            .totalValidations(getTotalValidations())
            .blockedAttempts(getBlockedAttempts())
            .averageLatency(getAverageLatency())
            .topAttackPatterns(getTopAttackPatterns())
            .build();
    }
}
----


== Conclusion

This architecture provides a comprehensive, extensible, and performant solution for HTTP/URL path traversal security that addresses the limitations found in existing libraries while incorporating lessons learned from real-world vulnerabilities.

== References

=== Security Standards and Frameworks

* link:https://owasp.org/www-project-application-security-verification-standard/[OWASP Application Security Architecture Guide]
* link:https://www.nist.gov/cyberframework[NIST Cybersecurity Framework]
* link:https://www.iso.org/standard/44378.html[ISO/IEC 27034 - Application Security]
* link:https://www.commoncriteriaportal.org/[Common Criteria for Information Technology Security Evaluation]
* link:https://attack.mitre.org/[MITRE ATT&CK Framework]
* link:https://csrc.nist.gov/publications/detail/sp/800-207/final[Zero Trust Architecture (NIST SP 800-207)]

=== HTTP and URL Standards

* link:https://www.rfc-editor.org/rfc/rfc3986[RFC 3986 - Uniform Resource Identifier (URI): Generic Syntax]
* link:https://www.rfc-editor.org/rfc/rfc7230[RFC 7230 - Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing]
* link:https://www.rfc-editor.org/rfc/rfc6265[RFC 6265 - HTTP State Management Mechanism]
* link:https://www.rfc-editor.org/rfc/rfc8941[RFC 8941 - Structured Field Values for HTTP]
* link:https://www.rfc-editor.org/rfc/rfc3987[RFC 3987 - Internationalized Resource Identifiers (IRIs)]

=== Vulnerability Resources

* link:https://cwe.mitre.org/data/definitions/22.html[CWE-22: Improper Limitation of a Pathname to a Restricted Directory]
* link:https://nvd.nist.gov/[National Vulnerability Database]
* link:https://www.first.org/cvss/[Common Vulnerability Scoring System (CVSS)]

