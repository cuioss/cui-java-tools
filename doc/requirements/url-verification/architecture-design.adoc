= URL Security Validation Architecture and Design
:toc: left
:toclevels: 3
:sectnums:
:icons: font

link:README.adoc[← Back to Documentation Index]

[IMPORTANT]
====
This document describes HOW the URL Security Validation system architecture works.
For WHAT tasks to implement, see link:../../../plan.adoc[Implementation Plan].
For HOW to test the system, see link:test-harness-design.adoc[Test Harness Design].
====

== Executive Summary

The URL Security Validation system provides comprehensive protection against path traversal attacks, encoding bypasses, and injection attempts through a layered, immutable, high-performance architecture in the `de.cuioss.tools.security.http` package.

=== Java 21+ Features Utilized

This architecture leverages modern Java 21+ features for improved code quality and maintainability:

* **String Templates** - Clean formatting without String.format complexity
* **Enhanced Pattern Matching** - Modern switch expressions with type patterns and record deconstruction
* **Records** - Immutable data carriers replacing @Value classes
* **SequencedCollections** - Ordered collection processing with first/last access
* **JSpecify Annotations** - Null-safety guarantees with @NonNull/@Nullable
* **Optional Integration** - Explicit null handling for sensitive data
* **Switch Expressions** - Concise, exhaustive pattern matching

== Design Principles

[cols="2,3"]
|===
|Principle |Implementation

|Defense in Depth
|Sequential validation stages, each catching different attack classes

|Fail Secure
|String/throws pattern - reject on any security violation

|Secure Defaults
|Configuration constants based on OWASP/RFC with documented sources

|Immutability
|All validation stages immutable after construction for thread safety

|Performance First
|Pre-compiled patterns, optimized algorithms, <1ms requirement

|Transparency
|Structured logging via LogRecord pattern, security event counting
|===

== System Architecture

=== High-Level Architecture

----
┌─────────────────────────────────────────────────────────┐
│                    Client Request                        │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│              HttpSecurityValidator                       │
│         (Core validation interface)                      │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│              Validation Pipeline                         │
│         (Sequential stage execution)                     │
├──────────────────────────────────────────────────────────┤
│  Stage 1: LengthValidationStage                         │
│  Stage 2: CharacterValidationStage                      │
│  Stage 3: DecodingStage                                 │
│  Stage 4: NormalizationStage                            │
│  Stage 5: PatternMatchingStage                          │
└──────────────────────────────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│          Security Event Tracking                         │
│    (Counter + LogRecord based logging)                   │
└──────────────────────────────────────────────────────────┘
----

=== Package Structure

----
de.cuioss.tools.security.http/
├── HttpSecurityValidator.java         # Core validation interface
├── UrlSecurityException.java          # Main exception with ValidationType
├── UrlSecurityFailureType.java        # Comprehensive failure enum  
├── ValidationType.java                # Input type classification
│
├── config/
│   ├── ConfigStageProvider.java      # Stage provider interface
│   ├── UrlSecurityConfig.java        # Base configuration with defaults
│   ├── URLPathConfig.java            # URL path specific config
│   ├── URLParameterConfig.java       # Parameter validation config
│   ├── HTTPHeaderConfig.java         # HTTP header config
│   ├── HTTPBodyConfig.java           # HTTP body validation config
│   └── CookieConfig.java              # Cookie validation config
│
├── security/
│   ├── SecurityEventCounter.java     # Thread-safe event counting
│   └── URLSecurityLogMessages.java   # LogRecord pattern messages
│
├── validation/
│   ├── LengthValidationStage.java    # Size limit validation (FIRST!)
│   ├── CharacterValidationStage.java # RFC character validation (SECOND!)
│   ├── DecodingStage.java            # Multi-layer decoding
│   ├── NormalizationStage.java       # Path normalization
│   └── PatternMatchingStage.java     # Attack pattern detection
│
└── pipeline/
    ├── UnifiedValidationPipeline.java # Single pipeline for all types
    └── ValidationFactory.java         # Factory for creating validators
----

== Core Components

=== Core Interfaces and Data Types

[source,java]
----
package de.cuioss.tools.security.http;

import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

/**
 * Core functional interface for HTTP security validation.
 * Follows the String/throws pattern consistently.
 * Can be used with lambda expressions and method references.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B3]
 */
@FunctionalInterface
public interface HttpSecurityValidator {
    /**
     * Validates the input and returns the sanitized/normalized version.
     * @param value The input to validate (may be null)
     * @return The validated/normalized value
     * @throws UrlSecurityException on any security violation
     */
    @NonNull
    String validate(@Nullable String value) throws UrlSecurityException;
}

/**
 * Classification of input types for appropriate validation.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B3]
 */
public enum ValidationType {
    URL_PATH,        // URL path segments
    URL_PARAMETER,   // Query parameters
    HTTP_HEADER,     // HTTP headers
    HTTP_BODY,       // Request/response bodies
    COOKIE;          // HTTP cookies
    
    /**
     * Check if this validation type requires URL decoding.
     * Used in pattern matching scenarios.
     */
    public boolean requiresDecoding() {
        return this == URL_PATH || this == URL_PARAMETER;
    }
}

/**
 * Comprehensive enumeration of security failure types.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B1]
 */
public enum UrlSecurityFailureType {
    // Encoding Issues
    INVALID_ENCODING("Invalid URL encoding detected"),
    DOUBLE_ENCODING("Double URL encoding detected"),
    UNICODE_NORMALIZATION_CHANGED("Unicode normalization altered input"),
    
    // Path Traversal
    PATH_TRAVERSAL_DETECTED("Path traversal pattern detected"),
    DIRECTORY_ESCAPE_ATTEMPT("Directory escape attempt detected"),
    
    // Character Issues
    INVALID_CHARACTER("Invalid character detected"),
    NULL_BYTE_INJECTION("Null byte injection detected"),
    CONTROL_CHARACTERS("Control characters detected"),
    
    // Length/Size Issues
    PATH_TOO_LONG("Path exceeds maximum length"),
    EXCESSIVE_NESTING("Excessive directory nesting"),
    
    // Pattern Matches
    SUSPICIOUS_PATTERN("Suspicious pattern detected"),
    KNOWN_ATTACK_SIGNATURE("Known attack signature detected"),
    
    // Structural Issues
    MALFORMED_INPUT("Malformed input structure"),
    INVALID_STRUCTURE("Invalid input structure"),
    
    // Protocol Issues  
    PROTOCOL_VIOLATION("Protocol specification violation"),
    RFC_VIOLATION("RFC specification violation");
    
    private final String description;
    
    UrlSecurityFailureType(String description) {
        this.description = description;
    }
}

/**
 * Main exception for security violations.
 * Extends RuntimeException for clean functional interface usage.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B2]
 */
public class UrlSecurityException extends RuntimeException {
    @NonNull private final UrlSecurityFailureType failureType;
    @NonNull private final ValidationType validationType;
    @NonNull private final String originalInput;
    @Nullable private final String sanitizedInput;
    @Nullable private final String detail;
    
    public UrlSecurityException(
            @NonNull UrlSecurityFailureType failureType,
            @NonNull ValidationType validationType,
            @NonNull String originalInput,
            @Nullable String sanitizedInput,
            @Nullable String detail) {
        super(buildMessage(failureType, validationType, originalInput, detail));
        this.failureType = failureType;
        this.validationType = validationType;
        this.originalInput = originalInput;
        this.sanitizedInput = sanitizedInput;
        this.detail = detail;
    }
    
    public UrlSecurityException(
            @NonNull UrlSecurityFailureType failureType,
            @NonNull ValidationType validationType,
            @NonNull String originalInput,
            @Nullable String sanitizedInput,
            @Nullable String detail,
            @Nullable Throwable cause) {
        super(buildMessage(failureType, validationType, originalInput, detail), cause);
        this.failureType = failureType;
        this.validationType = validationType;
        this.originalInput = originalInput;
        this.sanitizedInput = sanitizedInput;
        this.detail = detail;
    }
    
    private static String buildMessage(UrlSecurityFailureType failureType,
                                        ValidationType validationType,
                                        String originalInput,
                                        String detail) {
        StringBuilder sb = new StringBuilder();
        sb.append("Security validation failed [").append(validationType).append("]: ");
        sb.append(failureType);
        if (detail != null) {
            sb.append(" - ").append(detail);
        }
        sb.append(" (input: '").append(originalInput).append("')");
        return sb.toString();
    }
    
    /**
     * Static factory with cause support.
     */
    public static UrlSecurityException withCause(
            UrlSecurityFailureType failureType,
            ValidationType validationType,
            String originalInput,
            @Nullable String sanitizedInput,
            @Nullable String detail,
            @Nullable Throwable cause) {
        return new UrlSecurityException(failureType, validationType, originalInput, 
                                         sanitizedInput, detail, cause);
    }
    
    // Getters
    public UrlSecurityFailureType getFailureType() {
        return failureType;
    }
    
    public ValidationType getValidationType() {
        return validationType;
    }
    
    public String getOriginalInput() {
        return originalInput;
    }
    
    @Nullable
    public String getSanitizedInput() {
        return sanitizedInput;
    }
    
    @Nullable
    public String getDetail() {
        return detail;
    }
    
    /**
     * Get sanitized input as Optional.
     */
    public Optional<String> getSanitizedInputOptional() {
        return Optional.ofNullable(sanitizedInput);
    }
}
----

=== Data Records

[source,java]
----
package de.cuioss.tools.security.http;

/**
 * Data records used throughout the system.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B3]
 */
public record URLParameter(
    @NonNull String key, 
    @Nullable String value
) {
    /**
     * Check if this parameter contains sensitive data based on key name.
     */
    public boolean isSensitive() {
        String lowerKey = key.toLowerCase();
        return lowerKey.contains("password") || 
               lowerKey.contains("token") || 
               lowerKey.contains("secret") ||
               lowerKey.contains("api_key");
    }
}

public record Cookie(
    @NonNull String name, 
    @Nullable String value, 
    @NonNull Map<String, String> attributes
) {
    /**
     * Check if this is a security-sensitive cookie.
     */
    public boolean isSecuritySensitive() {
        String lowerName = name.toLowerCase();
        return lowerName.contains("session") || 
               lowerName.contains("auth") || 
               lowerName.contains("csrf");
    }
}

public record HTTPBody(
    @NonNull String contentType, 
    byte @NonNull [] content
) {
    /**
     * Get content length safely.
     */
    public int length() {
        return content.length;
    }
}
----

== Configuration Architecture

Configuration follows the embedded constants pattern from `ParserConfig`:

=== ConfigStageProvider Interface

[source,java]
----
package de.cuioss.tools.security.http.config;

/**
 * Provides factory methods for creating pre-configured validation stages.
 * This interface decouples pipelines from concrete configuration implementations.
 * All methods return HttpSecurityValidator for flexibility.
 */
public interface ConfigStageProvider {
    
    /**
     * @return The type of validation this configuration is for
     */
    ValidationType getValidationType();
    
    /**
     * @return Pre-configured length validation stage
     */
    HttpSecurityValidator getLengthValidationStage();
    
    /**
     * @return Pre-configured character validation stage appropriate for the ValidationType
     */
    HttpSecurityValidator getCharacterValidationStage();
    
    /**
     * @return Pre-configured decoding stage with security checks
     */
    HttpSecurityValidator getDecodingStage();
    
    /**
     * @return Pre-configured normalization stage
     */
    HttpSecurityValidator getNormalizationStage();
    
    /**
     * @return Pre-configured pattern matching stage
     */
    HttpSecurityValidator getPatternMatchingStage();
    
    /**
     * @return List of stages to use in the pipeline, in the correct order
     */
    SequencedCollection<HttpSecurityValidator> getStages();
}
----

=== Configuration Implementations

[source,java]
----
package de.cuioss.tools.security.http.config;

import lombok.Builder;
import lombok.Value;

/**
 * Base configuration with security defaults.
 * All defaults are based on OWASP guidelines and RFC specifications.
 * Implemented by: link:../../../plan.adoc#_phase_3_configuration_system[Tasks C1-C2]
 */
@Builder
@Value
public class UrlSecurityConfig {
    
    /**
     * Maximum URL path length in characters.
     * Default: 2048 based on RFC 3986 Section 3.3 and common browser limits.
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-3.3">RFC 3986</a>
     * @see <a href="https://owasp.org/www-community/vulnerabilities/Buffer_Overflow">OWASP Buffer Overflow</a>
     */
    public static final int DEFAULT_MAX_PATH_LENGTH = 2048;
    
    /**
     * Maximum directory traversal depth.
     * Default: 10 based on typical filesystem depth and OWASP recommendations.
     * @see <a href="https://owasp.org/www-community/attacks/Path_Traversal">OWASP Path Traversal</a>
     */
    public static final int DEFAULT_MAX_DIRECTORY_DEPTH = 10;
    
    /**
     * Maximum parameter value length.
     * Default: 4096 based on common server configurations.
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.1">RFC 7230</a>
     */
    public static final int DEFAULT_MAX_PARAMETER_LENGTH = 4096;
    
    /**
     * Maximum number of parameters.
     * Default: 100 to prevent parameter pollution attacks.
     * @see <a href="https://owasp.org/www-community/attacks/HTTP_Parameter_Pollution">OWASP HPP</a>
     */
    public static final int DEFAULT_MAX_PARAMETER_COUNT = 100;
    
    /**
     * Enable Unicode normalization (NFC).
     * Default: true per OWASP guidelines for Unicode security.
     * @see <a href="https://owasp.org/www-community/attacks/Unicode_Encoding">OWASP Unicode</a>
     */
    public static final boolean DEFAULT_UNICODE_NORMALIZATION = true;
    
    /**
     * Reject null bytes in input.
     * Default: true to prevent null byte injection attacks.
     * @see <a href="https://owasp.org/www-community/attacks/Null_Byte_Injection">OWASP Null Byte</a>
     */
    public static final boolean DEFAULT_REJECT_NULL_BYTES = true;
    
    @Builder.Default
    int maxPathLength = DEFAULT_MAX_PATH_LENGTH;
    
    @Builder.Default
    int maxDirectoryDepth = DEFAULT_MAX_DIRECTORY_DEPTH;
    
    @Builder.Default
    int maxParameterLength = DEFAULT_MAX_PARAMETER_LENGTH;
    
    @Builder.Default
    int maxParameterCount = DEFAULT_MAX_PARAMETER_COUNT;
    
    @Builder.Default
    boolean unicodeNormalization = DEFAULT_UNICODE_NORMALIZATION;
    
    @Builder.Default
    boolean rejectNullBytes = DEFAULT_REJECT_NULL_BYTES;
}

/**
 * Configuration for URL path validation.
 * Implements ConfigStageProvider with URL_PATH specific stages.
 */
@Value
public class URLPathConfig implements ConfigStageProvider {
    
    UrlSecurityConfig baseConfig;
    ValidationType validationType = ValidationType.URL_PATH;
    
    // Cached stage instances - created once, reused everywhere
    @Getter(lazy = true)
    LengthValidationStage lengthValidationStage = 
        new LengthValidationStage(baseConfig, ValidationType.URL_PATH);
    
    @Getter(lazy = true)
    CharacterValidationStage characterValidationStage = 
        new CharacterValidationStage(baseConfig, ValidationType.URL_PATH);
    
    @Getter(lazy = true)
    DecodingStage decodingStage = 
        new DecodingStage(baseConfig, ValidationType.URL_PATH);
    
    @Getter(lazy = true)
    NormalizationStage normalizationStage = 
        new NormalizationStage(baseConfig, ValidationType.URL_PATH);
    
    @Getter(lazy = true)
    PatternMatchingStage patternMatchingStage = 
        new PatternMatchingStage(baseConfig, ValidationType.URL_PATH);
    
    public URLPathConfig(UrlSecurityConfig baseConfig) {
        this.baseConfig = baseConfig;
    }
    
    @Override
    public ValidationType getValidationType() {
        return validationType;
    }
    
    @Override
    public SequencedCollection<HttpSecurityValidator> getStages() {
        return new ArrayList<>(List.of(
            getLengthValidationStage(),
            getCharacterValidationStage(),
            getDecodingStage(),
            getNormalizationStage(),
            getPatternMatchingStage()
        ));
    }
}

/**
 * Configuration for URL parameter validation.
 * Implements ConfigStageProvider with URL_PARAMETER specific stages.
 */
@Value
public class URLParameterConfig implements ConfigStageProvider {
    
    UrlSecurityConfig baseConfig;
    ValidationType validationType = ValidationType.URL_PARAMETER;
    
    @Getter(lazy = true)
    LengthValidationStage lengthValidationStage = 
        new LengthValidationStage(baseConfig, ValidationType.URL_PARAMETER);
    
    @Getter(lazy = true)
    CharacterValidationStage characterValidationStage = 
        new CharacterValidationStage(baseConfig, ValidationType.URL_PARAMETER);
    
    @Getter(lazy = true)
    DecodingStage decodingStage = 
        new DecodingStage(baseConfig, ValidationType.URL_PARAMETER);
    
    @Getter(lazy = true)
    PatternMatchingStage patternMatchingStage = 
        new PatternMatchingStage(baseConfig, ValidationType.URL_PARAMETER);
    
    public URLParameterConfig(UrlSecurityConfig baseConfig) {
        this.baseConfig = baseConfig;
    }
    
    @Override
    public ValidationType getValidationType() {
        return validationType;
    }
    
    @Override
    public HttpSecurityValidator getNormalizationStage() {
        return IdentityValidator.URL_PARAMETER; // Not used for parameters
    }
    
    @Override
    public SequencedCollection<HttpSecurityValidator> getStages() {
        return new ArrayList<>(List.of(
            getLengthValidationStage(),
            getCharacterValidationStage(),
            getDecodingStage(),
            getPatternMatchingStage()
        ));
    }
}

/**
 * Configuration for HTTP header validation.
 * Implements ConfigStageProvider with HTTP_HEADER specific stages.
 */
@Value
public class HTTPHeaderConfig implements ConfigStageProvider {
    
    UrlSecurityConfig baseConfig;
    ValidationType validationType = ValidationType.HTTP_HEADER;
    
    @Getter(lazy = true)
    LengthValidationStage lengthValidationStage = 
        new LengthValidationStage(baseConfig, ValidationType.HTTP_HEADER);
    
    @Getter(lazy = true)
    CharacterValidationStage characterValidationStage = 
        new CharacterValidationStage(baseConfig, ValidationType.HTTP_HEADER);
    
    @Getter(lazy = true)
    PatternMatchingStage patternMatchingStage = 
        new PatternMatchingStage(baseConfig, ValidationType.HTTP_HEADER);
    
    public HTTPHeaderConfig(UrlSecurityConfig baseConfig) {
        this.baseConfig = baseConfig;
    }
    
    @Override
    public ValidationType getValidationType() {
        return validationType;
    }
    
    @Override
    public HttpSecurityValidator getDecodingStage() {
        return IdentityValidator.HTTP_HEADER; // Not used for headers
    }
    
    @Override
    public HttpSecurityValidator getNormalizationStage() {
        return IdentityValidator.HTTP_HEADER; // Not used for headers
    }
    
    @Override
    public SequencedCollection<HttpSecurityValidator> getStages() {
        return new ArrayList<>(List.of(
            getLengthValidationStage(),
            getCharacterValidationStage(),
            getPatternMatchingStage()
        ));
    }
}
----

== Validation Stages

All validation stages follow these principles:

1. **Immutability**: Configuration stored in final fields, no runtime state changes
2. **Performance**: Pre-compiled patterns, optimized algorithms, <1ms per stage
3. **Thread Safety**: No mutable state, safe for concurrent use
4. **Clear Contracts**: String input/output with UrlSecurityException on violations

=== IdentityValidator

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.Getter;
import lombok.EqualsAndHashCode;
import lombok.ToString;

/**
 * Identity validator that performs no validation - just returns the input unchanged.
 * Used as a placeholder for stages that are not applicable to certain validation types.
 * Thread-safe and immutable.
 */
@EqualsAndHashCode
@ToString
public final class IdentityValidator implements HttpSecurityValidator {
    
    private final ValidationType validationType;
    
    /**
     * Singleton instances for each validation type to avoid unnecessary object creation.
     */
    public static final IdentityValidator URL_PATH = new IdentityValidator(ValidationType.URL_PATH);
    public static final IdentityValidator URL_PARAMETER = new IdentityValidator(ValidationType.URL_PARAMETER);
    public static final IdentityValidator HTTP_HEADER = new IdentityValidator(ValidationType.HTTP_HEADER);
    public static final IdentityValidator HTTP_BODY = new IdentityValidator(ValidationType.HTTP_BODY);
    public static final IdentityValidator COOKIE = new IdentityValidator(ValidationType.COOKIE);
    
    private IdentityValidator(ValidationType validationType) {
        this.validationType = validationType;
    }
    
    @Override
    public String validate(String value) {
        // Identity function - return input unchanged
        return value;
    }
}
----

=== LengthValidationStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.EqualsAndHashCode;
import lombok.ToString;

/**
 * Length validation MUST be the first stage to prevent DoS attacks.
 * Rejects oversized inputs before any processing.
 * Immutable and thread-safe.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V4]
 */
@EqualsAndHashCode
@ToString
public final class LengthValidationStage implements HttpSecurityValidator {
    
    private final int maxLength;
    private final int maxDepth;
    private final ValidationType validationType;
    
    public LengthValidationStage(UrlSecurityConfig config, ValidationType validationType) {
        this.maxLength = config.getMaxPathLength();
        this.maxDepth = config.getMaxDirectoryDepth();
        this.validationType = validationType;
    }
    
    @Override
    public String validate(String value) throws UrlSecurityException {
        // First check: total length
        if (value.length() > maxLength) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.PATH_TOO_LONG,
                validationType,
                value,
                null,
                null);
        }
        
        // Second check: nesting depth
        long depth = value.chars().filter(ch -> ch == '/' || ch == '\\').count();
        if (depth > maxDepth) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.EXCESSIVE_NESTING,
                validationType,
                value,
                null,
                null);
        }
        
        return value;
    }
}
----

=== DecodingStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.Value;
import java.text.Normalizer;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.regex.Pattern;

/**
 * Multi-layer decoding with security checks.
 * Immutable and thread-safe.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V1]
 */
@Value
public class DecodingStage implements HttpSecurityValidator {
    
    // Static pattern shared across all instances
    private static final Pattern DOUBLE_ENCODING_PATTERN = Pattern.compile("%25[0-9a-fA-F]{2}");
    
    UrlSecurityConfig config;
    ValidationType validationType;
    
    @Override
    public String validate(String value) throws UrlSecurityException {
        // Detect double encoding before decoding
        if (DOUBLE_ENCODING_PATTERN.matcher(value).find()) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.DOUBLE_ENCODING,
                validationType,
                value,
                null,
                null);
        }
        
        // URL decode
        String decoded;
        try {
            decoded = URLDecoder.decode(value, StandardCharsets.UTF_8);
        } catch (IllegalArgumentException e) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.INVALID_ENCODING,
                validationType,
                value,
                null,
                null,
                e);
        }
        
        // Unicode normalization with change detection
        if (config.isUnicodeNormalization()) {
            String normalized = Normalizer.normalize(decoded, Normalizer.Form.NFC);
            if (!decoded.equals(normalized)) {
                // Normalization changed the string - potential attack
                throw new UrlSecurityException(
                    UrlSecurityFailureType.UNICODE_NORMALIZATION_CHANGED,
                    validationType,
                    value,
                    normalized,
                    null);
            }
            decoded = normalized;
        }
        
        // Note: Null byte detection moved to CharacterValidationStage for earlier detection
        
        return decoded;
    }
}
----

=== Character Validation Constants

[source,java]
----
package de.cuioss.tools.security.http.validation;

import java.util.BitSet;

/**
 * Pre-computed character sets for validation according to RFC specifications.
 * These BitSets are read-only after initialization and thread-safe for concurrent reads.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V5]
 */
public final class CharacterValidationConstants {
    
    private CharacterValidationConstants() {
        // Utility class
    }
    
    // RFC 3986 unreserved characters: ALPHA / DIGIT / "-" / "." / "_" / "~"
    public static final BitSet RFC3986_UNRESERVED;
    
    // RFC 3986 path characters including unreserved + path-specific
    public static final BitSet RFC3986_PATH_CHARS;
    
    // RFC 3986 query characters including unreserved + query-specific  
    public static final BitSet RFC3986_QUERY_CHARS;
    
    // RFC 7230 header field characters (visible ASCII minus delimiters)
    public static final BitSet RFC7230_HEADER_CHARS;
    
    static {
        // Initialize RFC3986_UNRESERVED
        BitSet unreserved = new BitSet(256);
        // ALPHA
        for (int i = 'A'; i <= 'Z'; i++) unreserved.set(i);
        for (int i = 'a'; i <= 'z'; i++) unreserved.set(i);
        // DIGIT
        for (int i = '0'; i <= '9'; i++) unreserved.set(i);
        // "-" / "." / "_" / "~"
        unreserved.set('-');
        unreserved.set('.');
        unreserved.set('_');
        unreserved.set('~');
        RFC3986_UNRESERVED = unreserved;
        
        // Initialize RFC3986_PATH_CHARS
        BitSet pathChars = new BitSet(256);
        pathChars.or(unreserved);  // Include all unreserved chars
        pathChars.set('/');
        pathChars.set('@');
        pathChars.set(':');
        // sub-delims for path: "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
        "!$&'()*+,;=".chars().forEach(pathChars::set);
        RFC3986_PATH_CHARS = pathChars;
        
        // Initialize RFC3986_QUERY_CHARS
        BitSet queryChars = new BitSet(256);
        queryChars.or(unreserved);  // Include all unreserved chars
        queryChars.set('?');
        queryChars.set('&');
        queryChars.set('=');
        // sub-delims for query
        "!$'()*+,;".chars().forEach(queryChars::set);
        RFC3986_QUERY_CHARS = queryChars;
        
        // Initialize RFC7230_HEADER_CHARS
        BitSet headerChars = new BitSet(256);
        // RFC 7230: VCHAR = %x21-7E (visible ASCII)
        for (int i = 33; i <= 126; i++) {
            // Exclude HTTP delimiters: " ( ) , / : ; < = > ? @ [ \ ] { }
            if (!"\"(),/:;<=>?@[\\]{}".contains(String.valueOf((char)i))) {
                headerChars.set(i);
            }
        }
        headerChars.set(' '); // Space is allowed in headers
        RFC7230_HEADER_CHARS = headerChars;
    }
    
    /**
     * Returns the character set for the given validation type.
     * Note: Returns the actual BitSet, not a copy. Do not modify!
     */
    @NonNull
    public static BitSet getCharacterSet(@NonNull ValidationType type) {
        return switch (type) {
            case URL_PATH -> RFC3986_PATH_CHARS;
            case URL_PARAMETER -> RFC3986_QUERY_CHARS;
            case HTTP_HEADER -> RFC7230_HEADER_CHARS;
            case HTTP_BODY, COOKIE -> RFC3986_UNRESERVED;
        };
    }
}
----

=== CharacterValidationStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.EqualsAndHashCode;
import lombok.ToString;
import lombok.Getter;
import java.util.BitSet;

/**
 * Validates characters according to RFC 3986 for URLs.
 * MUST be the second stage after length validation.
 * Rejects invalid characters BEFORE any decoding/processing.
 * Immutable and thread-safe.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V5]
 */
@EqualsAndHashCode
@ToString
public final class CharacterValidationStage implements HttpSecurityValidator {
    
    private final BitSet allowedChars;
    private final ValidationType validationType;
    private final boolean allowPercentEncoding;
    
    public CharacterValidationStage(UrlSecurityConfig config, ValidationType type) {
        this.validationType = type;
        // Use the shared BitSet directly - it's read-only after initialization
        this.allowedChars = CharacterValidationConstants.getCharacterSet(type);
        
        // Determine if percent encoding is allowed based on type
        this.allowPercentEncoding = switch (type) {
            case URL_PATH, URL_PARAMETER -> true;
            default -> false;  // HTTP_HEADER and others don't allow percent encoding
        };
    }
    
    @Override
    public String validate(String value) throws UrlSecurityException {
        // Quick check for null/empty
        if (value == null || value.isEmpty()) {
            return value;
        }
        
        // Check each character
        for (int i = 0; i < value.length(); i++) {
            char ch = value.charAt(i);
            
            // Check for null byte FIRST (highest priority security check)
            if (ch == '\0') {
                throw new UrlSecurityException(
                    UrlSecurityFailureType.NULL_BYTE_INJECTION,
                    validationType,
                    value,
                    null,
                    "Null byte detected at position " + i);
            }
            
            // Handle percent encoding
            if (ch == '%' && allowPercentEncoding) {
                // Must be followed by two hex digits
                if (i + 2 >= value.length()) {
                    throw new UrlSecurityException(
                        UrlSecurityFailureType.INVALID_ENCODING,
                        validationType,
                        value,
                        null,
                        "Incomplete percent encoding at position " + i);
                }
                
                char hex1 = value.charAt(i + 1);
                char hex2 = value.charAt(i + 2);
                if (isNotHexDigit(hex1) || isNotHexDigit(hex2)) {
                    throw new UrlSecurityException(
                        UrlSecurityFailureType.INVALID_ENCODING,
                        validationType,
                        value,
                        null,
                        "Invalid hex digits in percent encoding at position " + i);
                }
                
                // Check for encoded null byte %00
                if (hex1 == '0' && hex2 == '0') {
                    throw new UrlSecurityException(
                        UrlSecurityFailureType.NULL_BYTE_INJECTION,
                        validationType,
                        value,
                        null,
                        "Encoded null byte (%00) detected at position " + i);
                }
                
                i += 2; // Skip the two hex digits
                continue;
            }
            
            // Check if character is allowed
            if (ch > 255 || !allowedChars.get(ch)) {
                throw new UrlSecurityException(
                    UrlSecurityFailureType.INVALID_CHARACTER,
                    validationType,
                    value,
                    null,
                    STR."Invalid character '\{ch}' (0x\{Integer.toHexString(ch).toUpperCase()}) at position \{i}");
            }
        }
        
        return value;
    }
    
    private boolean isNotHexDigit(char ch) {
        return !((ch >= '0' && ch <= '9') || 
                 (ch >= 'A' && ch <= 'F') || 
                 (ch >= 'a' && ch <= 'f'));
    }
}
----

=== NormalizationStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.Value;
import java.nio.file.Paths;

/**
 * Path normalization stage to resolve . and .. segments.
 * Follows RFC 3986 Section 5.2.4 for path normalization.
 * Immutable and thread-safe.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V2]
 */
@Value
public class NormalizationStage implements HttpSecurityValidator {
    
    UrlSecurityConfig config;
    ValidationType validationType;
    
    @Override
    public String validate(String value) throws UrlSecurityException {
        if (value == null || value.isEmpty()) {
            return value;
        }
        
        // Save original for comparison
        String original = value;
        
        // Normalize path segments (resolve . and ..)
        String normalized = normalizePath(value);
        
        // Check if normalization revealed path traversal
        if (containsPathTraversal(normalized)) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED,
                validationType,
                original,
                normalized,
                "Path normalization revealed traversal attempt");
        }
        
        // Check if path escapes root after normalization
        if (escapesRoot(normalized)) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.DIRECTORY_ESCAPE_ATTEMPT,
                validationType,
                original,
                normalized,
                "Path attempts to escape root directory");
        }
        
        return normalized;
    }
    
    private String normalizePath(String path) {
        // RFC 3986 path segment normalization with recursion protection
        String[] segments = path.split("/", -1);
        StringBuilder result = new StringBuilder();
        int depth = 0;
        int totalSegments = 0;
        
        // Prevent stack overflow with excessive segments
        final int MAX_SEGMENTS = 1000; // Reasonable limit for path segments
        if (segments.length > MAX_SEGMENTS) {
            throw new UrlSecurityException(
                UrlSecurityFailureType.EXCESSIVE_NESTING,
                validationType,
                path,
                null,
                STR."Path contains too many segments: \{segments.length} (max: \{MAX_SEGMENTS})"
            );
        }
        
        for (String segment : segments) {
            totalSegments++;
            
            // Additional recursion protection
            if (totalSegments > MAX_SEGMENTS) {
                throw new UrlSecurityException(
                    UrlSecurityFailureType.EXCESSIVE_NESTING,
                    validationType,
                    path,
                    null,
                    STR."Processing exceeded maximum segment count: \{MAX_SEGMENTS}"
                );
            }
            
            switch (segment) {
                case "." -> {
                    // Current directory - skip
                }
                case ".." -> {
                    // Parent directory
                    if (!result.isEmpty()) {
                        // Remove last segment
                        int lastSlash = result.lastIndexOf("/");
                        if (lastSlash >= 0) {
                            result.setLength(lastSlash);
                            depth = Math.max(0, depth - 1); // Prevent negative depth
                        }
                    } else {
                        // Trying to go above root
                        depth = Math.max(0, depth - 1);
                    }
                }
                case "" -> {
                    // Empty segment - skip
                }
                default -> {
                    // Normal segment
                    if (!result.isEmpty() || path.startsWith("/")) {
                        result.append("/");
                    }
                    result.append(segment);
                    depth++;
                    
                    // Check depth limit during processing
                    if (depth > config.getMaxDirectoryDepth()) {
                        throw new UrlSecurityException(
                            UrlSecurityFailureType.EXCESSIVE_NESTING,
                            validationType,
                            path,
                            result.toString(),
                            STR."Path depth \{depth} exceeds maximum \{config.getMaxDirectoryDepth()}"
                        );
                    }
                }
            }
        }
        
        // Preserve trailing slash if present
        if (path.endsWith("/") && !result.toString().endsWith("/")) {
            result.append("/");
        }
        
        return result.toString();
    }
    
    private boolean containsPathTraversal(String path) {
        // After normalization, there should be no .. segments
        return path.contains("../") || path.contains("..\\") || path.equals("..");
    }
    
    private boolean escapesRoot(String path) {
        // Check if normalized path tries to escape root
        return path.startsWith("../") || path.startsWith("..\\");
    }
}
----

=== PatternMatchingStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import lombok.Value;
import java.util.regex.Pattern;

/**
 * Pattern-based attack detection using pre-compiled patterns.
 * Immutable and optimized for performance.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V3]
 */
@Value
public class PatternMatchingStage implements HttpSecurityValidator {
    
    // Static patterns shared across all instances
    private static final Pattern PATH_TRAVERSAL_PATTERN = Pattern.compile(
        "(?:^|/)\\.\\.(?:/|$)"
    );
    private static final Pattern ENCODED_TRAVERSAL_PATTERN = Pattern.compile(
        "%(?:2e|2E)%(?:2e|2E)"
    );
    
    UrlSecurityConfig config; // Keep for consistency even if not used
    ValidationType validationType;
    
    @Override
    public String validate(String value) throws UrlSecurityException {
        // Check all patterns efficiently
        if (PATH_TRAVERSAL_PATTERN.matcher(value).find() ||
            ENCODED_TRAVERSAL_PATTERN.matcher(value).find()) {
            
            throw new UrlSecurityException(
                UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED,
                validationType,
                value,
                null,
                null);
        }
        
        return value;
    }
}
----

== Pipeline Architecture

=== Unified Validation Pipeline

A single pipeline implementation handles all validation types through configuration:

[source,java]
----
package de.cuioss.tools.security.http.pipeline;

import lombok.EqualsAndHashCode;
import lombok.ToString;
import java.util.SequencedCollection;
import java.util.Objects;
import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;

/**
 * Unified validation pipeline that works with any ConfigStageProvider.
 * The validation type and stage selection is determined by the configuration.
 * Implemented by: link:../../../plan.adoc#_phase_6_pipeline_implementation[Tasks P1-P5]
 */
@EqualsAndHashCode
@ToString
public final class UnifiedValidationPipeline implements HttpSecurityValidator {
    
    private final @NonNull ConfigStageProvider config;
    private final @NonNull SequencedCollection<HttpSecurityValidator> stages;
    private final @NonNull SecurityEventCounter eventCounter;
    private final @NonNull ValidationType validationType;
    
    public UnifiedValidationPipeline(ConfigStageProvider config, 
                                    SecurityEventCounter eventCounter) {
        this.config = Objects.requireNonNull(config, "Config must not be null");
        this.eventCounter = Objects.requireNonNull(eventCounter, "EventCounter must not be null");
        this.validationType = config.getValidationType();
        
        // Get stages from config - it knows which stages to use
        this.stages = config.getStages();
        
        if (stages.isEmpty()) {
            throw new IllegalArgumentException("Configuration must provide at least one stage");
        }
    }
    
    @Override
    public String validate(String value) throws UrlSecurityException {
        String result = value;
        
        // Sequential execution with early termination
        for (HttpSecurityValidator stage : stages) {
            // Skip null stages and identity validators
            if (stage != null && !(stage instanceof IdentityValidator)) {
                try {
                    result = stage.validate(result);
                } catch (UrlSecurityException e) {
                    // Add validation type to exception if not already set
                    if (e.getValidationType() == null) {
                        throw new UrlSecurityException(
                            e.getFailureType(),
                            this.validationType,
                            e.getOriginalInput(),
                            e.getSanitizedInput(),
                            e.getMessage(),
                            e.getCause());
                    }
                    
                    // Track security event
                    eventCounter.increment(e.getFailureType());
                    
                    // Log via URLSecurityLogMessages
                    logSecurityEvent(e);
                    
                    // Re-throw
                    throw e;
                }
            }
        }
        
        return result;
    }
    
    private void logSecurityEvent(UrlSecurityException e) {
        // Log security events based on failure type with pattern guards
        CuiLogger logger = new CuiLogger(UnifiedValidationPipeline.class);
        
        // Sanitize sensitive data before logging (only values, not keys/URLs)
        String sanitizedInput = sanitizeForLogging(e.originalInput(), e.validationType());
        
        // Use direct enum switch - proper Java 21 syntax (no 'when' guards)
        switch (e.failureType()) {
            case PATH_TRAVERSAL_DETECTED ->
                logger.warn(URLSecurityLogMessages.WARN.PATH_TRAVERSAL_DETECTED, 
                    sanitizedInput);
            case DOUBLE_ENCODING ->
                logger.warn(URLSecurityLogMessages.WARN.DOUBLE_ENCODING_DETECTED, 
                    sanitizedInput);
            case UNICODE_NORMALIZATION_CHANGED ->
                logger.warn(URLSecurityLogMessages.WARN.UNICODE_ATTACK_DETECTED);
            default ->
                logger.error(URLSecurityLogMessages.ERROR.VALIDATION_FAILED, 
                    e.failureType(), e.getMessage());
        }
    }
    
    /**
     * Sanitizes sensitive data for logging.
     * Only sanitizes parameter values and header values, not keys or URLs themselves.
     */
    private String sanitizeForLogging(@NonNull String input, @NonNull ValidationType type) {
        return switch (type) {
            case URL_PARAMETER -> {
                // Sanitize parameter values only
                String[] parts = input.split("=", 2);
                yield parts.length == 2 ? STR."\{parts[0]}=***" : input;
            }
            case HTTP_HEADER -> {
                // Sanitize header values (especially Authorization)
                if (input.toLowerCase().startsWith("authorization:") ||
                    input.toLowerCase().startsWith("x-api-key:")) {
                    int colonPos = input.indexOf(':');
                    yield STR."\{input.substring(0, colonPos + 1)} ***";
                }
                yield input;
            }
            case COOKIE -> {
                // Sanitize cookie values
                String[] parts = input.split("=", 2);
                yield parts.length == 2 ? STR."\{parts[0]}=***" : input;
            }
            case URL_PATH, HTTP_BODY -> input; // These are generally safe to log
        };
    }
}
----

== Security Event Tracking

=== Event Counter Pattern

[source,java]
----
package de.cuioss.tools.security.http.security;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Thread-safe security event counter.
 * Tracks occurrences of each UrlSecurityFailureType.
 * Implemented by: link:../../../plan.adoc#_phase_4_security_tracking_and_monitoring[Task S1]
 */
public class SecurityEventCounter {
    
    private final ConcurrentHashMap<UrlSecurityFailureType, AtomicLong> counters = 
        new ConcurrentHashMap<>();
    
    /**
     * Increment counter for a failure type.
     * @return new count value
     */
    public long increment(UrlSecurityFailureType type) {
        return counters.computeIfAbsent(type, k -> new AtomicLong(0))
                      .incrementAndGet();
    }
    
    /**
     * Get current count for a failure type.
     */
    public long getCount(@NonNull UrlSecurityFailureType type) {
        return Optional.ofNullable(counters.get(type))
            .map(AtomicLong::get)
            .orElse(0L);
    }
}
----

=== Structured Logging

[source,java]
----
package de.cuioss.tools.security.http.security;

import de.cuioss.tools.logging.LogRecord;
import de.cuioss.tools.logging.LogRecordModel;

/**
 * Structured log messages for URL security events.
 * Follows cui-jwt-validation LogRecord pattern.
 * Implemented by: link:../../../plan.adoc#_phase_4_security_tracking_and_monitoring[Task S2]
 */
public final class URLSecurityLogMessages {
    
    private static final String PREFIX = "URLSecurity";
    
    public static final class WARN {
        
        public static final LogRecord PATH_TRAVERSAL_DETECTED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(301)
                .template("Path traversal attempt detected: %s")
                .build();
        
        public static final LogRecord DOUBLE_ENCODING_DETECTED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(302)
                .template("Double encoding attack detected: %s")
                .build();
        
        public static final LogRecord UNICODE_ATTACK_DETECTED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(303)
                .template("Unicode normalization attack detected")
                .build();
    }
    
    public static final class ERROR {
        
        public static final LogRecord VALIDATION_FAILED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(401)
                .template("URL validation failed: %s - %s")
                .build();
    }
}
----

== Performance Optimization

=== Optimization Strategies

1. **Pre-compilation**: All patterns compiled during construction
2. **Immutable Caching**: Configuration and patterns stored in final fields
3. **Early Termination**: Stop processing on first security violation
4. **Efficient Algorithms**: Use StringBuilder, BitSet for character validation
5. **Memory Management**: Minimize string allocations

=== Performance Requirements

- Individual stage: <0.2ms per stage
- Complete pipeline: <1ms total for typical inputs (5 stages × 0.2ms)
- Memory: O(n) where n is input length
- Thread safety: No synchronization needed (immutable)
- Benchmark: 95th percentile must meet these requirements

== Usage Example

[source,java]
----
// Create base configuration with secure defaults
UrlSecurityConfig baseConfig = UrlSecurityConfig.builder()
    .maxPathLength(2048)  // Uses DEFAULT_MAX_PATH_LENGTH
    .build();

// Create specific configurations for different validation types
ConfigStageProvider pathConfig = new URLPathConfig(baseConfig);
ConfigStageProvider paramConfig = new URLParameterConfig(baseConfig);
ConfigStageProvider headerConfig = new HTTPHeaderConfig(baseConfig);

// Create unified pipelines with different configurations
SecurityEventCounter eventCounter = new SecurityEventCounter();

HttpSecurityValidator pathValidator = new UnifiedValidationPipeline(
    pathConfig,    // URL_PATH configuration
    eventCounter
);

HttpSecurityValidator paramValidator = new UnifiedValidationPipeline(
    paramConfig,   // URL_PARAMETER configuration  
    eventCounter
);

HttpSecurityValidator headerValidator = new UnifiedValidationPipeline(
    headerConfig,  // HTTP_HEADER configuration
    eventCounter
);

// Use validators - they all share the same pipeline implementation
try {
    String safePath = pathValidator.validate("/api/users/123");
    String safeParam = paramValidator.validate("search=test%20query");
    String safeHeader = headerValidator.validate("Bearer abc123");
} catch (UrlSecurityException e) {
    // Exception now includes ValidationType
    log.warn("Security violation in {}: {} - {}", 
        e.getValidationType(), 
        e.getFailureType(), 
        e.getOriginalInput());
}

// Alternative: Factory pattern for cleaner creation
public class ValidationFactory {
    
    private final @NonNull UrlSecurityConfig baseConfig;
    private final @NonNull SecurityEventCounter eventCounter;
    
    /**
     * Creates a validator for the specified type using exhaustive switch.
     * Java 21 ensures all enum cases are covered.
     */
    @NonNull
    public HttpSecurityValidator createValidator(@NonNull ValidationType type) {
        ConfigStageProvider config = switch (type) {
            case URL_PATH -> new URLPathConfig(baseConfig);
            case URL_PARAMETER -> new URLParameterConfig(baseConfig);
            case HTTP_HEADER -> new HTTPHeaderConfig(baseConfig);
            case HTTP_BODY -> new HTTPBodyConfig(baseConfig);
            case COOKIE -> new CookieConfig(baseConfig);
            // No default needed - exhaustive enum coverage
        };
        
        return new UnifiedValidationPipeline(config, eventCounter);
    }
}
----

== Security Considerations

=== Attack Coverage

- Path traversal: ../, ..\, encoded variants
- Encoding attacks: Double/triple encoding, mixed encoding
- Unicode attacks: Normalization, homographs, control characters
- Injection: XSS, SQL, LDAP, command injection patterns
- Protocol attacks: Header injection, request smuggling
- DoS: Size limits, algorithmic complexity

=== Default Security Posture

- All defaults follow maximum security (OWASP/RFC)
- No lenient modes - security by default
- Explicit overrides required for less restrictive settings
- Comprehensive logging and monitoring