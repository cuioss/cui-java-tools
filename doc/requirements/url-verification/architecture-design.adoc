= URL Security Validation Architecture and Design
:toc: left
:toclevels: 3
:sectnums:
:icons: font

link:README.adoc[← Back to Documentation Index]

[IMPORTANT]
====
This document describes HOW the URL Security Validation system architecture works.
For WHAT tasks to implement, see link:../../../plan.adoc[Implementation Plan].
For HOW to test the system, see link:test-harness-design.adoc[Test Harness Design].
====

== Executive Summary

The URL Security Validation system provides comprehensive protection against path traversal attacks, encoding bypasses, and injection attempts through a layered, immutable, high-performance architecture in the `de.cuioss.tools.security.http` package.

== Design Principles

[cols="2,3"]
|===
|Principle |Implementation

|Defense in Depth
|Sequential validation stages, each catching different attack classes

|Fail Secure
|String/throws pattern - reject on any security violation

|Secure Defaults
|Configuration constants based on OWASP/RFC with documented sources

|Immutability
|All validation stages immutable after construction for thread safety

|Performance First
|Pre-compiled patterns, optimized algorithms, <1ms requirement

|Transparency
|Structured logging via LogRecord pattern, security event counting
|===

== System Architecture

=== High-Level Architecture

----
┌─────────────────────────────────────────────────────────┐
│                    Client Request                        │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│              HttpSecurityValidator                       │
│         (Core validation interface)                      │
└─────────────────────┬───────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│              Validation Pipeline                         │
│         (Sequential stage execution)                     │
├──────────────────────────────────────────────────────────┤
│  Stage 1: LengthValidationStage                         │
│  Stage 2: CharacterValidationStage                      │
│  Stage 3: DecodingStage                                 │
│  Stage 4: NormalizationStage                            │
│  Stage 5: PatternMatchingStage                          │
└──────────────────────────────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────┐
│          Security Event Tracking                         │
│    (Counter + LogRecord based logging)                   │
└──────────────────────────────────────────────────────────┘
----

=== Package Structure

----
de.cuioss.tools.security.http/
├── HttpSecurityValidator.java         # Core validation interface
├── UrlSecurityException.java          # Main exception with failure types
├── UrlSecurityFailureType.java        # Comprehensive failure enum
├── ValidationType.java                # Input type classification
│
├── config/
│   ├── UrlSecurityConfig.java        # Base configuration with defaults
│   ├── URLConfig.java                # URL path specific config
│   ├── ParameterConfig.java          # Parameter validation config
│   ├── HeaderConfig.java             # HTTP header config
│   └── BodyConfig.java               # HTTP body validation config
│
├── security/
│   ├── SecurityEventCounter.java     # Thread-safe event counting
│   └── URLSecurityLogMessages.java   # LogRecord pattern messages
│
├── validation/
│   ├── LengthValidationStage.java    # Size limit validation (FIRST!)
│   ├── CharacterValidationStage.java # RFC character validation (SECOND!)
│   ├── DecodingStage.java            # Multi-layer decoding
│   ├── NormalizationStage.java       # Path normalization
│   └── PatternMatchingStage.java     # Attack pattern detection
│
└── pipeline/
    ├── URLPathValidationPipeline.java      # URL path pipeline
    ├── URLParameterValidationPipeline.java # Parameter pipeline
    ├── HTTPHeaderValidationPipeline.java   # Header pipeline
    ├── HTTPBodyValidationPipeline.java     # Body pipeline
    └── PipelineFactory.java                # Pipeline creation
----

== Core Components

=== Core Interfaces and Data Types

[source,java]
----
package de.cuioss.tools.security.http;

/**
 * Core interface for HTTP security validation.
 * Follows the String/throws pattern consistently.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B3]
 */
public interface HttpSecurityValidator {
    /**
     * Validates the input and returns the sanitized version.
     * @param value The input to validate
     * @return The validated/normalized value
     * @throws UrlSecurityException on any security violation
     */
    String execute(String value) throws UrlSecurityException;
    
    /**
     * @return The type of validation this validator performs
     */
    ValidationType getType();
}

/**
 * Classification of input types for appropriate validation.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B3]
 */
public enum ValidationType {
    URL_PATH,        // URL path segments
    URL_PARAMETER,   // Query parameters
    HTTP_HEADER,     // HTTP headers
    HTTP_BODY,       // Request/response bodies
    COOKIE          // HTTP cookies
}

/**
 * Comprehensive enumeration of security failure types.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B1]
 */
public enum UrlSecurityFailureType {
    // Encoding Issues
    INVALID_ENCODING("Invalid URL encoding detected"),
    DOUBLE_ENCODING("Double URL encoding detected"),
    UNICODE_NORMALIZATION_CHANGED("Unicode normalization altered input"),
    
    // Path Traversal
    PATH_TRAVERSAL_DETECTED("Path traversal pattern detected"),
    DIRECTORY_ESCAPE_ATTEMPT("Directory escape attempt detected"),
    
    // Character Issues
    INVALID_CHARACTER("Invalid character detected"),
    NULL_BYTE_INJECTION("Null byte injection detected"),
    CONTROL_CHARACTERS("Control characters detected"),
    
    // Length/Size Issues
    PATH_TOO_LONG("Path exceeds maximum length"),
    EXCESSIVE_NESTING("Excessive directory nesting"),
    
    // Pattern Matches
    SUSPICIOUS_PATTERN("Suspicious pattern detected"),
    KNOWN_ATTACK_SIGNATURE("Known attack signature detected"),
    
    // Structural Issues
    MALFORMED_INPUT("Malformed input structure"),
    INVALID_STRUCTURE("Invalid input structure"),
    
    // Protocol Issues  
    PROTOCOL_VIOLATION("Protocol specification violation"),
    RFC_VIOLATION("RFC specification violation");
    
    private final String description;
    
    UrlSecurityFailureType(String description) {
        this.description = description;
    }
}

/**
 * Main exception for security violations.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B2]
 */
public class UrlSecurityException extends RuntimeException {
    private final UrlSecurityFailureType failureType;
    private final String originalInput;
    private final String sanitizedInput;
    
    // Builder pattern for complex scenarios
    public static Builder builder() {
        return new Builder();
    }
}
----

=== Data Records

[source,java]
----
package de.cuioss.tools.security.http;

/**
 * Data records used throughout the system.
 * Implemented by: link:../../../plan.adoc#_phase_2_base_structure_and_core_components[Task B3]
 */
public record URLParameter(String key, String value) {}

public record Cookie(
    String name, 
    String value, 
    Map<String, String> attributes
) {}

public record HTTPBody(
    String contentType, 
    byte[] content
) {}
----

== Configuration Architecture

Configuration follows the embedded constants pattern from `ParserConfig`:

=== ConfigStageProvider Interface

[source,java]
----
package de.cuioss.tools.security.http.config;

/**
 * Provides factory methods for creating pre-configured validation stages.
 * This interface decouples pipelines from concrete configuration implementations.
 * All methods return HttpSecurityValidator for flexibility.
 */
public interface ConfigStageProvider {
    
    /**
     * @return Pre-configured length validation stage
     */
    HttpSecurityValidator getLengthValidationStage();
    
    /**
     * @return Pre-configured character validation stage for URL paths
     */
    HttpSecurityValidator getPathCharacterValidationStage();
    
    /**
     * @return Pre-configured character validation stage for URL parameters
     */
    HttpSecurityValidator getParameterCharacterValidationStage();
    
    /**
     * @return Pre-configured character validation stage for HTTP headers
     */
    HttpSecurityValidator getHeaderCharacterValidationStage();
    
    /**
     * @return Pre-configured decoding stage with security checks
     */
    HttpSecurityValidator getDecodingStage();
    
    /**
     * @return Pre-configured normalization stage
     */
    HttpSecurityValidator getNormalizationStage();
    
    /**
     * @return Pre-configured pattern matching stage
     */
    HttpSecurityValidator getPatternMatchingStage();
}
----

=== UrlSecurityConfig Implementation

[source,java]
----
package de.cuioss.tools.security.http.config;

import lombok.Builder;
import lombok.Value;

/**
 * Base configuration for URL security validation.
 * All defaults are based on OWASP guidelines and RFC specifications.
 * Implements ConfigStageProvider to provide factory methods for validation stages.
 * Implemented by: link:../../../plan.adoc#_phase_3_configuration_system[Tasks C1-C2]
 */
@Builder
@Value
public class UrlSecurityConfig implements ConfigStageProvider {
    
    /**
     * Maximum URL path length in characters.
     * Default: 2048 based on RFC 3986 Section 3.3 and common browser limits.
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-3.3">RFC 3986</a>
     * @see <a href="https://owasp.org/www-community/vulnerabilities/Buffer_Overflow">OWASP Buffer Overflow</a>
     */
    public static final int DEFAULT_MAX_PATH_LENGTH = 2048;
    
    /**
     * Maximum directory traversal depth.
     * Default: 10 based on typical filesystem depth and OWASP recommendations.
     * @see <a href="https://owasp.org/www-community/attacks/Path_Traversal">OWASP Path Traversal</a>
     */
    public static final int DEFAULT_MAX_DIRECTORY_DEPTH = 10;
    
    /**
     * Maximum parameter value length.
     * Default: 4096 based on common server configurations.
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.1">RFC 7230</a>
     */
    public static final int DEFAULT_MAX_PARAMETER_LENGTH = 4096;
    
    /**
     * Maximum number of parameters.
     * Default: 100 to prevent parameter pollution attacks.
     * @see <a href="https://owasp.org/www-community/attacks/HTTP_Parameter_Pollution">OWASP HPP</a>
     */
    public static final int DEFAULT_MAX_PARAMETER_COUNT = 100;
    
    /**
     * Enable Unicode normalization (NFC).
     * Default: true per OWASP guidelines for Unicode security.
     * @see <a href="https://owasp.org/www-community/attacks/Unicode_Encoding">OWASP Unicode</a>
     */
    public static final boolean DEFAULT_UNICODE_NORMALIZATION = true;
    
    /**
     * Reject null bytes in input.
     * Default: true to prevent null byte injection attacks.
     * @see <a href="https://owasp.org/www-community/attacks/Null_Byte_Injection">OWASP Null Byte</a>
     */
    public static final boolean DEFAULT_REJECT_NULL_BYTES = true;
    
    @Builder.Default
    int maxPathLength = DEFAULT_MAX_PATH_LENGTH;
    
    @Builder.Default
    int maxDirectoryDepth = DEFAULT_MAX_DIRECTORY_DEPTH;
    
    @Builder.Default
    int maxParameterLength = DEFAULT_MAX_PARAMETER_LENGTH;
    
    @Builder.Default
    int maxParameterCount = DEFAULT_MAX_PARAMETER_COUNT;
    
    @Builder.Default
    boolean unicodeNormalization = DEFAULT_UNICODE_NORMALIZATION;
    
    @Builder.Default
    boolean rejectNullBytes = DEFAULT_REJECT_NULL_BYTES;
    
    // Cached stage instances - created once, reused everywhere
    @Getter(lazy = true)
    private final LengthValidationStage lengthValidationStage = 
        new LengthValidationStage(this);
    
    @Getter(lazy = true)
    private final CharacterValidationStage pathCharacterValidationStage = 
        new CharacterValidationStage(this, ValidationType.URL_PATH);
    
    @Getter(lazy = true)
    private final CharacterValidationStage parameterCharacterValidationStage = 
        new CharacterValidationStage(this, ValidationType.URL_PARAMETER);
    
    @Getter(lazy = true)
    private final CharacterValidationStage headerCharacterValidationStage = 
        new CharacterValidationStage(this, ValidationType.HTTP_HEADER);
    
    @Getter(lazy = true)
    private final DecodingStage decodingStage = 
        new DecodingStage(this);
    
    @Getter(lazy = true)
    private final NormalizationStage normalizationStage = 
        new NormalizationStage(this);
    
    @Getter(lazy = true)
    private final PatternMatchingStage patternMatchingStage = 
        new PatternMatchingStage(this);
    
    // ConfigStageProvider implementation methods
    @Override
    public HttpSecurityValidator getLengthValidationStage() {
        return lengthValidationStage;
    }
    
    @Override
    public HttpSecurityValidator getPathCharacterValidationStage() {
        return pathCharacterValidationStage;
    }
    
    @Override
    public HttpSecurityValidator getParameterCharacterValidationStage() {
        return parameterCharacterValidationStage;
    }
    
    @Override
    public HttpSecurityValidator getHeaderCharacterValidationStage() {
        return headerCharacterValidationStage;
    }
    
    @Override
    public HttpSecurityValidator getDecodingStage() {
        return decodingStage;
    }
    
    @Override
    public HttpSecurityValidator getNormalizationStage() {
        return normalizationStage;
    }
    
    @Override
    public HttpSecurityValidator getPatternMatchingStage() {
        return patternMatchingStage;
    }
}
----

== Validation Stages

All validation stages follow these principles:

1. **Immutability**: Configuration stored in final fields, no runtime state changes
2. **Performance**: Pre-compiled patterns, optimized algorithms, <1ms per stage
3. **Thread Safety**: No mutable state, safe for concurrent use
4. **Clear Contracts**: String input/output with UrlSecurityException on violations

=== LengthValidationStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

/**
 * Length validation MUST be the first stage to prevent DoS attacks.
 * Rejects oversized inputs before any processing.
 * Immutable and thread-safe.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V4]
 */
public final class LengthValidationStage implements HttpSecurityValidator {
    
    private final int maxLength;
    private final int maxDepth;
    
    public LengthValidationStage(UrlSecurityConfig config) {
        this.maxLength = config.getMaxPathLength();
        this.maxDepth = config.getMaxDirectoryDepth();
    }
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        // First check: total length
        if (value.length() > maxLength) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.PATH_TOO_LONG)
                .originalInput(value)
                .build();
        }
        
        // Second check: nesting depth
        long depth = value.chars().filter(ch -> ch == '/' || ch == '\\').count();
        if (depth > maxDepth) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.EXCESSIVE_NESTING)
                .originalInput(value)
                .build();
        }
        
        return value;
    }
    
    @Override
    public ValidationType getType() {
        return ValidationType.URL_PATH;
    }
}
----

=== DecodingStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import java.text.Normalizer;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

/**
 * Multi-layer decoding with security checks.
 * Immutable and thread-safe.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V1]
 */
public final class DecodingStage implements HttpSecurityValidator {
    
    private final UrlSecurityConfig config;
    private final Pattern doubleEncodingPattern;
    
    public DecodingStage(UrlSecurityConfig config) {
        this.config = config;
        // Pre-compile patterns for performance
        this.doubleEncodingPattern = Pattern.compile("%25[0-9a-fA-F]{2}");
    }
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        // Detect double encoding before decoding
        if (doubleEncodingPattern.matcher(value).find()) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.DOUBLE_ENCODING)
                .originalInput(value)
                .build();
        }
        
        // URL decode
        String decoded;
        try {
            decoded = URLDecoder.decode(value, StandardCharsets.UTF_8);
        } catch (IllegalArgumentException e) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.INVALID_ENCODING)
                .originalInput(value)
                .cause(e)
                .build();
        }
        
        // Unicode normalization with change detection
        if (config.isUnicodeNormalization()) {
            String normalized = Normalizer.normalize(decoded, Normalizer.Form.NFC);
            if (!decoded.equals(normalized)) {
                // Normalization changed the string - potential attack
                throw UrlSecurityException.builder()
                    .failureType(UrlSecurityFailureType.UNICODE_NORMALIZATION_CHANGED)
                    .originalInput(value)
                    .sanitizedInput(normalized)
                    .build();
            }
            decoded = normalized;
        }
        
        // Note: Null byte detection moved to CharacterValidationStage for earlier detection
        
        return decoded;
    }
    
    @Override
    public ValidationType getType() {
        return ValidationType.URL_PATH;
    }
}
----

=== CharacterValidationStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import java.util.BitSet;

/**
 * Validates characters according to RFC 3986 for URLs.
 * MUST be the second stage after length validation.
 * Rejects invalid characters BEFORE any decoding/processing.
 * Immutable and thread-safe.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V5]
 */
public final class CharacterValidationStage implements HttpSecurityValidator {
    
    // RFC 3986 unreserved characters: ALPHA / DIGIT / "-" / "." / "_" / "~"
    // RFC 3986 reserved characters: gen-delims / sub-delims
    // gen-delims: ":" / "/" / "?" / "#" / "[" / "]" / "@"
    // sub-delims: "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
    // pct-encoded: "%" HEXDIG HEXDIG
    
    private final BitSet allowedChars;
    private final ValidationType validationType;
    private final boolean allowPercentEncoding;
    
    public CharacterValidationStage(UrlSecurityConfig config, ValidationType type) {
        this.validationType = type;
        this.allowedChars = new BitSet(256);
        
        // Initialize allowed characters based on type
        switch (type) {
            case URL_PATH -> {
                // RFC 3986 path characters
                addUnreservedChars();  // A-Z, a-z, 0-9, -, ., _, ~
                addPathChars();        // /, @, :, !, $, &, ', (, ), *, +, ,, ;, =
                this.allowPercentEncoding = true;
            }
            case URL_PARAMETER -> {
                // Query string characters
                addUnreservedChars();
                addQueryChars();       // All sub-delims plus ? and &
                this.allowPercentEncoding = true;
            }
            case HTTP_HEADER -> {
                // RFC 7230 header field characters
                addVisibleASCII();     // ASCII 33-126 except delimiters
                this.allowPercentEncoding = false;
            }
            default -> {
                // Most restrictive set
                addUnreservedChars();
                this.allowPercentEncoding = false;
            }
        }
    }
    
    private void addUnreservedChars() {
        // ALPHA
        for (int i = 'A'; i <= 'Z'; i++) allowedChars.set(i);
        for (int i = 'a'; i <= 'z'; i++) allowedChars.set(i);
        // DIGIT
        for (int i = '0'; i <= '9'; i++) allowedChars.set(i);
        // "-" / "." / "_" / "~"
        allowedChars.set('-');
        allowedChars.set('.');
        allowedChars.set('_');
        allowedChars.set('~');
    }
    
    private void addPathChars() {
        // Path-specific characters
        allowedChars.set('/');
        allowedChars.set('@');
        allowedChars.set(':');
        // sub-delims for path
        "!$&'()*+,;=".chars().forEach(allowedChars::set);
    }
    
    private void addQueryChars() {
        // Query-specific characters
        allowedChars.set('?');
        allowedChars.set('&');
        allowedChars.set('=');
        // sub-delims for query
        "!$'()*+,;".chars().forEach(allowedChars::set);
    }
    
    private void addVisibleASCII() {
        // RFC 7230: VCHAR = %x21-7E (visible ASCII)
        for (int i = 33; i <= 126; i++) {
            // Exclude HTTP delimiters
            if (!"\"(),/:;<=>?@[\\]{}".contains(String.valueOf((char)i))) {
                allowedChars.set(i);
            }
        }
        allowedChars.set(' '); // Space is allowed in headers
    }
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        // Quick check for null/empty
        if (value == null || value.isEmpty()) {
            return value;
        }
        
        // Check each character
        for (int i = 0; i < value.length(); i++) {
            char ch = value.charAt(i);
            
            // Check for null byte FIRST (highest priority security check)
            if (ch == '\0') {
                throw UrlSecurityException.builder()
                    .failureType(UrlSecurityFailureType.NULL_BYTE_INJECTION)
                    .originalInput(value)
                    .detail("Null byte detected at position " + i)
                    .build();
            }
            
            // Handle percent encoding
            if (ch == '%' && allowPercentEncoding) {
                // Must be followed by two hex digits
                if (i + 2 >= value.length()) {
                    throw UrlSecurityException.builder()
                        .failureType(UrlSecurityFailureType.INVALID_ENCODING)
                        .originalInput(value)
                        .detail("Incomplete percent encoding at position " + i)
                        .build();
                }
                
                char hex1 = value.charAt(i + 1);
                char hex2 = value.charAt(i + 2);
                if (!isHexDigit(hex1) || !isHexDigit(hex2)) {
                    throw UrlSecurityException.builder()
                        .failureType(UrlSecurityFailureType.INVALID_ENCODING)
                        .originalInput(value)
                        .detail("Invalid hex digits in percent encoding at position " + i)
                        .build();
                }
                
                // Check for encoded null byte %00
                if (hex1 == '0' && hex2 == '0') {
                    throw UrlSecurityException.builder()
                        .failureType(UrlSecurityFailureType.NULL_BYTE_INJECTION)
                        .originalInput(value)
                        .detail("Encoded null byte (%00) detected at position " + i)
                        .build();
                }
                
                i += 2; // Skip the two hex digits
                continue;
            }
            
            // Check if character is allowed
            if (ch > 255 || !allowedChars.get(ch)) {
                throw UrlSecurityException.builder()
                    .failureType(UrlSecurityFailureType.INVALID_CHARACTER)
                    .originalInput(value)
                    .detail(String.format("Invalid character '%c' (0x%02X) at position %d", 
                                        ch, (int)ch, i))
                    .build();
            }
        }
        
        return value;
    }
    
    private boolean isHexDigit(char ch) {
        return (ch >= '0' && ch <= '9') || 
               (ch >= 'A' && ch <= 'F') || 
               (ch >= 'a' && ch <= 'f');
    }
    
    @Override
    public ValidationType getType() {
        return validationType;
    }
}
----

=== NormalizationStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

import java.nio.file.Paths;

/**
 * Path normalization stage to resolve . and .. segments.
 * Follows RFC 3986 Section 5.2.4 for path normalization.
 * Immutable and thread-safe.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V2]
 */
public final class NormalizationStage implements HttpSecurityValidator {
    
    private final UrlSecurityConfig config;
    
    public NormalizationStage(UrlSecurityConfig config) {
        this.config = config;
    }
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        if (value == null || value.isEmpty()) {
            return value;
        }
        
        // Save original for comparison
        String original = value;
        
        // Normalize path segments (resolve . and ..)
        String normalized = normalizePath(value);
        
        // Check if normalization revealed path traversal
        if (containsPathTraversal(normalized)) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED)
                .originalInput(original)
                .sanitizedInput(normalized)
                .detail("Path normalization revealed traversal attempt")
                .build();
        }
        
        // Check if path escapes root after normalization
        if (escapesRoot(normalized)) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.DIRECTORY_ESCAPE_ATTEMPT)
                .originalInput(original)
                .sanitizedInput(normalized)
                .detail("Path attempts to escape root directory")
                .build();
        }
        
        return normalized;
    }
    
    private String normalizePath(String path) {
        // RFC 3986 path segment normalization
        String[] segments = path.split("/", -1);
        StringBuilder result = new StringBuilder();
        int depth = 0;
        
        for (String segment : segments) {
            if (".".equals(segment)) {
                // Current directory - skip
                continue;
            } else if ("..".equals(segment)) {
                // Parent directory
                if (result.length() > 0) {
                    // Remove last segment
                    int lastSlash = result.lastIndexOf("/");
                    if (lastSlash >= 0) {
                        result.setLength(lastSlash);
                        depth--;
                    }
                } else {
                    // Trying to go above root
                    depth--;
                }
            } else if (!segment.isEmpty()) {
                // Normal segment
                if (result.length() > 0 || path.startsWith("/")) {
                    result.append("/");
                }
                result.append(segment);
                depth++;
            }
        }
        
        // Check depth limit
        if (depth > config.getMaxDirectoryDepth()) {
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.EXCESSIVE_NESTING)
                .originalInput(path)
                .detail("Path depth " + depth + " exceeds maximum " + config.getMaxDirectoryDepth())
                .build();
        }
        
        // Preserve trailing slash if present
        if (path.endsWith("/") && !result.toString().endsWith("/")) {
            result.append("/");
        }
        
        return result.toString();
    }
    
    private boolean containsPathTraversal(String path) {
        // After normalization, there should be no .. segments
        return path.contains("../") || path.contains("..\\") || path.equals("..");
    }
    
    private boolean escapesRoot(String path) {
        // Check if normalized path tries to escape root
        return path.startsWith("../") || path.startsWith("..\\");
    }
    
    @Override
    public ValidationType getType() {
        return ValidationType.URL_PATH;
    }
}
----

=== PatternMatchingStage

[source,java]
----
package de.cuioss.tools.security.http.validation;

/**
 * Pattern-based attack detection using pre-compiled patterns.
 * Immutable and optimized for performance.
 * Implemented by: link:../../../plan.adoc#_phase_5_validation_stages[Task V3]
 */
public final class PatternMatchingStage implements HttpSecurityValidator {
    
    // Pre-compiled patterns stored in final fields
    private final Pattern pathTraversalPattern;
    private final Pattern windowsTraversalPattern;
    private final Pattern encodedTraversalPattern;
    
    public PatternMatchingStage(UrlSecurityConfig config) {
        // Compile all patterns during construction
        this.pathTraversalPattern = Pattern.compile(
            "(?:^|/)\\.\\.(?:/|$)"
        );
        this.windowsTraversalPattern = Pattern.compile(
            "(?:^|\\\\)\\.\\.(?:\\\\|$)"
        );
        this.encodedTraversalPattern = Pattern.compile(
            "%(?:2e|2E)%(?:2e|2E)"
        );
    }
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        // Check all patterns efficiently
        if (pathTraversalPattern.matcher(value).find() ||
            windowsTraversalPattern.matcher(value).find() ||
            encodedTraversalPattern.matcher(value).find()) {
            
            throw UrlSecurityException.builder()
                .failureType(UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED)
                .originalInput(value)
                .build();
        }
        
        return value;
    }
}
----

== Pipeline Architecture

=== Sequential Execution Model

Pipelines execute validation stages sequentially with early termination:

[source,java]
----
package de.cuioss.tools.security.http.pipeline;

import java.util.List;

/**
 * URL path validation pipeline.
 * Uses ConfigStageProvider interface for dependency injection.
 * Implemented by: link:../../../plan.adoc#_phase_6_pipeline_implementation[Task P1]
 */
public final class URLPathValidationPipeline implements HttpSecurityValidator {
    
    private final List<HttpSecurityValidator> stages;
    private final SecurityEventCounter eventCounter;
    
    public URLPathValidationPipeline(ConfigStageProvider stageProvider, 
                                    SecurityEventCounter eventCounter) {
        // Get individual stages from provider in correct order
        // Order is critical: Length first, then Character validation BEFORE processing
        this.stages = List.of(
            stageProvider.getLengthValidationStage(),          // First: prevent DoS
            stageProvider.getPathCharacterValidationStage(),   // Second: RFC path validation
            stageProvider.getDecodingStage(),                  // Third: decode input
            stageProvider.getNormalizationStage(),             // Fourth: normalize paths
            stageProvider.getPatternMatchingStage()            // Fifth: detect attacks
        );
        this.eventCounter = eventCounter;
    }
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        String result = value;
        
        // Sequential execution with early termination
        for (HttpSecurityValidator stage : stages) {
            try {
                result = stage.execute(result);
            } catch (UrlSecurityException e) {
                // Track security event
                eventCounter.increment(e.getFailureType());
                // Log via URLSecurityLogMessages
                logSecurityEvent(e);
                // Re-throw for caller
                throw e;
            }
        }
        
        return result;
    }
    
    @Override
    public ValidationType getType() {
        return ValidationType.URL_PATH;
    }
}

/**
 * URL parameter validation pipeline.
 * Uses ConfigStageProvider but skips normalization stage.
 * Implemented by: link:../../../plan.adoc#_phase_6_pipeline_implementation[Task P2]
 */
public final class URLParameterValidationPipeline implements HttpSecurityValidator {
    
    private final List<HttpSecurityValidator> stages;
    private final SecurityEventCounter eventCounter;
    
    public URLParameterValidationPipeline(ConfigStageProvider stageProvider,
                                         SecurityEventCounter eventCounter) {
        // Parameters: validate chars before decoding, skip normalization
        this.stages = List.of(
            stageProvider.getLengthValidationStage(),
            stageProvider.getParameterCharacterValidationStage(),
            stageProvider.getDecodingStage(),
            stageProvider.getPatternMatchingStage()
        );
        this.eventCounter = eventCounter;
    }
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        String result = value;
        for (HttpSecurityValidator stage : stages) {
            try {
                result = stage.execute(result);
            } catch (UrlSecurityException e) {
                eventCounter.increment(e.getFailureType());
                throw e;
            }
        }
        return result;
    }
    
    @Override
    public ValidationType getType() {
        return ValidationType.URL_PARAMETER;
    }
}

/**
 * HTTP header validation pipeline.
 * Uses ConfigStageProvider but only needs subset of stages.
 * Implemented by: link:../../../plan.adoc#_phase_6_pipeline_implementation[Task P3]
 */
public final class HTTPHeaderValidationPipeline implements HttpSecurityValidator {
    
    private final List<HttpSecurityValidator> stages;
    private final SecurityEventCounter eventCounter;
    
    public HTTPHeaderValidationPipeline(ConfigStageProvider stageProvider,
                                       SecurityEventCounter eventCounter) {
        // Headers: validate RFC 7230 chars first, no decoding/normalization needed
        this.stages = List.of(
            stageProvider.getLengthValidationStage(),
            stageProvider.getHeaderCharacterValidationStage(),
            stageProvider.getPatternMatchingStage()
        );
        this.eventCounter = eventCounter;
    }
    
    @Override
    public String execute(String value) throws UrlSecurityException {
        String result = value;
        for (HttpSecurityValidator stage : stages) {
            try {
                result = stage.execute(result);
            } catch (UrlSecurityException e) {
                eventCounter.increment(e.getFailureType());
                throw e;
            }
        }
        return result;
    }
    
    @Override
    public ValidationType getType() {
        return ValidationType.HTTP_HEADER;
    }
}
----

== Security Event Tracking

=== Event Counter Pattern

[source,java]
----
package de.cuioss.tools.security.http.security;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Thread-safe security event counter.
 * Tracks occurrences of each UrlSecurityFailureType.
 * Implemented by: link:../../../plan.adoc#_phase_4_security_tracking_and_monitoring[Task S1]
 */
public class SecurityEventCounter {
    
    private final ConcurrentHashMap<UrlSecurityFailureType, AtomicLong> counters = 
        new ConcurrentHashMap<>();
    
    /**
     * Increment counter for a failure type.
     * @return new count value
     */
    public long increment(UrlSecurityFailureType type) {
        return counters.computeIfAbsent(type, k -> new AtomicLong(0))
                      .incrementAndGet();
    }
    
    /**
     * Get current count for a failure type.
     */
    public long getCount(UrlSecurityFailureType type) {
        AtomicLong counter = counters.get(type);
        return counter != null ? counter.get() : 0;
    }
}
----

=== Structured Logging

[source,java]
----
package de.cuioss.tools.security.http.security;

import de.cuioss.tools.logging.LogRecord;
import de.cuioss.tools.logging.LogRecordModel;

/**
 * Structured log messages for URL security events.
 * Follows cui-jwt-validation LogRecord pattern.
 * Implemented by: link:../../../plan.adoc#_phase_4_security_tracking_and_monitoring[Task S2]
 */
public final class URLSecurityLogMessages {
    
    private static final String PREFIX = "URLSecurity";
    
    public static final class WARN {
        
        public static final LogRecord PATH_TRAVERSAL_DETECTED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(301)
                .template("Path traversal attempt detected: %s")
                .build();
        
        public static final LogRecord DOUBLE_ENCODING_DETECTED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(302)
                .template("Double encoding attack detected: %s")
                .build();
        
        public static final LogRecord UNICODE_ATTACK_DETECTED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(303)
                .template("Unicode normalization attack detected")
                .build();
    }
    
    public static final class ERROR {
        
        public static final LogRecord VALIDATION_FAILED = 
            LogRecordModel.builder()
                .prefix(PREFIX)
                .identifier(401)
                .template("URL validation failed: %s - %s")
                .build();
    }
}
----

== Performance Optimization

=== Optimization Strategies

1. **Pre-compilation**: All patterns compiled during construction
2. **Immutable Caching**: Configuration and patterns stored in final fields
3. **Early Termination**: Stop processing on first security violation
4. **Efficient Algorithms**: Use StringBuilder, BitSet for character validation
5. **Memory Management**: Minimize string allocations

=== Performance Requirements

- Individual stage: <0.2ms per stage
- Complete pipeline: <1ms total for typical inputs (5 stages × 0.2ms)
- Memory: O(n) where n is input length
- Thread safety: No synchronization needed (immutable)
- Benchmark: 95th percentile must meet these requirements

== Usage Example

[source,java]
----
// Create configuration with secure defaults
UrlSecurityConfig config = UrlSecurityConfig.builder()
    .maxPathLength(2048)  // Uses DEFAULT_MAX_PATH_LENGTH
    .build();

// Create pipeline using ConfigStageProvider interface
HttpSecurityValidator validator = new URLPathValidationPipeline(
    config,  // UrlSecurityConfig implements ConfigStageProvider
    new SecurityEventCounter()
);

// Validate input
try {
    String safe = validator.execute(userInput);
    // Use validated input
} catch (UrlSecurityException e) {
    // Handle security violation
    log.warn(URLSecurityLogMessages.WARN.PATH_TRAVERSAL_DETECTED, 
             e.getOriginalInput());
}

// Different pipelines can use the same config provider
HttpSecurityValidator paramValidator = new URLParameterValidationPipeline(
    config,  // Same config, different stage selection
    new SecurityEventCounter()
);

HttpSecurityValidator headerValidator = new HTTPHeaderValidationPipeline(
    config,  // Same config, minimal stages
    new SecurityEventCounter()
);
----

== Security Considerations

=== Attack Coverage

- Path traversal: ../, ..\, encoded variants
- Encoding attacks: Double/triple encoding, mixed encoding
- Unicode attacks: Normalization, homographs, control characters
- Injection: XSS, SQL, LDAP, command injection patterns
- Protocol attacks: Header injection, request smuggling
- DoS: Size limits, algorithmic complexity

=== Default Security Posture

- All defaults follow maximum security (OWASP/RFC)
- No lenient modes - security by default
- Explicit overrides required for less restrictive settings
- Comprehensive logging and monitoring