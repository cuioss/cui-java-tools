/*
 * Copyright Â© 2025 CUI-OpenSource-Software (info@cuioss.de)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.cuioss.tools.security.http.tests;

import de.cuioss.test.generator.junit.EnableGeneratorController;
import de.cuioss.test.generator.junit.parameterized.TypeGeneratorSource;
import de.cuioss.tools.security.http.config.SecurityConfiguration;
import de.cuioss.tools.security.http.core.UrlSecurityFailureType;
import de.cuioss.tools.security.http.exceptions.UrlSecurityException;
import de.cuioss.tools.security.http.generators.injection.IPv6AddressAttackGenerator;
import de.cuioss.tools.security.http.monitoring.SecurityEventCounter;
import de.cuioss.tools.security.http.pipeline.URLPathValidationPipeline;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;

import static org.junit.jupiter.api.Assertions.*;

/**
 * T22: Test IPv6 address attacks
 * 
 * <p>
 * This test class implements Task T22 from the HTTP security validation plan,
 * focusing on testing IPv6 address-based attack patterns that can bypass
 * URL validation and security controls.
 * </p>
 * 
 * <h3>Test Coverage</h3>
 * <ul>
 *   <li>IPv6 address spoofing attacks</li>
 *   <li>IPv4-mapped IPv6 addresses for bypass</li>
 *   <li>IPv6 address confusion attacks</li>
 *   <li>Malformed IPv6 addresses</li>
 *   <li>IPv6 scope identifier abuse</li>
 *   <li>IPv6 URL parsing vulnerabilities</li>
 *   <li>IPv6 bracket escaping attacks</li>
 *   <li>IPv6 compression abuse patterns</li>
 * </ul>
 * 
 * <h3>Validation Expectations</h3>
 * <ul>
 *   <li>All malicious IPv6 patterns should be <strong>REJECTED</strong></li>
 *   <li>Security events should be properly recorded</li>
 *   <li>Appropriate failure types should be identified</li>
 *   <li>Original inputs should be preserved in exceptions</li>
 * </ul>
 * 
 * <h3>Security Standards</h3>
 * <ul>
 *   <li>RFC 4291: IPv6 Addressing Architecture</li>
 *   <li>RFC 3986: URI Generic Syntax with IPv6</li>
 *   <li>OWASP IPv6 Security Guidelines</li>
 *   <li>CVE-2019-14287, CVE-2020-8597, CVE-2021-22205</li>
 * </ul>
 * 
 * Implements: Task T22 from HTTP verification specification
 * 
 * @author Claude Code Generator
 * @since 2.5
 */
@EnableGeneratorController
@DisplayName("T22: IPv6 Address Attack Tests")
class IPv6AddressAttackTest {

    private URLPathValidationPipeline pipeline;
    private SecurityEventCounter eventCounter;
    private SecurityConfiguration config;

    @BeforeEach
    void setUp() {
        config = SecurityConfiguration.defaults();
        eventCounter = new SecurityEventCounter();
        pipeline = new URLPathValidationPipeline(config, eventCounter);
    }

    /**
     * Test all IPv6 attack patterns generated by IPv6AddressAttackGenerator.
     * 
     * <p>
     * Tests various IPv6 attack patterns including address spoofing,
     * IPv4-mapping abuse, malformed addresses, and parsing vulnerabilities.
     * </p>
     * 
     * @param ipv6AttackPattern A malicious IPv6 address pattern
     */
    @ParameterizedTest
    @TypeGeneratorSource(value = IPv6AddressAttackGenerator.class, count = 64)
    @DisplayName("All IPv6 attack patterns should be rejected")
    void shouldRejectAllIPv6AttackPatterns(String ipv6AttackPattern) {
        // Given: An IPv6 attack pattern from the generator
        long initialEventCount = eventCounter.getTotalCount();

        // When: Attempting to validate the malicious IPv6 pattern
        var exception = assertThrows(UrlSecurityException.class,
                () -> pipeline.validate(ipv6AttackPattern),
                "IPv6 attack pattern should be rejected: " + ipv6AttackPattern);

        // Then: The validation should fail with appropriate security event
        assertNotNull(exception, "Exception should be thrown for IPv6 attack");
        assertTrue(isIPv6SpecificFailure(exception.getFailureType(), ipv6AttackPattern),
                "Failure type should be IPv6 specific: " + exception.getFailureType() + " for pattern: " + ipv6AttackPattern);

        // And: Original malicious input should be preserved
        assertEquals(ipv6AttackPattern, exception.getOriginalInput(),
                "Original input should be preserved in exception");

        // And: Security event should be recorded
        assertTrue(eventCounter.getTotalCount() > initialEventCount,
                "Security event should be recorded");
    }

    /**
     * Test specific high-risk IPv6 attack patterns.
     * 
     * <p>
     * This test ensures that the most dangerous IPv6 attack patterns
     * are consistently blocked.
     * </p>
     */
    @Test
    @DisplayName("Known IPv6 attack patterns should be blocked")
    void shouldBlockKnownIPv6AttackPatterns() {
        String[] ipv6AttackPatterns = {
                // IPv4-mapped IPv6 bypass attempts
                "[::ffff:127.0.0.1]/../../etc/passwd",
                "[::ffff:0:0.0.0.0]/admin",
                "http://[::ffff:192.168.1.1]/../config",

                // IPv6 address confusion
                "[::1]:8080/../../etc/passwd",
                "[2001:db8::1]:80/../admin/config",
                "http://[::]:80/../../etc/hosts",

                // Malformed IPv6 addresses for parser confusion
                "[:::1]/admin",
                "[2001:db8:::1]/config",
                "[::g]/../../etc/passwd",
                "[2001:zzzz::1]/admin",

                // IPv6 scope identifier abuse
                "[fe80::1%eth0]/../../../etc/passwd",
                "[::1%lo0]/admin/../../config",
                "[2001:db8::1%999]/../sensitive",

                // IPv6 bracket escaping attempts
                "http://[2001:db8::1]]/../etc/passwd",
                "[2001:db8::1[/../admin",
                "http://]2001:db8::1[/../../config",

                // IPv6 compression abuse
                "[::::::1]/../../etc/passwd",
                "[2001::::::db8]/admin",
                "[::::::::]/../config"
        };

        for (String pattern : ipv6AttackPatterns) {
            long initialEventCount = eventCounter.getTotalCount();

            var exception = assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(pattern),
                    "IPv6 attack pattern should be blocked: " + pattern);

            assertNotNull(exception.getFailureType(),
                    "Failure type should be specified for IPv6 pattern: " + pattern);

            assertTrue(eventCounter.getTotalCount() > initialEventCount,
                    "Security event should be recorded for IPv6 pattern: " + pattern);
        }
    }

    /**
     * Test IPv6 patterns that attempt to bypass localhost restrictions.
     * 
     * <p>
     * Ensures that IPv6 patterns designed to bypass localhost/loopback
     * security controls are properly detected and blocked.
     * </p>
     */
    @Test
    @DisplayName("IPv6 localhost bypass attempts should be blocked")
    void shouldBlockIPv6LocalhostBypassAttempts() {
        String[] localhostBypassPatterns = {
                // Various IPv6 representations of localhost
                "[::1]/../../etc/passwd",
                "[0:0:0:0:0:0:0:1]/admin/../../config",
                "[::0001]/../../etc/hosts",

                // IPv4-mapped localhost variants
                "[::ffff:127.0.0.1]/../../etc/passwd",
                "[::ffff:7f00:1]/admin",
                "[64:ff9b::7f00:1]/../../config",

                // Compressed forms
                "[::1:0:0:1]/../../etc/passwd",
                "[::127.0.0.1]/admin"
        };

        for (String pattern : localhostBypassPatterns) {
            assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(pattern),
                    "IPv6 localhost bypass should be blocked: " + pattern);
        }
    }

    /**
     * Test IPv6 patterns with embedded path traversal.
     * 
     * <p>
     * Validates that path traversal attempts are detected even when
     * embedded within IPv6 URL structures.
     * </p>
     */
    @Test
    @DisplayName("IPv6 with embedded path traversal should be blocked")
    void shouldBlockIPv6WithPathTraversal() {
        String[] ipv6PathTraversalPatterns = {
                "http://[2001:db8::1]/../../../etc/passwd",
                "[::1]:8080/../../admin/config.xml",
                "https://[fe80::1]/api/../../../etc/hosts",
                "[2001:db8::1]/uploads/../../etc/shadow",
                "http://[::ffff:10.0.0.1]/files/..\\..\\windows\\win.ini"
        };

        for (String pattern : ipv6PathTraversalPatterns) {
            assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(pattern),
                    "IPv6 path traversal should be blocked: " + pattern);
        }
    }

    /**
     * Test IPv6 URL parsing edge cases that could bypass validation.
     * 
     * <p>
     * Ensures that malformed or edge-case IPv6 URLs that could confuse
     * parsers are properly handled.
     * </p>
     */
    @Test
    @DisplayName("IPv6 URL parsing edge cases should be handled securely")
    void shouldHandleIPv6ParsingEdgeCasesSecurely() {
        String[] parsingEdgeCases = {
                // Multiple colons in wrong places
                "[2001::db8::1]/admin",
                "[:::2001:db8::1]/config",
                "[2001:db8::1:::]/sensitive",

                // Invalid characters in IPv6
                "[2001:db8::g1]/admin",
                "[2001:xy8::1]/config",
                "[2001:db8::1z]/sensitive",

                // Bracket mismatches
                "2001:db8::1]/admin",
                "[2001:db8::1/config",
                "[[2001:db8::1]]/sensitive",

                // Port confusion
                "[::1:80]/admin",
                "[2001:db8::1]:abc/config",
                "[::1]:-80/sensitive"
        };

        for (String edgeCase : parsingEdgeCases) {
            assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(edgeCase),
                    "IPv6 parsing edge case should be blocked: " + edgeCase);
        }
    }

    /**
     * Test that security events are properly categorized for different IPv6 attack types.
     */
    @Test
    @DisplayName("Different IPv6 attack types should generate appropriate security events")
    void shouldCategorizeIPv6SecurityEventsCorrectly() {
        // Test invalid IPv6 format
        assertThrows(UrlSecurityException.class, () -> pipeline.validate("[:::1]/admin"));

        // Test IPv6 with path traversal
        assertThrows(UrlSecurityException.class, () -> pipeline.validate("[::1]/../../etc/passwd"));

        // Test malformed IPv6
        assertThrows(UrlSecurityException.class, () -> pipeline.validate("[2001:gggg::1]/admin"));

        // At least one security event should be recorded
        assertTrue(eventCounter.getTotalCount() > 0,
                "At least one security event should be recorded for IPv6 attacks");
    }

    /**
     * Test performance impact of IPv6 validation.
     * 
     * <p>
     * Ensures that validation performance remains acceptable even
     * when processing complex IPv6 attack patterns.
     * </p>
     */
    @Test
    @DisplayName("IPv6 validation should maintain performance")
    void shouldMaintainPerformanceWithIPv6Attacks() {
        String complexIPv6Pattern = "[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:8080/../../../../../../../../../../etc/passwd";

        // Warm up
        for (int i = 0; i < 10; i++) {
            try {
                pipeline.validate(complexIPv6Pattern);
            } catch (UrlSecurityException ignored) {
                // Expected for malicious pattern
            }
        }

        // Measure performance
        long startTime = System.nanoTime();
        for (int i = 0; i < 100; i++) {
            try {
                pipeline.validate(complexIPv6Pattern);
            } catch (UrlSecurityException ignored) {
                // Expected for malicious pattern
            }
        }
        long endTime = System.nanoTime();

        long averageNanos = (endTime - startTime) / 100;
        long averageMillis = averageNanos / 1_000_000;

        // Should complete within reasonable time (< 5ms per validation)
        assertTrue(averageMillis < 5,
                "IPv6 validation should complete within 5ms, actual: " + averageMillis + "ms");
    }

    /**
     * QI-9: Determines if a failure type matches specific IPv6 attack patterns.
     * Replaces broad OR-assertion with comprehensive security validation.
     * 
     * @param failureType The actual failure type from validation
     * @param pattern The IPv6 attack pattern being tested
     * @return true if the failure type is expected for IPv6 attack patterns
     */
    private boolean isIPv6SpecificFailure(UrlSecurityFailureType failureType, String pattern) {
        // QI-9: IPv6 attack patterns can trigger multiple specific failure types
        // Accept all IPv6-relevant failure types for comprehensive security validation
        return failureType == UrlSecurityFailureType.SUSPICIOUS_PATTERN_DETECTED ||
               failureType == UrlSecurityFailureType.INVALID_CHARACTER ||
               failureType == UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED ||
               failureType == UrlSecurityFailureType.PROTOCOL_VIOLATION ||
               failureType == UrlSecurityFailureType.RFC_VIOLATION ||
               failureType == UrlSecurityFailureType.KNOWN_ATTACK_SIGNATURE ||
               failureType == UrlSecurityFailureType.INVALID_ENCODING ||
               failureType == UrlSecurityFailureType.UNICODE_NORMALIZATION_CHANGED ||
               failureType == UrlSecurityFailureType.CONTROL_CHARACTERS;
    }
}