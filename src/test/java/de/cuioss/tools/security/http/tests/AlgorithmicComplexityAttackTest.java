/*
 * Copyright © 2025 CUI-OpenSource-Software (info@cuioss.de)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.cuioss.tools.security.http.tests;

import de.cuioss.test.generator.junit.EnableGeneratorController;
import de.cuioss.test.generator.junit.parameterized.TypeGeneratorSource;
import de.cuioss.tools.concurrent.StopWatch;
import de.cuioss.tools.security.http.config.SecurityConfiguration;
import de.cuioss.tools.security.http.core.UrlSecurityFailureType;
import de.cuioss.tools.security.http.exceptions.UrlSecurityException;
import de.cuioss.tools.security.http.generators.injection.AlgorithmicComplexityAttackGenerator;
import de.cuioss.tools.security.http.monitoring.SecurityEventCounter;
import de.cuioss.tools.security.http.pipeline.URLPathValidationPipeline;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;

import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive test suite for algorithmic complexity attack detection in URL security validation.
 *
 * <p>This test class validates that the URL security pipeline correctly identifies and blocks
 * algorithmic complexity attacks that could lead to denial of service through computationally
 * expensive operations, excessive CPU usage, memory exhaustion, or processing time attacks.
 * Tests cover all 15 complexity attack types generated by {@link AlgorithmicComplexityAttackGenerator}.
 *
 * <p><strong>Attack Types Covered:</strong>
 * <ul>
 *   <li>Regex ReDoS (Regular Expression Denial of Service)</li>
 *   <li>Exponential backtracking patterns</li>
 *   <li>Hash collision attacks (algorithmic complexity)</li>
 *   <li>Deep recursion patterns</li>
 *   <li>Nested loop complexity attacks</li>
 *   <li>Polynomial time complexity exploits (O(n²), O(n³))</li>
 *   <li>Exponential time complexity exploits (O(2^n), O(3^n))</li>
 *   <li>Memory allocation complexity attacks</li>
 *   <li>String comparison timing attacks</li>
 *   <li>Sorting algorithm complexity exploits</li>
 *   <li>Graph traversal complexity attacks</li>
 *   <li>XML parser complexity bombs</li>
 *   <li>JSON parser complexity attacks</li>
 *   <li>URL parsing complexity exploits</li>
 *   <li>Pattern matching complexity attacks</li>
 * </ul>
 *
 * <p><strong>Performance Requirements:</strong>
 * Each algorithmic complexity attack detection must complete within 20ms to prevent DoS through
 * processing time exhaustion. This is slightly higher than other attack types due to the 
 * computational nature of complexity detection.
 *
 * <p><strong>Security Standards:</strong>
 * Based on OWASP guidelines for complexity attack prevention, CWE-407 (Inefficient Algorithmic Complexity),
 * and CWE-1333 (Inefficient Regular Expression Complexity).
 *
 * @author Security Test Framework
 * @see AlgorithmicComplexityAttackGenerator
 * @see <a href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS">OWASP ReDoS Attack</a>
 * @see <a href="https://cwe.mitre.org/data/definitions/407.html">CWE-407: Inefficient Algorithmic Complexity</a>
 * @see <a href="https://cwe.mitre.org/data/definitions/1333.html">CWE-1333: Inefficient Regular Expression Complexity</a>
 */
@EnableGeneratorController
@DisplayName("T21: Algorithmic Complexity Attack Detection Tests")
class AlgorithmicComplexityAttackTest {

    private URLPathValidationPipeline pipeline;

    @BeforeEach
    void setUp() {
        pipeline = new URLPathValidationPipeline(SecurityConfiguration.defaults(), new SecurityEventCounter());
    }

    @ParameterizedTest
    @TypeGeneratorSource(value = AlgorithmicComplexityAttackGenerator.class, count = 3)
    @DisplayName("All algorithmic complexity attacks should be rejected")
    void shouldRejectAllAlgorithmicComplexityAttacks(String complexityAttackPattern) {
        // Given: An algorithmic complexity attack pattern
        assertNotNull(complexityAttackPattern, "Attack pattern should not be null");
        assertFalse(complexityAttackPattern.trim().isEmpty(), "Attack pattern should not be empty");

        // When & Then: Pipeline should reject the attack and throw appropriate exception
        var exception = assertThrows(UrlSecurityException.class,
                () -> pipeline.validate(complexityAttackPattern),
                "Algorithmic complexity attack should be rejected: " + complexityAttackPattern);

        // Verify failure type is appropriate for complexity attack detection
        assertTrue(isSpecificComplexityAttackFailure(exception.getFailureType(), complexityAttackPattern),
                "Failure type should be specific complexity attack related: " + exception.getFailureType() +
                        " for pattern: " + complexityAttackPattern);

        // Verify exception contains meaningful information
        assertNotNull(exception.getMessage(), "Exception message should not be null");
        assertFalse(exception.getMessage().trim().isEmpty(), "Exception message should not be empty");
    }

    @ParameterizedTest
    @TypeGeneratorSource(value = AlgorithmicComplexityAttackGenerator.class, count = 2)
    @DisplayName("Algorithmic complexity detection should complete within performance limits")
    void shouldCompleteComplexityDetectionWithinTimeLimit(String complexityAttackPattern) {
        // Given: An algorithmic complexity attack pattern
        StopWatch stopWatch = StopWatch.createStarted();

        // When: Pipeline processes the attack
        assertThrows(UrlSecurityException.class,
                () -> pipeline.validate(complexityAttackPattern));

        // Then: Processing should complete within 20ms to prevent DoS through processing time
        stopWatch.stop();
        long processingTimeMs = stopWatch.elapsed(TimeUnit.MILLISECONDS);
        assertTrue(processingTimeMs < 20,
                "Complexity attack detection took %dms, should be < 20ms for pattern: %s".formatted(
                        processingTimeMs, complexityAttackPattern));
    }

    @Test
    @DisplayName("Regex ReDoS patterns should be detected")
    void shouldDetectRegexRedosPatterns() {
        String[] redosPatterns = {
                "https://example.com/api/complexity?input=(a+)++b",
                "https://example.com/api/complexity?data=(x*)*y",
                "https://example.com/api/complexity?query=(test|test)*data",
                "https://example.com/api/complexity?param=(abc*)*",
                "https://example.com/api/complexity?value=(123|123)*456"
        };

        for (String redos : redosPatterns) {
            var exception = assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(redos),
                    "ReDoS pattern should be detected: " + redos);

            assertEquals(UrlSecurityFailureType.INVALID_CHARACTER, exception.getFailureType(),
                    "ReDoS pattern should trigger INVALID_CHARACTER for: " + redos);
        }
    }

    @Test
    @DisplayName("Exponential backtracking patterns should be detected")
    void shouldDetectExponentialBacktrackingPatterns() {
        String[] backtrackingPatterns = {
                "https://example.com/api/complexity?bt=(a+)+aaaaaaaaaaaaaaaaaaaX",
                "https://example.com/api/complexity?exp=(x*)*xxxxxxxxxxxxxxxxxxxxxxxxxY",
                "https://example.com/api/complexity?back=(.*)*...............Z",
                "https://example.com/api/complexity?track=(a|a)*aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaB",
                "https://example.com/api/complexity?complex=(b+)+bbbbbbbbbbbbbbbbbbbbbbC"
        };

        for (String backtracking : backtrackingPatterns) {
            var exception = assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(backtracking),
                    "Exponential backtracking pattern should be detected: " + backtracking);

            assertEquals(UrlSecurityFailureType.INVALID_CHARACTER, exception.getFailureType(),
                    "Backtracking pattern should trigger INVALID_CHARACTER for: " + backtracking);
        }
    }

    @Test
    @DisplayName("Hash collision attacks should be detected")
    void shouldDetectHashCollisionAttacks() {
        String[] hashCollisionPatterns = {
                "https://example.com/api/complexity?hash=AaBB",
                "https://example.com/api/complexity?collision=AaAaBBBB",
                "https://example.com/api/complexity?bucket=AaBBC#D$",
                "https://example.com/api/complexity?table=AaAaAaBBBBBB",
                "https://example.com/api/complexity?map=AaBBBaAB"
        };

        for (String hashCollision : hashCollisionPatterns) {
            var exception = assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(hashCollision),
                    "Hash collision attack should be detected: " + hashCollision);

            assertEquals(UrlSecurityFailureType.INVALID_CHARACTER, exception.getFailureType(),
                    "Hash collision should trigger INVALID_CHARACTER for: " + hashCollision);
        }
    }

    @Test
    @DisplayName("Deep recursion patterns should be detected")
    void shouldDetectDeepRecursionPatterns() {
        String[] recursionPatterns = {
                "https://example.com/api/complexity?recurse=((((((((DEEP))))))))",
                "https://example.com/api/complexity?deep=[[[[[[[DEEP]]]]]]]",
                "https://example.com/api/complexity?nested={{{{{{{DEEP}}}}}}}",
                "https://example.com/api/complexity?stack=<<<<<<<DEEP>>>>>>>",
                "https://example.com/api/complexity?depth=\\1\\1\\1\\1DEEP"
        };

        for (String recursion : recursionPatterns) {
            var exception = assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(recursion),
                    "Deep recursion pattern should be detected: " + recursion);

            assertEquals(UrlSecurityFailureType.INVALID_CHARACTER, exception.getFailureType(),
                    "Recursion pattern should trigger INVALID_CHARACTER for: " + recursion);
        }
    }

    @Test
    @DisplayName("Polynomial time complexity attacks should be detected")
    void shouldDetectPolynomialTimeComplexityAttacks() {
        String[] polynomialPatterns = {
                "https://example.com/api/complexity?poly=POLY:" + generatePolynomialTestData("ABC", 20),
                "https://example.com/api/complexity?quadratic=POLY:" + generatePolynomialTestData("XYZ", 15),
                "https://example.com/api/complexity?cubic=POLY:" + generatePolynomialTestData("123", 25),
                "https://example.com/api/complexity?quartic=POLY:" + generatePolynomialTestData("ABCD", 18),
                "https://example.com/api/complexity?complex=POLY:" + generatePolynomialTestData("WXYZ", 22)
        };

        for (String polynomial : polynomialPatterns) {
            var exception = assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(polynomial),
                    "Polynomial complexity attack should be detected: " + polynomial);

            assertEquals(UrlSecurityFailureType.INVALID_CHARACTER, exception.getFailureType(),
                    "Polynomial complexity should trigger INVALID_CHARACTER for: " + polynomial);
        }
    }

    @Test
    @DisplayName("Exponential time complexity attacks should be detected")
    void shouldDetectExponentialTimeComplexityAttacks() {
        String[] exponentialPatterns = {
                "https://example.com/api/complexity?exp=" + generateExponentialTestData("AB", 8),
                "https://example.com/api/complexity?double=" + generateExponentialTestData("XY", 7),
                "https://example.com/api/complexity?triple=" + generateExponentialTestData("ABC", 6),
                "https://example.com/api/complexity?factorial=" + generateExponentialTestData("ABCD", 5),
                "https://example.com/api/complexity?exponential=" + generateExponentialTestData("12", 10)
        };

        for (String exponential : exponentialPatterns) {
            var exception = assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(exponential),
                    "Exponential complexity attack should be detected: " + exponential);

            assertEquals(UrlSecurityFailureType.INVALID_CHARACTER, exception.getFailureType(),
                    "Exponential complexity should trigger INVALID_CHARACTER for: " + exponential);
        }
    }

    @Test
    @DisplayName("Memory allocation complexity attacks should be detected")
    void shouldDetectMemoryAllocationComplexityAttacks() {
        String[] memoryPatterns = {
                "https://example.com/api/complexity?nested=(((((((memory))))))))",
                "https://example.com/api/complexity?expand={a:{b:{c:{d:{e:value}}}}}",
                "https://example.com/api/complexity?entity=&lt;!ENTITY%20bomb%20%22expansion%22%3E",
                "https://example.com/api/complexity?repeat=\\1\\1\\1\\1memory",
                "https://example.com/api/complexity?hash=Aa&hash=BB&hash=C#&hash=D$"
        };

        for (String memory : memoryPatterns) {
            var exception = assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(memory),
                    "Memory allocation complexity attack should be detected: " + memory);

            assertEquals(UrlSecurityFailureType.INVALID_CHARACTER, exception.getFailureType(),
                    "Memory allocation pattern should trigger INVALID_CHARACTER for: " + memory);
        }
    }

    @Test
    @DisplayName("XML parser complexity bombs should be detected")
    void shouldDetectXmlParserComplexityBombs() {
        String[] xmlBombs = {
                "https://example.com/api/complexity?xml=XML:" + generateXmlBombTestData(10),
                "https://example.com/api/complexity?xmldoc=XML:" + generateXmlBombTestData(8),
                "https://example.com/api/complexity?xmldata=XML:" + generateXmlBombTestData(15),
                "https://example.com/api/complexity?xmlparse=XML:" + generateXmlBombTestData(6),
                "https://example.com/api/complexity?xmlbomb=XML:" + generateXmlBombTestData(12)
        };

        for (String xmlBomb : xmlBombs) {
            var exception = assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(xmlBomb),
                    "XML parser complexity bomb should be detected: " + xmlBomb);

            assertEquals(UrlSecurityFailureType.INVALID_CHARACTER, exception.getFailureType(),
                    "XML bomb should trigger INVALID_CHARACTER for: " + xmlBomb);
        }
    }

    @Test
    @DisplayName("JSON parser complexity attacks should be detected")
    void shouldDetectJsonParserComplexityAttacks() {
        String[] jsonBombs = {
                "https://example.com/api/complexity?json=JSON:" + generateJsonBombTestData(20),
                "https://example.com/api/complexity?jsondata=JSON:" + generateJsonBombTestData(15),
                "https://example.com/api/complexity?jsonparse=JSON:" + generateJsonBombTestData(30),
                "https://example.com/api/complexity?jsonbomb=JSON:" + generateJsonBombTestData(12),
                "https://example.com/api/complexity?jsondeep=JSON:" + generateJsonBombTestData(25)
        };

        for (String jsonBomb : jsonBombs) {
            var exception = assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(jsonBomb),
                    "JSON parser complexity attack should be detected: " + jsonBomb);

            assertEquals(UrlSecurityFailureType.INVALID_CHARACTER, exception.getFailureType(),
                    "JSON bomb should trigger INVALID_CHARACTER for: " + jsonBomb);
        }
    }

    @Test
    @DisplayName("Complex URL parsing attacks should be detected")
    void shouldDetectComplexUrlParsingAttacks() {
        String[] urlParsingAttacks = {
                generateComplexUrlTestData("https://example.com/api/complexity", 100),
                generateComplexUrlTestData("https://example.com/api/complexity", 80),
                generateComplexUrlTestData("https://example.com/api/complexity", 150),
                generateComplexUrlTestData("https://example.com/api/complexity", 60),
                generateComplexUrlTestData("https://example.com/api/complexity", 120)
        };

        for (String urlParsing : urlParsingAttacks) {
            var exception = assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(urlParsing),
                    "Complex URL parsing attack should be detected: " + urlParsing);

            assertEquals(UrlSecurityFailureType.INVALID_CHARACTER, exception.getFailureType(),
                    "URL parsing complexity should trigger INVALID_CHARACTER for: " + urlParsing);
        }
    }

    @Test
    @DisplayName("Pattern matching complexity attacks should be detected")
    void shouldDetectPatternMatchingComplexityAttacks() {
        String[] patternAttacks = {
                "https://example.com/api/complexity?regex=(a+)+b&input=aaaaaac",
                "https://example.com/api/complexity?regex=(a|a)*b&input=aaaaaac",
                "https://example.com/api/complexity?regex=a(b|c)*d&input=abbbbbbbc",
                "https://example.com/api/complexity?search=^(a+)+$&input=aaaaaaaX",
                "https://example.com/api/complexity?pattern=([a-z]+)*[a-z]&input=abcdx"
        };

        for (String pattern : patternAttacks) {
            var exception = assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(pattern),
                    "Pattern matching complexity attack should be detected: " + pattern);

            assertEquals(UrlSecurityFailureType.INVALID_CHARACTER, exception.getFailureType(),
                    "Pattern matching complexity should trigger INVALID_CHARACTER for: " + pattern);
        }
    }

    @Test
    @DisplayName("Generator should produce consistent and valid attack patterns")
    void shouldProduceConsistentAttackPatterns() {
        AlgorithmicComplexityAttackGenerator generator = new AlgorithmicComplexityAttackGenerator();

        // Test generator consistency and coverage
        boolean[] attackTypeSeen = new boolean[15];
        int totalTests = 150;

        for (int i = 0; i < totalTests; i++) {
            String attackPattern = generator.next();
            assertNotNull(attackPattern, "Generated attack pattern should not be null");
            assertFalse(attackPattern.trim().isEmpty(), "Generated attack pattern should not be empty");

            // Track which attack types we've seen to ensure good distribution
            markAttackTypeSeen(attackPattern, attackTypeSeen);

            // Verify the attack is actually rejected by the pipeline
            assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(attackPattern),
                    "Generated attack pattern should be rejected: " + attackPattern);
        }

        // Verify we've seen a reasonable distribution of attack types
        long seenCount = 0;
        for (boolean seen : attackTypeSeen) {
            if (seen) seenCount++;
        }
        assertTrue(seenCount >= 10,
                "Should see at least 10 different attack types, saw %d".formatted(seenCount));
    }

    /**
     * Determines if the failure type is specifically appropriate for algorithmic complexity attacks.
     * Different complexity attack vectors trigger specific failure types.
     * 
     * @param failureType The failure type to validate
     * @param pattern The specific attack pattern being tested
     * @return true if the failure type is appropriate for the pattern
     */
    private boolean isSpecificComplexityAttackFailure(UrlSecurityFailureType failureType, String pattern) {
        // Algorithmic complexity attacks can trigger multiple specific failure types based on attack vector:
        // - Large input patterns → INPUT_TOO_LONG or PATH_TOO_LONG
        // - Nested structures → EXCESSIVE_NESTING
        // - Pattern-based attacks → SUSPICIOUS_PATTERN_DETECTED
        // - Malformed structures → MALFORMED_INPUT or INVALID_STRUCTURE
        // - Control character attacks → CONTROL_CHARACTERS or INVALID_CHARACTER
        
        return failureType == UrlSecurityFailureType.INPUT_TOO_LONG ||
                failureType == UrlSecurityFailureType.PATH_TOO_LONG ||
                failureType == UrlSecurityFailureType.SUSPICIOUS_PATTERN_DETECTED ||
                failureType == UrlSecurityFailureType.KNOWN_ATTACK_SIGNATURE ||
                failureType == UrlSecurityFailureType.INVALID_CHARACTER ||
                failureType == UrlSecurityFailureType.EXCESSIVE_NESTING ||
                failureType == UrlSecurityFailureType.MALFORMED_INPUT ||
                failureType == UrlSecurityFailureType.INVALID_STRUCTURE ||
                failureType == UrlSecurityFailureType.CONTROL_CHARACTERS;
    }

    /**
     * Tracks which algorithmic complexity attack types have been seen to ensure generator coverage.
     */
    private void markAttackTypeSeen(String attackPattern, boolean[] attackTypeSeen) {
        // Mark attack types based on pattern content - updated for new small patterns
        if (attackPattern.contains("input=") || attackPattern.contains("data=") || attackPattern.contains("(a+)+")) attackTypeSeen[0] = true; // ReDoS
        if (attackPattern.contains("?bt=") || attackPattern.contains("?exp=") || attackPattern.contains("?back=")) attackTypeSeen[1] = true; // Backtracking
        if (attackPattern.contains("key1=Aa") || attackPattern.contains("key2=BB") || attackPattern.contains("C#") || attackPattern.contains("D$")) attackTypeSeen[2] = true; // Hash collision
        if (attackPattern.contains("?recurse=") || attackPattern.contains("?deep=") || attackPattern.contains("?nested=") || attackPattern.contains("?stack=")) attackTypeSeen[3] = true; // Deep recursion
        if (attackPattern.contains("?nested=") || attackPattern.contains("?loop=") || attackPattern.contains("?quadratic=")) attackTypeSeen[4] = true; // Nested loops
        if (attackPattern.contains("?poly=") || attackPattern.contains("_nested_loop_hint_") || attackPattern.contains("_poly_hint_")) attackTypeSeen[5] = true; // Polynomial
        if (attackPattern.contains("?exp=") || attackPattern.contains("?double=") || attackPattern.contains("_exponential_hint_") || attackPattern.contains("_exp_hint_")) attackTypeSeen[6] = true; // Exponential
        if (attackPattern.contains("?nested=") || attackPattern.contains("?expand=") || attackPattern.contains("?entity=") || attackPattern.contains("?repeat=")) attackTypeSeen[7] = true; // Memory
        if (attackPattern.contains("?timing=") || attackPattern.contains("?compare=") || attackPattern.contains("_timing_hint_")) attackTypeSeen[8] = true; // Timing
        if (attackPattern.contains("?sort=") || attackPattern.contains("?order=") || attackPattern.contains("reverse_sorted_hint_")) attackTypeSeen[9] = true; // Sorting
        if (attackPattern.contains("?graph=") || attackPattern.contains("?traverse=") || attackPattern.contains("dense_graph_hint_")) attackTypeSeen[10] = true; // Graph
        if (attackPattern.contains("?xml=") || attackPattern.contains("?xmldoc=") || attackPattern.contains("entity_expansion_hint_")) attackTypeSeen[11] = true; // XML
        if (attackPattern.contains("?json=") || attackPattern.contains("?jsondata=") || attackPattern.contains("deep_nesting_hint_")) attackTypeSeen[12] = true; // JSON
        if (attackPattern.contains("url_parsing_complexity_hint_") || attackPattern.contains("&param")) attackTypeSeen[13] = true; // URL parsing
        if (attackPattern.contains("?regex=") || attackPattern.contains("&input=") || attackPattern.contains("?search=") || attackPattern.contains("?pattern=")) attackTypeSeen[14] = true; // Pattern matching
    }

    // Helper methods for generating test data

    private String generatePolynomialTestData(String base, int size) {
        // Small pattern that hints at polynomial complexity
        return base + "_poly_hint_size_" + size;
    }

    private String generateExponentialTestData(String base, int depth) {
        // Small pattern that hints at exponential complexity
        return base + "_exp_hint_depth_" + depth;
    }

    private String generateXmlBombTestData(int depth) {
        // Small pattern that hints at XML entity expansion
        return "<entity_expansion_hint_depth_" + depth + ">BOMB</entity>";
    }

    private String generateJsonBombTestData(int depth) {
        // Small pattern that hints at JSON deep nesting
        return "{\"deep_nesting_hint_depth_" + depth + "\":\"COMPLEXITY\"}";
    }

    private String generateComplexUrlTestData(String basePattern, int complexity) {
        // Small pattern that hints at URL parsing complexity
        return basePattern + "?url_parsing_complexity_hint_params_" + complexity;
    }
}