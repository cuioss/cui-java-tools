/*
 * Copyright Â© 2025 CUI-OpenSource-Software (info@cuioss.de)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.cuioss.tools.security.http.tests;

import de.cuioss.test.generator.junit.EnableGeneratorController;
import de.cuioss.test.generator.junit.parameterized.TypeGeneratorSource;
import de.cuioss.tools.security.http.config.SecurityConfiguration;
import de.cuioss.tools.security.http.core.UrlSecurityFailureType;
import de.cuioss.tools.security.http.exceptions.UrlSecurityException;
import de.cuioss.tools.security.http.generators.PathTraversalGenerator;
import de.cuioss.tools.security.http.monitoring.SecurityEventCounter;
import de.cuioss.tools.security.http.pipeline.URLPathValidationPipeline;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;

import static org.junit.jupiter.api.Assertions.*;

/**
 * T1: Test basic path traversal patterns
 * 
 * <p>
 * This test class implements Task T1 from the HTTP security validation plan,
 * focusing on testing basic path traversal attack patterns using the
 * PathTraversalGenerator and advanced cui-test-generator patterns.
 * </p>
 * 
 * <h3>Test Coverage</h3>
 * <ul>
 *   <li>Basic path traversal sequences (../, ..\\)</li>
 *   <li>URL encoded traversal patterns (%2e%2e%2f)</li>
 *   <li>Unicode traversal variants (\\u002e)</li>
 *   <li>Mixed encoding attacks</li>
 *   <li>Null byte injection patterns</li>
 *   <li>Advanced traversal combinations</li>
 * </ul>
 * 
 * <h3>Validation Expectations</h3>
 * <ul>
 *   <li>All path traversal patterns should be <strong>REJECTED</strong></li>
 *   <li>Security events should be properly recorded</li>
 *   <li>Appropriate failure types should be identified</li>
 *   <li>Original inputs should be preserved in exceptions</li>
 * </ul>
 * 
 * <h3>Security Standards</h3>
 * <ul>
 *   <li>OWASP Path Traversal Prevention</li>
 *   <li>RFC 3986 URI validation</li>
 *   <li>CVE-2019-5418, CVE-2018-1000671, CVE-2020-5398</li>
 * </ul>
 * 
 * Implements: Task T1 from HTTP verification specification
 * 
 * @author Claude Code Generator
 * @since 2.5
 */
@EnableGeneratorController
@DisplayName("T1: Basic Path Traversal Attack Tests")
class PathTraversalAttackTest {

    private URLPathValidationPipeline pipeline;
    private SecurityEventCounter eventCounter;
    private SecurityConfiguration config;

    @BeforeEach
    void setUp() {
        config = SecurityConfiguration.defaults();
        eventCounter = new SecurityEventCounter();
        pipeline = new URLPathValidationPipeline(config, eventCounter);
    }

    /**
     * Test all path traversal patterns generated by PathTraversalGenerator.
     * 
     * <p>
     * Tests 50 different path traversal patterns from all pattern groups:
     * basic, encoded, unicode, mixed encoding, null bytes, and advanced patterns.
     * </p>
     * 
     * @param pathTraversalPattern A malicious path traversal pattern
     */
    @ParameterizedTest
    @TypeGeneratorSource(value = PathTraversalGenerator.class, count = 64)
    @DisplayName("All path traversal patterns should be rejected")
    void shouldRejectAllPathTraversalPatterns(String pathTraversalPattern) {
        // Given: A path traversal attack pattern from the generator
        long initialEventCount = eventCounter.getTotalCount();

        // When: Attempting to validate the malicious path
        var exception = assertThrows(UrlSecurityException.class,
                () -> pipeline.validate(pathTraversalPattern),
                "Path traversal pattern should be rejected: " + pathTraversalPattern);

        // Then: The validation should fail with appropriate security event
        assertNotNull(exception, "Exception should be thrown for path traversal");
        assertTrue(isPathTraversalRelatedFailure(exception.getFailureType()),
                "Failure type should be path traversal related: " + exception.getFailureType());

        // And: Original malicious input should be preserved
        assertEquals(pathTraversalPattern, exception.getOriginalInput(),
                "Original input should be preserved in exception");

        // And: Security event should be recorded
        assertTrue(eventCounter.getTotalCount() > initialEventCount,
                "Security event should be recorded");
    }

    /**
     * Test specific high-risk path traversal patterns.
     * 
     * <p>
     * This test ensures that the most dangerous path traversal patterns
     * are consistently blocked.
     * </p>
     */
    @ParameterizedTest
    @TypeGeneratorSource(value = PathTraversalGenerator.class, count = 20)
    @DisplayName("High-risk path traversal patterns should be consistently blocked")
    void shouldConsistentlyBlockHighRiskPatterns(String pathTraversalPattern) {
        // Given: A reproducibly generated high-risk pattern
        long initialTotalCount = eventCounter.getTotalCount();

        // When & Then: Pattern should be rejected
        assertThrows(UrlSecurityException.class,
                () -> pipeline.validate(pathTraversalPattern),
                "High-risk pattern should be blocked: " + pathTraversalPattern);

        // And: Security events should be incremented (any security event type is valid)
        assertTrue(eventCounter.getTotalCount() > initialTotalCount,
                "Security counter should track path traversal attempts");
    }

    /**
     * Test known CVE path traversal patterns.
     * 
     * <p>
     * Validates that specific patterns from known CVEs are properly blocked,
     * ensuring protection against documented security vulnerabilities.
     * </p>
     */
    @Test
    @DisplayName("Known CVE path traversal patterns should be blocked")
    void shouldBlockKnownCVEPatterns() {
        String[] cvePatterns = {
                // CVE-2019-5418: Rails path traversal
                "../../../../../../../etc/passwd{{",

                // CVE-2018-1000671: Mercurial path traversal  
                "../.hg/hgrc",

                // CVE-2020-5398: Spring Framework path traversal
                "/..;/..;/..;/..;/..;/..;/etc/passwd",

                // CVE-2021-22204: GitLab path traversal
                "../../../../../../../../../../../etc/passwd",

                // CVE-2019-0230: Apache Struts path traversal
                "/%2e%2e/%2e%2e/%2e%2e/etc/passwd"
        };

        for (String cvePattern : cvePatterns) {
            long initialEventCount = eventCounter.getTotalCount();

            var exception = assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(cvePattern),
                    "CVE pattern should be blocked: " + cvePattern);

            assertNotNull(exception.getFailureType(),
                    "Failure type should be specified for CVE pattern: " + cvePattern);

            assertTrue(eventCounter.getTotalCount() > initialEventCount,
                    "Security event should be recorded for CVE pattern: " + cvePattern);
        }
    }

    /**
     * Test path traversal patterns with legitimate-looking prefixes.
     * 
     * <p>
     * Ensures that path traversal attempts are detected even when embedded
     * within seemingly legitimate URL paths.
     * </p>
     */
    @Test
    @DisplayName("Path traversal with legitimate prefixes should be blocked")
    void shouldBlockPathTraversalWithLegitimatePrefix() {
        String[] legitimatePrefixPatterns = {
                "/api/v1/users/../../../etc/passwd",
                "/admin/dashboard/../../config/database.yml",
                "/uploads/images/../../../.env",
                "/files/documents/..\\..\\..\\windows\\win.ini",
                "/public/assets/%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
        };

        for (String pattern : legitimatePrefixPatterns) {
            assertThrows(UrlSecurityException.class,
                    () -> pipeline.validate(pattern),
                    "Legitimate prefix should not mask path traversal: " + pattern);
        }
    }

    /**
     * Test that security events are properly categorized for different pattern types.
     */
    @Test
    @DisplayName("Different pattern types should generate appropriate security events")
    void shouldCategorizeSecurityEventsCorrectly() {
        // Test basic path traversal
        assertThrows(UrlSecurityException.class, () -> pipeline.validate("../../../etc/passwd"));
        long pathTraversalCount = eventCounter.getCount(UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED);

        // Test encoding attack
        assertThrows(UrlSecurityException.class, () -> pipeline.validate("%2e%2e%2f%2e%2e%2fetc%2fpasswd"));
        long encodingAttackCount = eventCounter.getCount(UrlSecurityFailureType.DOUBLE_ENCODING);

        // Test malicious pattern  
        assertThrows(UrlSecurityException.class, () -> pipeline.validate("....//....//etc/passwd"));
        long maliciousPatternCount = eventCounter.getCount(UrlSecurityFailureType.SUSPICIOUS_PATTERN_DETECTED);

        // At least one of these should be incremented
        assertTrue(pathTraversalCount > 0 || encodingAttackCount > 0 || maliciousPatternCount > 0,
                "At least one security event type should be recorded");
    }

    /**
     * Test performance impact of path traversal validation.
     * 
     * <p>
     * Ensures that validation performance remains acceptable even
     * when processing malicious path traversal patterns.
     * </p>
     */
    @Test
    @DisplayName("Path traversal validation should maintain performance")
    void shouldMaintainPerformanceUnderAttack() {
        String complexPattern = "../../../../../../../../../../../../../../../../../../../../../../../etc/passwd";

        // Warm up
        for (int i = 0; i < 10; i++) {
            try {
                pipeline.validate(complexPattern);
            } /*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*/catch (Exception ignored) {
            }
        }

        // Measure performance
        long startTime = System.nanoTime();
        for (int i = 0; i < 100; i++) {
            try {
                pipeline.validate(complexPattern);
            } /*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*//*~~(Catch specific not Exception)~~>*/catch (Exception ignored) {
            }
        }
        long endTime = System.nanoTime();

        long averageNanos = (endTime - startTime) / 100;
        long averageMillis = averageNanos / 1_000_000;

        // Should complete within reasonable time (< 5ms per validation)
        assertTrue(averageMillis < 5,
                "Path traversal validation should complete within 5ms, actual: " + averageMillis + "ms");
    }

    /**
     * Helper method to determine if a failure type is related to path traversal.
     * 
     * @param failureType The failure type to check
     * @return true if the failure type is path traversal related
     */
    private boolean isPathTraversalRelatedFailure(UrlSecurityFailureType failureType) {
        return failureType == UrlSecurityFailureType.PATH_TRAVERSAL_DETECTED ||
                failureType == UrlSecurityFailureType.DIRECTORY_ESCAPE_ATTEMPT ||
                failureType == UrlSecurityFailureType.DOUBLE_ENCODING ||
                failureType == UrlSecurityFailureType.SUSPICIOUS_PATTERN_DETECTED ||
                failureType == UrlSecurityFailureType.INVALID_CHARACTER ||
                failureType == UrlSecurityFailureType.NULL_BYTE_INJECTION ||
                failureType == UrlSecurityFailureType.INVALID_ENCODING;
    }


}